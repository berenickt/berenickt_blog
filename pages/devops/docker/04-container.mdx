---
title: '04-컨테이너 다루기'
date: 2025/01/05
---

## 1. 컨테이너

docker desktop이 안에서 docker의 모든 기능을 쓸 수 있는게 아니라, 
터미널에서 명령어 실행해서 이거저거 쓰는 일이 더 많습니다.
그래서 오늘은 컨테이너 다루는 명령어 몇개와 컨테이너 접속, 컨테이너의 실체 이런걸 알아봅시다.

------

### 1.1 이미지 실행 터미널에서 하려면

```bash
docker run -d 이미지명:태그명 
```

터미널에 입력하면 이미지를 컨테이너에서 실행할 수 있다고 했는데, 

* 근데 이러면 터미널 하나를 무단 점유하기 때문에, 터미널이 또 필요해지면 하나 더 귀찮게 열어야합니다.
* 그게 싫으면 `-d` 옵션을 집어넣어서 **백그라운드에서 실행가능**합니다.
* cf. `detached(분리된)`의 약자입니다.

------

### 1.2 이미지 실행시 포트 설정

```bash
docker run -p 8081:8080 -d 이미지명:태그명
# docker run -d -p 8080:8080 nodeserver:v1
```

이미지를 실행할 때 포트를 설정해주고 싶으면, `-p` 넣고 `내컴퓨터포트:컨테이너포트` 집어넣으면 됩니다.

* 그래서 위처럼 실행하면 누가 내 컴퓨터 8081 포트로 들어오면, 컨테이너의 8080 포트로 안내해주라는 뜻입니다.
* 포트설정 없이 그냥 띄우면, 브라우저로 접속했을 때 아무것도 안뜹니다.
* 하지만 왜 그런지 이유를 알아야 나중에 응용이 되기 때문에, 왜 포트 설정을 해야하는지는 그림을 봅시다.

![docker_4-1](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_4-1.png)

▲ 포트 설정을 안해놨을 때 왜 `localhost:8080`으로 접속했을 때 아무것도 없냐면, 
일단 `localhost`는 내 컴퓨터로 접속하라는 뜻이고, `8080`은 8080번 포트로 접속하라는 뜻입니다.
근데 거기로 들어가봤자 웹서버는 없음.

왜냐면 웹서버는 **내 컴퓨터 안의 가상컴퓨터에서** 돌아가고 있습니다.
내 컴퓨터 안의 은밀한 곳에서 혼자 돌아가고 있기 때문에, 
내 컴퓨터 & 가상컴퓨터의 포트끼리 연결하는 작업을 해주면 됩니다.

![docker_4-2](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_4-2.png)

▲ 포트끼리 연결하는건 별거 아니고, "**내 컴퓨터 A번 포트로 들어오면 컨테이너의 B번 포트로 보내라**" 이건데,
이걸 하고 싶으면 컨테이너 실행할 때, `-p 내컴퓨터포트번호:컨테이너포트번호`하면 됩니다.
똥배관 연결같은 것임.

> 💡 Q. 다른 컴퓨터 접속은 어떻게 하는 것임?
>
> * 그니까 지금 계속 다른 사람들이 내 컴퓨터에 접속한다고 했는데, 그건 어떻게 하는것이게요?
> * 실은 웹브라우저 켜서 `어떤컴퓨터IP주소:포트번호` 입력하면 그게 다른 컴퓨터에 접속하는 법입니다.
>
> 내가 내 컴퓨터에 접속하는 방법도 있습니다.
>
> * `내컴퓨터IP주소:포트번호` 입력하면 되는데,
>   * 번거롭게 IP주소 찾을 필요 없이 내 컴퓨터는 `localhost`라고 입력하면 됩니다.
> * 그래서 남의 입장이 되어서 내 컴퓨터로 들어가는걸 시뮬레이션 해보려면,
>   * 브라우저에 `localhost:8080` 이런거 입력해보는 것입니다.

------

### 1.3 컨테이너 관련한 명령어들

이미지를 실행중인 컨테이너 관련한 명령어 몇개만 알아봅시다.

```bash
$ docker ps            # 현재 실행중인 컨테이너들 표시
$ docker logs 컨테이너이름 # 컨테이너 컴퓨터 터미널의 로그 출력
```

심지어 특정 컨테이너 터미널로 접속이 가능합니다.

```bash
docker exec -it 컨테이너이름 sh
```

* 그럼 이제 명령어 입력할 때 마다 그 컨테이너 터미널 안에서 실행이 됩니다.
* 진짠지 궁금하면 들어가서 파일목록 보여주는 `ls` 명령어 입력해봅시다.
* 컨테이너를 탈출하려면 `ctrl +p` 후에 `ctrl + q` 입력합니다. 

```bash
$ docker stop 컨테이너이름 # 실행중인 컨테이너 정지, 컨테이너 아이디 입력해도 됨
$ docker rm 컨테이너이름   # 정지된 컨테이너를 삭제, 정지안된 컨테이너 삭제하려면 -f 옵션을 붙임
```

이런 식으로 쭉 나열해봤는데, 뭔가 많이 배운거같은 느낌 주려고 한거고, 
어차피 다음날 다 까먹기 때문에 그냥 이런게 있다고만 알고 지나가면 됩니다. 필요할 때 찾아서 쓰십시오.
위 명령어들은 `docker desktop` 안에서 `container 메뉴` 들어가면, 전부 클릭질로 할 수 있게 되어있습니다.

------

## 2. 컨테이너 구조

`컨테이너의 실체`같은게 궁금하면 별거 아닙니다. **리눅스 OS가 제공하는 이거저거 기능을 섞은 것**입니다.

![docker_4-3](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_4-3.png)

* 리눅스의 `namespace` 기능을 사용하면, 
  * 프로그램마다 서로 영향을 끼치지 않게 독립적으로 프로세스와 파일구조 같은걸 분리해줄 수 있습니다.
* 리눅스의 `cgroup(control group)`이라는 기능을 사용하면, 
  * 프로그램마다 CPU나 램을 얼마나 점유할 건지도 정해둘 수 있습니다.

이런걸 이용하면 **혼자 별도로 독립적으로 동작하는 가상 컴퓨터**를 만들 수 있는데, 
그걸 `컨테이너`라고 멋있게 포장해서 부를 뿐입니다.

`컨테이너`는 여러개 띄울 수 있어서 **컴퓨터 한 대에서 여러 컴퓨터를 운영하는 것**처럼 마법을 부릴 수 있고, 
`컨테이너`에서 문제가 생겨도 내 컴퓨터로 전염되는 일이 거의 없고, 그런 장점이 있습니다.

![docker_4-4](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_4-4.png)

원래 `runc`같은 프로그램을 쓰면, 컨테이너를 띄울 수 있습니다.
실은 `containerd`라는 프로그램으로 `runc`를 조작하면 편리해서 그런 경우들도 있습니다.
그럼 `Docker`는 뭐냐면 `containerd`, `runc`를 7살짜리도 쓸 수 있게 만든 프로그램일 뿐입니다.
거기에 이미지 빌드기능, pull 기능, 관리기능 이런걸 더해서 개발자들 편하게 만들어준 것임.

그래서 `Docker`대신 다른 프로그램 사용해도 됩니다.
`Podman` 이런 것도 유명하고, 맥북의 경우 `Orbstack` 이런게 최근에 가볍다고 유행하던 것 같습니다.
