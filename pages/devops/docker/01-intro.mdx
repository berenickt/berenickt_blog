---
title: '01-Docker와 Container 등장배경'
date: 2025/01/05
---

## 1. 도커와 컨테이너 이전

도커와 컨테이너 이전에 살던 개발자들은 원시인과 다를 바가 없었습니다.

1. 어디 새로 취업하면 개발 환경셋팅 맞추느라 하루종일 삽질하고
2. 업데이트하면 항상 뭔가 망가져서 업데이트 전에 열심히 기도하고
3. 내가 코드짠걸 서버컴퓨터로 옮기기만 하면 컴퓨터가 폭발하기 때문에 고사도 지냈습니다.

하지만 도커와 컨테이너가 나오고 나서 이 짓거리가 거의 없어졌습니다.

---

### 1.1 치킨집 비유

코딩하다 망해가지고 서울에 치킨집을 차렸습니다. 근데 매우 잘되어서 부산에 분점을 냈습니다.
그럼 부산점은 어떻게 운영할까요?

가장 쉽게 할 수 있는게 내 레시피만 보내서 부산에서 그대로 따라하라고 하면 되는 것인데, 그러면 또 인생이 망합니다.
지점마다 서로 주방시설, 도구 재료가 다르면,
조리 과정에서 문제도 많이 생길거고 맛도 살짝 달라질 수 밖에 없으니까요.

제대로 장사하려면, 여러분이 서울에서 쓰던 재료랑 레시피랑 이런걸 전부 **밀키트**로 준비해서,
그걸 부산으로 보내고 부산에서는 그냥 그걸 데우는 식으로만 운영하면 됩니다.
큰 프랜차이즈 치킨집들은 전부 이런 식으로 운영합니다.

---

### 1.2 개발할 때도 똑같음

개발할 때도 똑같습니다.

- 팀원끼리 협업할 때
- AWS에 있는 서버 컴퓨터에다가 내 코드를 배포할 때

같은 코드를 각각 다른 컴퓨터에서 실행해야 하는 경우들이 생깁니다.
하지만 내 컴퓨터에서 코드 잘돌아간다고, 그걸 다른 컴퓨터에 대충 보내서 실행하면 의도대로 동작하지 않는 경우가 많습니다.

컴퓨터마다 OS도 다르고 설치된 기본프로그램들 버전도 다르고 그러니까요. 그럼 어떻게 하게요?

여러분들이 쓰던 OS랑 프로그램이랑 그런걸 컴퓨터마다 전부 똑같이 준비하면 됩니다.
그 다음에 코드를 그 위에서 실행하면 걱정할 필요가 없는데, 이러기 위해서 옛날엔 VM이란걸 썼습니다.

어떤 OS위에 다른 OS를 설치하는 건데, 굉장히 무겁고 성능도 좋지 않기 때문에,
요즘은 그거 대신 훨씬 가벼운 Docker와 컨테이너를 씁니다.

---

## 2. Docker

![Docker](https://raw.githubusercontent.com/berenickt/image-server/main/img/docker-file.png)

`Docker`는 "**리눅스 컨테이너를 기반으로 만든, OS 레벨 가상화 기술**”이다.

> 💡 위 그림의 왼쪽은 VM 머신, 오른쪽은 Docker
>
> 가상머신을 활용한 도구로는 VMware, VirtualBox, Parallels(mac용) 등이 있습니다.
> 한 대의 컴퓨터에서 여러 운영체제를 동시에 수행 가능합니다.

![docker_1-1](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_1-1.png)

Docker를 쓰면 코드 밀키트같은걸 만들 수 있습니다.
거기다가 OS, 필요한 프로그램, 코드 이런걸 전부 담을 수 있고,
Docker를 쓰면 그 밀키트를 버튼 딸깍으로 쉽게 실행해줄 수도 있습니다.

그래서 `Docker`는 쉽게 말하면,

1. 코드 밀키트를 만들고
2. 코드 밀키트를 실행해주는 간단한 프로그램일 뿐입니다.

근데 VM 이런 것 보다 매우 가볍게 동작합니다.

그리고 이 **코드 밀키트를 실행하고 있는 가상 컴퓨터**를 `컨테이너(가상 컴퓨터)`라고 부릅니다.

---

### 2.1 어떻게 하냐면

말로만 씨부리면 이해가 어렵기 때문에 밀키트가 뭔지 어떻게 쓰는지 살짝 맛을 봅시다.
밀키트를 어떻게 만드냐면, `Dockerfile`이란 파일이 하나 필요합니다.

```dockerfile
리눅스 OS 설치해주세요
Python, Node.js 설치해주세요
JDK 21 설치해주세요
print("hello") 실행해주세요
```

Dockerfile 이라는 파일을 하나 만들고, 다음과 같이 쭉 적을 수 있습니다.

- 무슨 OS를 설치할지
- 어떤 프로그램이랑 라이브러리랑 SDK를 설치할지
- 어떤 코드를 어떻게 실행할지

그 다음에 `docker build 어쩌구 명령어`를 입력하면 밀키트로 포장이 되고,
그 다음에 `docker run 어쩌구 명령어`를 입력하면 밀키트를 실행할 수 있습니다.

`밀키트`를 실행하면 `컨테이너`라고 부르는 가상 컴퓨터가 하나 만들어지고,
그 안에서 여러분들이 설정해둔 OS와 작업환경에서 코드가 실행이 됩니다. 이게 Docker 사용법 끝입니다.

---

### 2.2 그로인해 변한 세상

원래 몸이 편해지면 슬슬 이상한 짓을 하기 마련입니다.
Docker 덕분에 개발과정이 편해지다보니까, 개발자들이 이상한 짓을 하기 시작했습니다.

![docker_1-2](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_1-2.png)

(1) 밀키트 덕분에 배포가 쉬워지니까 요즘은 어떻게 서버를 개발하냐면

- 이전엔 서버기능을 하나의 프로그램 안에 다 쑤셔넣었는데
- 지금은 잘게 쪼개서 여러 프로그램으로 나누고 그걸 따로따로 배포해서 운영합니다.
- 그러면 여러명이서 분업하기도 좋고 기능 업데이트도 빨라진다는 장점이 있습니다.
- 이걸 `마이크로서비스 아키텍쳐`라고 하는데 요즘 백엔드 밥줄이 되었습니다.

(2) 프로그램을 빌드하고 테스트하고 배포하는 작업이

- 도커 덕분에 초딩도 할 수 있을 정도로 쉬워졌기 때문에
- 원클릭 딸깍 자동 배포같은걸 도입하기 시작하는 곳들이 많아졌습니다.

(3) 그리고 도커쓰면 원하는 프로그램을 원하는 버전으로 원하는 OS 위에 쉽게 설치하고 삭제도 할 수 있어서

- 내가 만든 프로그램을 이거저거 버전별로 테스트해보기도 쉬워졌고
- 내 컴퓨터에 뭐 설치하기 싫어하는 결벽증 환자도 증가했고
- 덕분에 강의나 책같은거 만들기도 편해졌습니다.

---

### 2.3 Docker의 실체

Docker라는 프로그램의 실체는 별거 아닙니다. 리눅스 자체에 원래 가벼운 가상화 기술이 있었습니다.

```
namespaces
cgroups
unionFS
```

가상 파일시스템을 만들어주는 `union filesystem(FS)`, `namespace` 과
원하는 곳에 컴퓨터 자원을 할당해주는 `cgroups` 라는 기능을 쓰면,
리눅스 컴퓨터 안에 `가상 컴퓨터(컨테이너)`를 만들 수 있습니다.

![docker_1-3](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_1-3.png)

그걸 쓸 수 있게 도와주는 프로그램도 누가 만들어놓은게 있습니다. (runc, containerd)
근데 그것들을 7살도 쓸 수 있게 짜깁기해서 만들어놓은게 Docker라는 프로그램일 뿐입니다.
거기에 빌드, push, 모니터링 등 편의기능도 추가했을 뿐이고요.

그래서 Docker 대신 쓸 수 있는 프로그램도 있고, (e.g. podman, buildah, OrbStack, cri-o)
Docker 없이 직접 리눅스 `컨테이너(가상 컴퓨터)`를 띄우는 것도 가능합니다.

---

### 2.4 단점

장점이 있으면 단점이 있기 마련입니다.

1. 컨테이너 침입과 같은 새로운 보안 이슈를 챙겨야함
2. 컨테이너를 많이 사용하면 관리 시간과 서버비용이 증가함
3. 안정적인 DB같은거 띄울 땐 컨테이너로 만드는게 딱히 이점이 없음
4. 컨테이너 간 완전한 격리를 원하면 컨테이너 말고 가벼운 VM쓰는게 나을 수 있음

---

### 2.5 경고

그래서 코딩 처음하는 분들도 Docker로 환경셋팅해놓고 코딩 입문하고 그런 분들이 있는데,
요즘은 학원들에서 그렇게 시키는거 같던데, 나쁜 방법은 아닐 수 있습니다.

하지만 그 짓을 비유하면,
요리를 배우고 싶다면서 "누가 만들어놓은 주방에 치킨 밀키트만 가져와서 레시피대로 튀겨보기"와 비슷합니다.

평생 치킨 밀키트 튀기기만 하다가 죽을거면 그래도 아무 문제가 없는데,
나중에 **나만의 치킨요리**를 만들어서 분점도 내고 확장도 하고 그러고 싶으면,
밀키트부터 쓰고 그런게 아니라 직접 처음부터 치킨을 만들어보는 경험도 중요합니다.

코딩 입문할때도 마찬가지로 나중에 **나만의 이미지와 컨테이너**를 자신있게 만들고 싶으면,
도커없이 내 컴퓨터에 직접 설치하고 셋팅하고 노가다해보고 그런 과정이 매우 중요합니다.
그래야 나중에 Dockerfile도 맘대로 작성해볼 수 있게 됩니다.

Docker만 배우면 아무 쓸모가 없으니까, 실제 웹서버를 만드는 상황에서 Docker를 사용해봅시다.
뒤에 가서 docker compose와 orchestration 툴 사용법까지 좀 알아보도록 합시다.

---

## 3. Docker 설치

- cf. https://docs.docker.com/desktop/install/mac-install/
- https://www.docker.com/ 도커 홈페이지에 접속한 뒤, Get Started를 클릭
- OS에 맞게 다운로드하고, 설치하고, 재부팅한다.

터미널 명령어로 docker 조작하는 것도 가능하지만,
공식 GUI 프로그램을 쓰면 그걸로 훨씬 편하게 docker 기능들을 사용할 수 있습니다.
구글에서 "docker desktop"을 검색해서 설치해옵시다.
설치하면 docker 엔진, docker compose, docker CLI 등 필요한걸 전부 설치해줍니다.

![docker_1-4](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_1-4.png)

- 윈도우는 아마 대부분 AMD64 (일명 x86-64) 이거 설치하면 될 것이고,

  - ARM 어쩌구 CPU를 쓰는 경우에 ARM을 선택합시다.

- 맥북은 CPU가 M1 이상인 분들은 apple silicon 선택합시다.
- 윈도우는 아마 컴퓨터 재시작까지 해야합니다.
- 아무튼 설치하고 docker desktop 실행까지 해봅시다.

(1) Windows

- Git, Git Bash 설치
- Docker Desktop, WSL 설치
- VSCode 설치

(2) Mac

- iTerm2 설치
- Git 설치
- Docker Desktop 설치
- VSCode 설치

설치할 프로그램을 다 받으면, 실습용으로 쓸 폴더를 하나 만들어서 vscode로 연다.

---

### 3.1 자주겪는 에러

(1) 윈도우는 `The network name cannot be found.` 에러가 뜨면

- 시작 - 검색 - powershell 실행 후 `wsl --unregister docker-desktop`
- 입력하고 docker desktop 껐다가 다시 켜보도록 합시다.

(2) 시스템 리소스 부족 에러가 뜨면 아마 램 부족일 수 있어서

- 램을 잡아먹는 프로그램을 끄거나, 윈도우 재부팅 후 `Docker desktop`만 실행해봅시다.
- 아니면 강의에서 소개하는 식으로 터미널에서 명령어들을 실행하는 식으로 docker를 사용합시다.
- 터미널 켜려면 윈도우는 검색에서 "powershell" 검색해서 실행하고
- 맥북은 런치패드에서 "터미널" 검색해서 실행하면 됩니다.

---

### 3.2 이미지

저번 시간에 **밀키트**라고 비유해서 설명한걸 멋있는 말로 `이미지`라고 부릅니다.
`이미지`에는 OS, 실행에 필요한 프로그램, 라이브러리, 소스코드 등이 들어있습니다.
`이미지`는 실행도 쉽습니다.

이미지를 사용하면 환경 맞추기도 쉽고, 내 프로그램을 다른 곳에서 실행하기도 쉬운데,
예를 들어, 웹서버 프로그램을 열심히 만들어놨는데 그걸 서버 컴퓨터에 배포하고 싶으면,

- AWS에서 컴퓨터 한 대를 빌려서
- 컴퓨터에 코드옮기고
- 필요한 프로그램 설치하고
- 웹서버 실행하고 지랄을 해야합니다.

하지만 도커를 쓰면

- 내 작업환경이랑 코드를 그대로 이미지로 만든 다음에,
- 이미지를 그 서버 컴퓨터로 옮겨서 실행만 눌러두면 됩니다.

뭔가 도커 이미지로 싸매놓으면 실행이 느리고 비효율적이지 않을까 싶은데 매우 가벼워서 큰 걱정은 안해도 됩니다.

---

#### 3.2.1 이미지 실행해보기

![docker_1-5](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_1-5.png)

이미지 만들어둔게 없기 때문에, 남들이 만들어놓은 이미지를 한번 다운받아서 실행해봅시다.

Docker desktop 상단에 검색창이 있을텐데,
여기서 `Docker hub`라는 곳에 전체공개로 올라와있는 이미지들을 다운받아볼 수 있습니다.
`Docker hub`은 “**그냥 docker 이미지들 모아놓은 저장소**”입니다.

리눅스 OS 설치된 이미지 다운받고 싶으면 ubuntu, alpine 이런거 검색해보시면 되고,
아니면 Nodejs나 파이썬 설치되어있는거 다운받고 싶으면 역시 검색해보면 됩니다.
저는 테스트삼아서 `hello world`라는 이름의 이미지 한번 다운받아보겠습니다.
그냥 hello 어쩌구 글자 몇개 출력해주는 이미지입니다. 다운 수 가장 많은거 다운받아오면 됩니다.

> `Tag`라고 써있는 건 버전이랑 비슷한 말입니다. `Pull` 누르면 다운가능합니다.

```bash
docker pull 이미지이름:태그명
```

실은 터미널에서도 `docker 명령어` 입력하면 남자답게 이미지 다운로드가 가능합니다.
Docker desktop 하단에 터미널 오픈하는 버튼이 어딘가에 있을텐데,
거기다가 위의 명령어 입력하면 되겠습니다. 그럼 docker hub에서 찾아서 가져와줍니다.

![docker_1-6](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_1-6.png)

▲ 다운받은 이미지는 images 메뉴에 추가됩니다.
아니면 터미널에 상남자처럼 `docker image ls` 입력해도 이미지 목록을 볼 수 있습니다.

---

### 3.3 컨테이너

![docker_1-7](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_1-7.png)

▲ 이미지 실행하려면 이미지 오른쪽에 재생버튼 누르면 됩니다.

```bash
docker run 이미지이름:태그명
```

아니면 터미널에서 실행해볼거면 이런거 입력하면 실행됩니다.

- `이미지`를 실행하면, `컨테이너`라는게 뜨고 `이미지`가 그 안에서 실행됩니다.
- `컨테이너`는 “**이미지 하나를 실행하고 있는 가상 컴퓨터**”라고 보면 되겠습니다.
  - 비유하면, `이미지(image)`는 밀키트, `컨테이너(container)`는 밀키트로 만든 요리라고 할 수 있습니다.

![docker_1-8](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_1-8.png)

근데 다운받은 hello-world 이미지는 "터미널에 hello 어쩌구 글자정도 출력해주세요~"
그 정도만 들어있기 때문에 글자 몇개만 출력해주고 컨테이너가 정지된걸 볼 수 있습니다.
시시해서 죽고싶다면 좀 더 다이나믹한 이미지도 실행해봅시다.

![docker_1-9](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_1-9.png)

▲ `dockercloud/hello-world` 이미지를 다운받아서 실행해봅시다.
얘는 다이나믹하게 웹서버를 하나 실행해주는 이미지입니다.

![docker_1-10](https://raw.githubusercontent.com/berenickt/image-server/refs/heads/main/docker/docker_1-10.png)

▲ 그 다음에 실행하는데 포트번호를 8080으로 기재하고 실행해봅시다.
"내 컴퓨터의 8080포트로 들어가면 그 컨테이너의 80번 포트로 안내해주세요~" 라는 뜻인데,
자세한건 나중에 알아봅시다.

아무튼 실행했으면 당장 웹브라우저 켜서 `localhost:8080` 주소로 들어가봅시다.
그러면 이상한 웹페이지가 하나 뜨는데 웹서버가 실행중이라 그렇습니다.
누가 `localhost:8080`으로 방문하면 웹페이지를 하나 보내주는 웹서버입니다.
아무튼 웹서버같은 프로그램도 이미지로 만들어서 돌려볼 수 있습니다.

---

### 3.4 결론 : Docker 컨테이너와 이미지

(1) 유저랜드

- OS는 메모리 사용을 기준으로 `커널 공간`과 `유저 공간`으로 나눌 수 있음
- **유저 공간에서 실행되는 실행 파일과 라이브러리**를 `유저랜드(userland)`라고 부름
  - 보통 리눅스 배포판에서 유저랜드는 부팅에 필요한 실행 파일과 라이브러리, 고유의 패키징 시스템을 포함됨
  - 보통 리눅스 배포판 이름으로 되어 있음 (e.g. Ubuntu, CentOS, Debian 등)
  - But. 운영체제의 사용자 공간을 가리키는 용어이기 때문에, 리눅스 배포판의 이름과 직접적으로 관련없음

(2) Docker 이미지

- `베이스 이미지` : **유저랜드만 설치된 파일**을 의미
- `Docker 이미지` : 베이스 이미지에 필요한 프로그램과 라이브러리, 소스를 설치한 뒤 파일 하나로 만든 것
  - Docker 이미지는 16진수로 된 ID로 구분하고, 각각의 이미지는 독립적
  - 이미지를 통째로 생성하지 않고, 바뀐 부분만 생성한 뒤, 부모 이미지를 계속 참조하는 방식으로 동작
  - Docker에서는 이를 `레이어`라고 부름

(3) Docker 컨테이너

- `Docker 컨테이너` : **이미지를 실행한 상태**
  - 이미지로 여러 개의 컨테이너를 만들 수 있음
- 운영체제로 비유하면, `이미지`는 실행 파일이고, `컨테이너`는 프로세스
- `Docker === 특정 실행 파일 또는 스크립트를 위한 실행 환경`

> 💡결론
>
> 1. OS, 개발환경, 소스코드 등을 담아서 `이미지`를 만들 수 있고
> 2. 이미지를 실행중인 가상컴퓨터가 `컨테이너`이구나
