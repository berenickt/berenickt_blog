---
title: '08-S3'
date: 2024/01/10
---

## 1. 객체 스토리지

- `객체 스토리지(Object Storage)`는 이름 그대로 데이터를 객체로 관리한다
- 하나의 객체는 이렇게 독립적으로 존재한다.

  - 객체는 무수히 많아질 수 있다.

- 하나의 객체는 `아이디`와 `데이터`, 그리고 `메타 데이터`를 포함한다.

객체 스토리지의 특징

- 방대한 확장성과 메타 데이터를 갖고 있다
- 규모와 유연성이 필요한 애플리케이션을 구축하는 데 적합
- 기존 데이터 스토어를 가져오는 데 사용 가능한데, **분석이나 백업 또는 아카이브 목적**으로 사용 가능
- 데이터를 **일부분만 수정하는 것이 불가능**함
  - 그래서 데이터 전체를 덮어써야 한다.

---

## 2. 파일 스토리지

- `파일 스토리지 (File Storage)` : 데이터를 파일로 관리한다.
- 파일 스토리지에는 **파일 시스템**이라는 것이 존재한다.
  - 그리고 그 안에 다양한 경로에 파일들이 존재한다.
  - 파일 스토리지의 특징 중 하는 파일들이 이렇게 계층으로 나눠져서 구성된다는 점이다.
  - e.g. Windows나 Mac OS에서 폴더 내에 파일이 존재하는 것
- 폴더 내에 또 다른 폴더가 존재할 수 있으며, 그 폴더 내에 여러 개의 파일들이 존재할 수 있다.

파일 스토리지의 특징

- **파일 시스템을 통해 데이터를 파일 단위로 저장**한다.
- **파일의 일부분만 수정이 가능**하다.
- 그래서 애플리케이션이 공유 파일에 액세스하거나 파일 시스템이 있어야 하는 경우에 적합
- e.g. NAS, 대규모 콘텐츠 레포지토리, 미디어 스토어, 그리고 사용자 홈 디렉터리 등

---

## 3. 블록 스토리지

- `블록 스토리지 (Block Storage)` : 데이터를 **블록**으로 관리한다.
  - cf. `블록` : 저장공간을 나누는 단위
- 블록 스토리지는 데이터를 작은 블록 단위로 저장하며, 각 블록은 고유한 주소 또는 식별자를 가진다.
- 블록 스토리지는 개별 가상 서버로 프로비저닝되기 때문에 **엄청나게 낮은 지연 시간을 제공**한다.
  - 그래서 **고성능 워크로드**에 사용하기에 적합하다.
- 주로 **데이터베이스 시스템, 가상 머신, 클라우드 스토리지** 등에서 사용
- 파일 시스템이나 메타데이터 없이 **순수한 데이터 블록만을 저장**한다.
  - cf. Elastic Block Store가 바로 이 블록 스토리지다.

---

## 4. 파일 스토리지 vs 객체 스토리지

|               파일 스토리지               |            객체 스토리지             |
| :---------------------------------------: | :----------------------------------: |
|         데이터를 파일 단위로 관리         |      데이터를 객체 단위로 관리       |
|        파일내용 일부분만 수정 가능        |   객체 데이터 일부분만 수정 불가능   |
| 운영체제에서 직접 접근 가능 (볼륨 마운트) |     운영체제에서 직접 접근 불가      |
|         큰 확장에 대처하기 어려움         |     큰 확장에 유연하게 대처 가능     |
|            사본 저장하지 않음             | 다수의 사본을 분산시켜 저장 (안정성) |

- `파일 스토리지` : 파일을 찾기 위해서는 **파일의 경로**를 알아야 한다.
  - e.g. `C:\MyFolder\hello.txt`
- `객체 스토리지` : 각 객체가 **고유한 아이디**를 갖고 있기 때문에, **해시 함수**를 통해 객체를 곧바로 찾을 수 있다.
  - e.g. `GET /hello.txt`
  - 객체 스토리지는 depth가 1인 tree라고 이해하면 된다.

---

## 5. S3

- Simple Storage Service의 약자
- 처음에 아마존에서 수많은 상품의 이미지를 저장하기 위해서 만들어졌다고 함
- AWS 클라우드 스토리지 유형
  - `S3 (Simple Storage Service)` : 객체 스토리지
  - `EFS (Elastic File System)` : 파일 스토리지
  - `EBS (Elastic Block Store)` : 블록 스토리지

필요에 따라 적합한 유형의 스토리지를 선택해서 사용하면 된다.

---

### 5.1 S3 특징

- 객체 기반의 무제한 파일 저장 스토리지
- URL을 통해 손쉽게 파일 공유 가능
- 99%의 내구성
- 사용한 만큼만 지불(GB당 과금)
- 정적 웹사이트 호스팅 가능

---

### 5.2 타 AWS 서비스들과 통합

S3는 다른 AWS 서비스들과 쉽게 통합해서 사용할 수 있다.

- DynamoDB, Lambda, Redshift, EMR, Data Pipeline, Kinesis 등의 서비스들과의 통합을 지원한다.
- S3는 주로 수정이 잘 일어나지 않는 **최종 파일**을 저장하는 용도로 사용한다.
  - 객체 스토리지의 특성상 파일의 일부분만 수정이 불가능하기 때문에,
- S3는 빠른 속도로 Read/Write를 해야 하는 경우 부적합하다.
- 그래서 적합한 용도로는 이미지, 동영상, 음악, 문서 등의 미디어 파일을 보관하거나 로그파일을 보관하기에 적합하다.
- 또한 다른 AWS 서비스의 데이터를 백업하는 등의 데이터 백업에도 적합하며,
  - 정적 웹 호스팅을 위해서도 사용하기 좋다.

---

### 5.3 S3 관련 용어

- `Bucket` : Object를 담는 최상위 단위미 (이름, 개수 제한있음)
  - cf. 한국말로 ‘양동’이라는 뜻
- `Object` : Bucket에 담는 데이터의 단위 (파일)
  - 우리가 흔히 파일이라고 부르는 것이 S3에서는 객체이다.
  - Bucket 안에 존재하는 것이 바로 객체
- `Metadata` : Object에 대한 여러가지 정보를 담고있는 데이터
- `Policy` : Bucket과 Object에 대한 접근을 통제하는 권한 정보

---

### 5.4 S3 사용방법

1. 가장 먼저 Bucket 생성한다.
   - (그래야 데이터를 저장할 수 있기 때문)
2. HTTP로 Bucket에 파일 업로드한다.
   - (업로드된 파일은 Object로 Bucket 내에 저장됨)
3. Object에 권한을 설정해야 한다.
   - (이 권한에 따라 외부 서비스 및 사용자의 Object 접근 가능 여부가 달라짐)
4. HTTP로 Bucket에서 파일 다운로드받아서 사용한다

---

### 5.5 S3의 스토리지 클래스

S3 스토리지 클래스 종류

- S3 Standard
- S3 Intelligent-Tiering
- S3 Standard-IA
- S3 One Zone-IA
- S3 Glacier Flexible Retrieval
- S3 Glacier Deep Archive
- S3 Glacier Instant Retrieval
- S3 on Outposts

스토리지 클래스는 스토리지를 저장하는 형태를 의미한다. 어떤 스토리지 클래스를 사용하는지에 따라서 요금이 크게 달라진다.

> 💡 주요 스토리지 클래스
>
> 자주 액세스하는 객체를 위한 스토리지 클래스
>
> - `Standard` : 기본 스토리지 클래스
>   - 최소 3개의 가용 영역(AZ)에 데이터를 저장
>   - 자주 액세스하는 데이터를 위해 높은 내구성, 가용성 및 성능을 갖춘 객체 스토리지를 제공
>
> 자주 액세스하지 않는 객체를 위한 스토리지 클래스
>
> - `Standard-IA (Infrequent Access)`
>   - 여러 개의 가용 영역에 중복 저장(고가용성, 복원력 있음)
>   - 자주 액세스하지 않지만 필요할 때 빠르게 액세스해야 하는 데이터에 적합
>   - Standard 클래스와 마찬가지로,
>     - 최소 3개의 가용 영역에 객체를 중복으로 저장함으로써 고가용성 및 복원력을 갖고 있다
> - `One Zone-IA (Infrequent Access)`
>   - 하나의 가용 영역에만 데이터를 저장 (Standard-IA 비해 저렴, 복원력 없음)
> - IA는 **Infrequent Access**의 약자로, 자주 접근하지 않는다는 의미

---

### 5.6 S3 Glacier

- S3에는 Glacier라는 스토리지 클래스가 있다.
  - Glacier라는 단어는 우리 말로 **빙하**라는 뜻
- 즉, `Glacier`는 **자주 접근하지 않는 데이터를 빙하에 보관하는 용도의 스토리지 클래스**다.
- **데이터 아카이빙을 위한 백업 스토리지**이며 무제한 확장성을 제공
- Glacier는 주로 백업 및 아카이빙 용도의 **Cold 데이터**를 저장하는 용도로 사용하며,
- 매우 낮은 비용으로 데이터를 저장할 수 있다.

---

### 5.7 S3 객체 라이프사이클 관리

![s3_object_lifecycle](https://raw.githubusercontent.com/berenickt/image-server/main/img/s3_object_lifecycle.jpeg)

- 먼저 처음에는 객체를 **Standard** 클래스로 저장한다.
  - 최근에 업로드 된 데이터는 자주 접근할 확률이 높기 때문
- 30일 경과한 이후에 데이터에 자주 접근하지 않게 되면, **Standard-IA**로 스토리지 클래스를 변경한다.
  - 그렇게 되면 GB당 요금이 Standard 클래스에 비해 **약 45% 저렴**해진다.
- 또 30일 지나서 데이터를 아카이빙 하기 위한 목적으로 **Glacier** 클래스로 변경한다.
  - 그렇게 되면 GB당 요금이 Standard-IA에 비해 **약 67% 저렴**해지며,
  - Standard 클래스에 비해서는 **약 82%나 저렴**해진다.
- AWS에서 제작한 S3 소개 영상 링크 : https://www.youtube.com/watch?v=77lMCiiMilo&feature=youtu.be

---

## 6. (실습) S3 버킷 생성

[S3]로 이동해보면, 오른쪽 상단에 리전을 선택하는 것보면 특이한 점을 발견할 수 있다.

- 기존에는 리전명으로 되어 있었던 부분이 S3 페이지에서는 글로벌이라고 나온다.
- 리전 목록을 펼쳐보면, 모든 리전이 비활성화 되어 있는 것도 볼 수 있다.
- 이렇게 나오는 이유는 S3에서는 리전을 선택할 필요가 없기 때문이다.
- 대신 버킷에 대한 리전만 지정하면 됩니다.

---

### 6.1 S3 버킷 생성

여기 오른쪽에 있는 [버킷 만들기] 버튼을 클릭한다.

- `버킷 이름` : 전 세계에서 유일한 이름으로 입력 (cf. sw-bucket-240114-1)
  - 버킷 이름을 입력할 때 주의할 점은
  - 버킷 이름은 DNS 형식으로 전 세계에서 유일해야 한다.
  - (다른 S3 사용자와 중복이 불가능)
  - 삭제하면 곧바로 같은 이름으로 버킷을 만들기 어려울 수 있음
- `객체 소유권` : ACL 비활성화됨 옵션 그대로 사용
- `이 버킷의 퍼블릭 액세스 차단 설정`
  - 퍼블릭 액세스가 차단되어 있으면,
  - 외부에서 버킷에 있는 객체에 접근할 수 없게 된다.
  - 우선 이 옵션을 선택한 상태로 버킷을 생성할 것이다.
- 화면을 제일 하단으로 내려서 [버킷 만들기] 버튼을 클릭한다.
- 여기서 해당 버킷을 눌러서 들어가면, 각종 탭과 객체 목록이 나온다.
  - 현재는 아무런 객체도 들어있지 않기 때문에 비어 있다.

---

## 7. (실습) S3 버킷에 파일 업로드 및 다운로드

먼저 간단한 내용의 hello.txt 파일을 작성합니다.

```tex hello.txt
Hello, S3!
```

이후 S3 버킷 페이지에서 [업로드] 버튼을 클릭한다.

- 그러면 파일 업로드 화면이 나오는데, 여기서 [파일 추가] 버튼을 클릭한다.
- 그리고 아까 작성한 파일을 선택해서 [열기] 버튼을 클릭한다.
  - 업로드할 파일 및 폴더 목록에 해당 파일이 추가된다.
  - 화면 하단에 있는 [업로드] 버튼을 클릭해서 파일을 업로드한다.
  - 이제 [닫기] 버튼을 클릭한다.

그럼 버킷 내부에 이렇게 객체가 하나 생긴 것을 볼 수 있다.

- 여기서 유형, 마지막 수정 일자, 크기, 스토리지, 클래스 등의 정보를 확인할 수 있다.
- 지금은 Standard 클래스로 되어 있는 것을 볼 수 있다.

이 객체를 한번 클릭한다.

- 그러면 이렇게 객체에 대한 상세 정보가 나오는 것을 볼 수 있습니다.
- 여기서 객체 URL을 보면 해당 객체의 고유 주소가 있는데,
  - 주소 내에 버킷의 이름과 객체의 ID가 포함되어 있다.
  - 이처럼 S3의 버킷 이름은 URL에 포함되기 때문에 고유한 값이어야 한다.
- 이제 오른쪽 위에 있는 [다운로드] 버튼을 클릭.
  - 그러면 파일이 다운로드된다.
  - 다운로드된 파일의 내용을 확인해,
  - 아까 업로드한 파일과 동일한 내용인지 확인한다.

---

## 8. (실습) S3 버킷에 폴더 생성

> 💡 S3에 폴더를 만들기 전에 알아야 할 것은
>
> - S3에서 폴더의 개념은 기존 파일 스토리지와 다르다
> - S3에서 폴더는 파일 이름의 Prefix 개념이다.
>   - 객체 스토리지에서 모든 파일은 depth가 1인 tree로 저장되기 때문.

[S3] → 해당 버킷 상세페이지에서 [폴더 만들기] 버튼을 클릭한다.

- `폴더 이름` : MyFolder
- 이후 화면을 아래로 내려서 [폴더 만들기] 버튼을 클릭한다.
- 여기서 폴더를 클릭해서 들어간다.
  - 폴더에 들어가면 아무런 객체가 없기 때문에 비어 있다.

버킷 최상위 경로에서 이전에 업로드해둔 hello.txt 파일을 선택한다.

- 선택한 이후에 [작업] → [복사] 메뉴를 클릭한다.
- 그럼 객체를 복사할 수 있는 화면이 나온다.
- `대상 옵션`
  - cf. 대상 옵션 : 객체를 어디로 복사할 것인지 설정하는 옵션.
  - [S3 찾아보기] 버튼을 클릭합니다.
  - 그러면 버킷의 내용이 나오는데, 아까 만든 폴더를 클릭.
  - **폴더에 들어간 이후**에 [대상 선택] 버튼을 클릭한다.
  - 그러면 복사할 대상 경로가 설정된다.
- 이후 화면을 제일 하단으로 스크롤하여 [복사] 버튼을 클릭한다.
  - 그럼 이렇게 객체 복사가 완료된다.
  - 이제 [닫기] 버튼을 클릭한다.

객체가 제대로 복사됐는지 확인하기 위해서 버킷에서 폴더를 눌러서 들어갑니다.

- 이 파일을 눌러서 상세 정보를 보고,
- 기존 루트경로에 hello.txt 파일의 객체 URL 정보를 확인해보면,
- 폴더 안에 있는 객체는 URL의 폴더의 이름이 함께 포함되어 있다.
- 앞에서 말한 것처럼 S3에서 폴더는 파일 이름의 Prefix 개념이기 때문에,
  - `MyFolder/hello.txt`가 파일의 이름이라고 보면 된다.

---

## 9. (실습) Cyberduck으로 S3 다루기

이번에는 Cyberduck이라는 외부 프로그램으로 S3를 다뤄본다.

- 먼저 외부 프로그램을 통해 S3에 접속하기 위해서는 별도의 권한이 필요하다.
- 그리고 AWS에서 그러한 권한을 관리해주는 서비스가 IAM이라는 서비스이다.

---

### 9.1 Access Key 생성 (IAM)

[IAM] → 왼쪽의 [사용자] 메뉴를 클릭

- 그럼 사용자를 관리할 수 있는 화면이 나온다.
- 오른쪽 상단에 있는 [사용자 생성] 버튼을 클릭한다.
  - `사용자 이름` : s3-admin
  - 사용자 이름을 입력하고 [다음] 버튼을 클릭.
- 다음 단계는 실제로 사용자에게 권한을 부여하는 단계이다.
  - 먼저 [직접 정책 연결] 옵션을 클릭.
  - 이후 아래에 나오는 검색창에 `S3FullAccess`라고 검색한다.
  - 그러면 AmazonS3FullAccess라는 정책이 하나 필터링되어 나온다.
  - 해당 정책을 선택한 이후에는 [다음] 버튼을 클릭한다.
- 마지막 3단계에서는 지금까지 설정한 내용을 한 번 더 확인한다.
  - 설정한 내용의 이상이 없다면 [사용자 생성] 버튼을 클릭.
  - 그러면 이렇게 새로운 사용자가 생성된다.

사용자를 눌러서 상세 페이지로 들어간다.

- [보안 자격 증명] 탭을 클릭.
  - cf. 보안 자격 증명 탭에서는 이 사용자에 대한 다양한 자격 증명을 관리함.
- 화면을 아래로 내려보면, [액세스 키] 섹션이 나온다.
- 여기서 [액세스 키 만들기] 버튼을 클릭한다.
- 그러면 액세스 키를 만들기 위한 페이지가 나온다.
  - 여기서 제일 상단에 있는 커맨드 라인 인터페이스(CLI)를 선택한다.
  - cf. CLI 옵션 : 키와 시크릿 키를 통해 접속할 때 사용하는 옵션
- 이후 화면을 아래로 내려서,
  - 제일 하단에 있는 위의 권장 사항을 이해했으며 액세스 키 생성을 체크 표시
  - 체크한 이후에 [다음] 버튼을 클릭한다
- 이후 필요하다면 태그를 입력하고, [액세스 키 만들기] 버튼을 클릭한다.

주의할 점은 위에 초록색 부분에도 나와 있지만, 키를 생성한 시점에만 다운로드 받을 수 있다.

- 이전에 EC2 인스턴스의 키 페어를 만들 때와 마찬가지로,
- 보안을 위해 키를 생성한 시점에만 다운로드 받을 수 있으며,
- 이후에는 키 파일을 잃어버리지 않도록 스스로 잘 관리해야 한다.
- [.csv 파일 다운로드] 버튼을 클릭하여 CSV 파일을 다운로드한다.

---

### 9.2 Cyberduck 설치

- https://cyberduck.io/
- Cyberduck은 FTP, SFTP 등의 다양한 형태로 원격 서버에 접속해서 사용할 수 있는 스토리지 브라우저다.
- [다운로드] 버튼을 클릭하여 프로그램을 다운로드 받고 설치 및 실행한다.

Cyberduck을 실행한 뒤에, 오른쪽 상단에 있는 [새 연결] 버튼을 클릭한다.

- 그럼 새로운 연결을 추가하기 위한 다이얼로그가 나온다.
- 그러면 FTP뿐만 아니라 다양한 접속 방식을 제공하는 것을 볼 수 있다.
- 여기서 [Amazon S3]를 선택한다.
- S3를 선택하면, 입력 옵션이 바뀌게 되고, 이제 액세스 키를 입력해야 한다.
- 앞에서 다운로드 받은 CSV 파일을 열면,
  - 액세스 키 아이디와 시크릿 액세스 키가 나오는데,
  - 이 값을 각각 접근키ID, Secret Access Key에 복붙해서 넣으면 된다.
- 모든 키를 입력했다면, [연결] 버튼을 클릭한다.

그럼 이렇게 S3에 정상적으로 접속되는 것을 볼 수 있다.

- 확대해 보면, 버킷과 버킷 내에 있는 객체들까지 잘 나온다.

---

## 10. (실습) S3 정적 웹 호스팅

먼저 해당 [버킷] 상세 페이지에서 [속성] 탭을 클릭한다.

- 여기서 화면을 아래로 스크롤해보면,
- 하단에 정적 웹사이트 호스팅이라는 옵션이 나온다.
  - 지금은 비활성화되어 있는데,
  - 활성화시키기 위해서 [편집] 버튼을 클릭.
- 이후 활성화를 선택하여 정적 웹사이트 호스팅을 활성화시켜준다.
  - `인덱스 문서`에는 제일 처음 나올 문서의 이름을 입력해준다.
  - 기본 값은 index.html인데 이 값을 그대로 입력한다.
  - index.html을 입력하면 웹사이트에 접속했을 때, 이 파일이 기본으로 나온다.
  - 화면을 밑으로 내려서 [변경 사항 저장] 버튼을 클릭한다.
- 다시 맨 밑으로 화면을 스크롤해보면, 주소가 1개 생성되어 있다.
  - 이제 이 주소를 통해 웹사이트에 접속할 수 있다.
  - 하지만 지금은 index.html 파일이 없기 때문에,
  - 먼저 index.html 파일을 만들어서 업로드해야 한다.
- 간단한 형태의 HTML 파일을 작성하고 index.html이라는 이름으로 저장한다.

```html index.html
<!doctype html>
<html>
  <head>
    <title>First met AWS</title>
  </head>
  <body>
    <h1>Hello, S3!</h1>
  </body>
</html>
```

다음으로는 작성한 파일을 버킷의 최상위 경로에 업로드해야 한다.

- 다시 [객체] 탭으로 돌아와서 최상위 경로에 [업로드] 버튼을 클릭
- 작성한 index.html 파일을 선택해 최상위 경로로 업로드한다.
- [속성] 탭을 클릭한다.
  - 화면 제일 하단의 정적 웹사이트 호스팅 옵션으로 이동한다.
  - 여기서 버킷 웹사이트 엔드포인트 주소를 복사한다.
  - 주소를 복사한 후, 브라우저에서 접속해보면,
  - 접속이 안 되고 에러가 발생한다.
  - 에러 메시지를 보면 access denied라고 되어 있습니다.
  - 이 에러는 버킷에 있는 객체에 접근 권한이 없기 때문에,
  - 접근이 거부되어 발생한 것이다.
  - 그래서 버킷에 있는 객체들에 대해서 접근 권한을 변경해야 한다.
- 권한을 변경하기 위해서 버킷의 [권한] 탭을 클릭.
  - [Public Access 차단] 옵션의 [편집] 버튼을 클릭한다.
  - Public Access 차단 체크를 해제한다.
  - 체크를 해제한 이후에 [변경사항 저장] 버튼을 클릭한다.
  - 퍼블릭 액세스를 허용하는 것이 맞는지 한 번 더 확인하기 위한 다이얼로그가 뜬다.
  - “확인”을 입력하고, [확인] 버튼을 클릭하면 된다.
- [권한] 화면을 아래로 내리면, 버킷 정책을 편집할 수 있는 옵션이 나온다.
  - cf. 버킷 정책은 버킷과 객체들에 대한 접근 권한을 설정하는 것
  - cf. 각 정책은 JSON 형태로 작성한다.
  - 여기서 [편집] 버튼을 클릭한다.
  - 편집 모드에서 여기에 있는 [Bucket ARN]을 복사한다.
  - cf. ARN은 아마존 리소스 네임의 약자로 AWS 리소스들의 고유한 이름을 의미
  - 이후에 오른쪽 상단에 있는 정책 생성기 버튼을 클릭
    - cf. 직접 정책을 작성하는 것이 어렵기 때문에 정책 생성기에 도움을 받는 것

---

### 10.1 AWS Policy Generator

그러면 새 창에서 정책 생성기가 나온다.

- `Select Type of Policy` : S3 Bucket Policy 선택
- `Principal` : `*` 입력
  - cf. 리소스에 대한 액세스가 허용되거나 거부되는 사용자, 계정, 서비스 또는 기타 엔티티를 지정하는 옵션.
  - 모든 사용자가 접근할 수 있도록 하기 위해, 와일드카드라고 부르는 별표를 입력
- `Actions` : GetObject 선택
  - Get Object는 이름 그대로 객체를 가져오는 동작이다.
- `Amazon Resource Name (ARN)`
  - ARN 필드에 앞에서 복사해둔 버킷에 ARN을 붙여넣고 뒤에 `/*`를 입력
  - cf. `/*`를 입력하는 이유는 버킷 내에 있는 모든 객체에 접근할 수 있도록 하기 위함
- 모든 설정을 마쳤으면 [Add Statement] 버튼을 클릭한다.
- 그러면 밑에 테이블이 하나 나온다.
- 이 상태에서 [Generate Policy] 버튼을 클릭하여 정책을 생성한다.
- 그럼 JSON 형태의 정책이 다이얼로그에 나타난다.
  - 여기서 이 정책 내용을 모두 복사한다.
- 이후 S3 버킷 정책 편집 화면으로 다시 돌아와서 복사한 정책 내용을 붙여 넣어준다.

정책을 붙여넣은 이후에 화면 하단에 있는 [변경사항 저장] 버튼을 클릭한다.

- 이제 우리가 만든 정책이 버킷에 적용되었다.
- 버킷의 [속성] 탭을 클릭한다.
- 정적 웹사이트 호스팅 옵션에 있는 웹사이트 엔드포인트를 복사한다.
- 이후에 브라우저에서 해당 복사한 주소로 접속해보면,
  - 작성한 index.html 파일이 정상적으로 나오는 것을 볼 수 있다.

이처럼 S3를 사용하면 정적 웹사이트를 편리하게 호스팅할 수 있다.

---

## 11. (실습) S3 버킷 삭제

버킷을 삭제하려면 먼저 버킷이 비어 있어야 한다.

- [S3] → [버킷]에서 버킷을 선택한 뒤에, [비어있음] 버튼을 클릭한다.
  - cf. 버튼 번역이 좀 이상한데, 버킷 비우기 버튼이라고 보면 된다.
- 클릭하면 버킷 비우기 화면이 나온다.
  - 버킷을 비우는 것은 중요한 작업이기 때문에, 한 번 더 확인을 거치는 것
- `영구 삭제`라고 입력하고, [비어 있음] 버튼을 클릭한다.
- [종료] 버튼을 클릭한다.

이번에는 버킷을 삭제하기 위해, 다시 버킷을 선택한 뒤, [삭제] 버튼을 클릭한다.

- 그러면 버킷 삭제 화면이 나오고, 여기에 버킷의 이름을 그대로 입력한다.
- [버킷 삭제] 버튼을 클릭하여 버킷을 삭제한다.
- 이렇게 버킷 삭제가 완료된다.
