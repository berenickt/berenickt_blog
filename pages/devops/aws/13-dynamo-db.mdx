---
title: '13-DynamoDB'
date: 2024/01/10
---

## 1. NoSQL

- NoSQL은 **Non SQL** 또는 **Non relational**을 나타내는 말
  - 즉, 관계가 없는 형태의 데이터베이스를 의미
- 관계형 데이터베이스의 데이터 일관성 제약을 일부 완화함으로써, **수평적으로 확장 가능한 성능**을 갖고 있다.
  - 또한 개발하기에 용이하며 **짧은 지연 시간 및 복원력**을 갖고 있다.
  - 이러한 NoSQL은 **스키마 없는 데이터 모델에 최적화** 되어 있다.
- **간단한 데이터 구조**를 갖고 있으며, 열, 문서, 그래프, 인메모리 키-값 스토어 등의 다양한 데이터 모델을 사용할 수 있다.
  - 그래서 빅데이터, 모바일 및 웹 애플리케이션에 사용하기에 매우 적합하다

---

### 1.1 RDBMS와 NoSQL 데이터베이스 차이점

- `RDBMS`에서는 데이터를 유연하게 쿼리할 수 있지만,
  - 대신 쿼리 비용이 상대적으로 높으며 트래픽이 많은 상황에서는 확장성이 떨어진다.
- `NoSQL 데이터베이스`에서는 몇 가지 제한된 방법으로 데이터를 효율적으로 쿼리할 수 있으며,
  - 그 외에는 쿼리 비용이 높고 속도가 느리다는 특징을 갖고 있다

|             |                           관계형 데이터베이스                           |                      NoSQL 데이터베이스                      |
| :---------: | :---------------------------------------------------------------------: | :----------------------------------------------------------: |
| 데이터 모델 |             스키마 강제적(행과 열로 구성된 테이블로 정규화)             |                  스키마 강제 적용하지 않음                   |
|  ACID 속성  |            ACID 속성을 지원(원자성, 일관성, 격리성, 내구성)             |                    일부 ACID 속성을 지원                     |
|    성능     | 디스크 하위 시스템에 따라 다름(쿼리, 인덱스 및 테이블 구조 최적화 필요) | 기본 하드웨어 클러스터 크기, 네트워크 지연 시간 등에 따라 듦 |
|  확장 기능  |                          더 빠른 하드웨어 사용                          |                하드웨어의 분산 클러스터 사용                 |
|     API     |                        SQL을 준수하는 쿼리 사용                         |   객체 기반 API(인 메모리 데이터 구조를 쉽게 저장 및 검색)   |
|    도구     |                          다양한 도구 세트 제공                          |            클러스터 관리 및 조정을 위한 도구 제공            |

---

### 1.2 NoSQL 데이터베이스 종류

NoSQL 데이터베이스에는 4가지 주로 사용되는 유형이 있다.

- `열 기반 데이터베이스` : 데이터의 행이 아닌 데이터의 열을 읽고 쓰는 데 최적화되어 있다.
- `문서 데이터베이스` : JSON 또는 XML 형식의 문서와 같은 반정형 데이터를 저장하도록 설계 되어 있다
  - 문서별로 다른 스키마를 적용할 수 있으며, 유연하게 애플리케이션 데이터를 구성 및 저장할 수 있다.
- `그래프 데이터베이스` : 간선이라고 부르는 방향 링크와 정점을 저장하는 형태의 데이터베이스
- `인 메모리 키-값 스토어` : 읽기 중심의 애플리케이션 워크로드 또는 컴퓨팅 집약적 워크로드에 최적화되어 있다.
  - 인 메모리 캐싱은 핵심 데이터 조각을 메모리에 저장해 액세스 지연 시간을 줄여주므로 애플리케이션 성능이 향상된다.

이 데이터베이스들은 데이터가 저장되고, 액세스되고, 구조화되는 방식이 다르며, 서로 다른 사용 사례 및 애플리케이션에 최적화 되어 있습니다.

---

## 2. DynamoDB

- `DynamoDB` : AWS에서 제공하는 **매우 빠르고 확장 가능한 완전관리형 클라우드 NoSQL 데이터베이스**
- 규모와 관계없이 10ms 미만의 지연 시간을 보장하며, 유연한 데이터 모델을 사용할 수 있고 용량에 제한이 없다.
- 안정적인 성능 및 처리 용량 자동 조정 기능을 통해 안정적이고 확장 가능한 서비스를 제공할 수 있으며,
  - 용량과 읽기/쓰기 유닛에 대하여 과금됨
- `DAX(DynamoDB Accelerator)` : 가용성이 뛰어난 완전관리형 인 메모리 캐시
  - DAX를 사용하면 초당 수백만 개의 요청에도 DynamoDB 응답 시간을 밀리초에서 마이크로초로 단축 가능

---

### 2.1 DynamoDB Read 방식

- `Eventually Consistent Read` (기본으로 사용되는 방식)
  - 최근 완료된 쓰기 작업의 결과를 반영하지 않을 수 있기 때문에, **부실 데이터가 일부 포함될 수 있는** 방식
  - 하지만 잠시 후에 읽기 요청을 반복하면 응답이 최신 데이터를 반환하게 된다.
- `Strongly Consistent Read`
  - 성공한 모든 이전 쓰기 작업의 업데이트를 반영하여 **가장 최신 데이터**로 응답을 반환하는 방식
  - 네트워크 지연 또는 중단이 발생한 경우에 사용이 어려울 수 있다.

---

### 2.2 DynamoDB 과금방식

과금 방식은 크게 **스토리지 요금**과 **읽기/쓰기 용량 유닛**에 대한 요금으로 나눠진다.

- `데이터 스토리지` :

  - 테이블에서 사용한 디스크 공간(GB)당 시간당 요금을 부과
  - GB당 월 0.27 USD

- `읽기 용량 유닛`
  - `1 읽기 용량 유닛`은 초당 최대 2건의 읽기 작업을 제공 (월별 5백 2십만 건)
  - 읽기 요청 유닛 100만 건당 0.271 USD
- `쓰기 용량 유닛 요금`
  - `1 쓰기 용량 유닛`은 초당 최대 1건의 쓰기 작업을 제공 (월별 2백 6십만 건)
  - 쓰기 요청 유닛 100만 건당 1.3556 USD

cf. 이 요금은 현재 시점의 서울 리전 기준 요금이며, 프리티어에서는 매월 25GB 스토리지 및 읽기/쓰기 용량 유닛이 각 25개씩 제공됨

---

### 2.3 DynamoDB 기본 구성

- `Table` : Item의 집합
- `Item` : Attribute의 집합
- `Attribute` : Key-Value방식의 데이터를 의미하며, Key는 문자열

---

## 3. DynamoDB 데이터 타입

### 3.1 스칼라 데이터 형식

하나의 값만을 표현할 수 있는 **스칼라 데이터 형식**은 다음과 같다.

- `Number (N)` : 양수, 음수 또는 0. 최대 38자리까지 지원.
- `String (S)` : UTF-8 이진 인코딩 을 사용하는 유니코드.
- `Binary (B)` : 압축 텍스트, 암호화 데이터, 또는 이미지 같은 모든 이진수 데이터 저장 가능.
- `Boolean (S, "0"또는 1")` : true 또는 false를 저장할 수 있음.
- `Null (NULL)` : 알려지지 않았거나 정의되지 않은 상태의 속성.

---

### 3.2 문서 형식

내포 속성이 있는 복잡한 구조를 표현하기 위한 **문서 형식**이 있다.

- `List (L)` : 순서가 지정된 값 모음을 저장할 수 있음.
- `Мар (M)` : 정렬되지 않은 이름-값 쌍의 모음을 저장할 수 있음

---

### 3.2 다중 값 형식

여러 스칼라 값을 표현할 수 있는 다중 값 형식이 있다.

- `String Set (SS)` : 문자열 집합
- `Number Set (NS)` : 숫자 집합
- `Binary Set (BS)` : 이진 집합

---

## 4. DynamoDB 파티션 및 키

### 4.1 DynamoDB 파티션

`DynamoDB의 파티션` : DynamoDB가 데이터를 저장하는 곳

- SSD(Solid State Drive)로 백업되는 테이블용 스토리지 할당을 의미하며,
- 하나의 AWS 리전 내의 여러 가용 영역에 자동으로 복제된다.
- 이 파티션은 사용자가 직접 관리할 필요 없이 전적으로 DynamoDB에서 처리한다.

DynamoDB는다음과 같은 상황에 테이블에 추가 파티션을 할당한다.

- 기존 파티션이 지원할 수 있는 한도를 초과하여 테이블의 할당된 처리량 설정을 늘리는 경우
- 기존 파티션 용량이 다 차서 추가 스토리지 공간이 필요한 경우

---

### 4.2 DynamoDB 키

보통 DB에서 key라고 하면 Table내에서 각 Item을 구분하는 고유 식별자를 의미한다.

- `기본키 (Primary Key)`
  - Table내에서 각 ltem을 구분하는 고유 식별자
  - `단순 기본 키` : 파티션 키만 사용
  - `복합 기본 키` : 파티션 키와 정렬 키를 함께 사용
- `파티션 키(Partition Key)`
  - 데이터가 저장되어 있는 파티션을 결정하기 위한 키
  - 내부 해시 함수에 대한 입력으로 파티션 키 값을 사용
  - 출력에 따라 항목을 저장할 파티션이 결정됨
- `정렬 키 (Sort Key)` : 파티션 키가 동일한 모든 항목들을 정렬하는 키 값

DynamoDB에서는 파티션 키만 사용하거나 파티션 키와 정렬 키를 함께 사용하는 형태로 테이블의 기본 키를 설정할 수 있다.

- 먼저 `기본 키로 파티션 키만 사용하는 경우`, 파티션 키를 통해서 Item을 찾을 수 있다.
- 다음은 `기본 키로 파티션 키와 정렬 키를 함께 사용하는 경우`,
  - 파티션 키를 해시 함수의 입력으로 전달하여 Item이 저장되어 있는 파티션을 찾고,
  - 이후에 해당 파티션 내에서 정렬 키를 사용하여 Item을 찾는다.

---

## 5. DynamoDB 보조 인덱스

DynamoDB의 테이블에서는 하나 이상의 보조 인덱스를 생성할 수 있다.

- 보조 인덱스는 파티션 키에 대한 쿼리는 물론이고, 정렬 키를 사용하여 테이블 데이터에 대한 쿼리까지 실행할 수 있다.
- DynamoDB는 인덱스를 사용하도록 요구하지는 않으면서도 데이터를 쿼리할 때 애플리케이션에 보다 많은 유연성을 제공한다.
- 테이블에서 보조 인덱스를 생성한 후에는, 테이블에서 데이터를 읽는 것과 같은 방식으로 인덱스에서 데이터를 읽을 수 있다.

DynamoDB의 보조 인덱스에는 2가지 종류가 있다.

- `LSI (Local Secondary Index, 로컬 보조 인덱스)`
  - 테이블과 파티션 **키는 동일하지만 정렬 키는 다른** 인덱스
  - 테이블에 정렬 키(Sort Key)를 추가로 더 만든다고 생각하면 된다.
- `GSI (Global Secondary Index, 글로벌 보조 인덱스)`
  - 파티션 키 및 정렬 키가 **테이블의 파티션 키 및 정렬 키와 다를 수 있는** 인덱스

DynamoDB에서는 테이블당 최대 20개의 GSI 및 5개의 LSI를 정의할 수 있다.

---

### 5.1 GSI와 LSI의 차이점

| 특성                     | 글로벌 보조 인덱스                                                                                            | 로컬 보조 인덱스                                                                                          |
| ------------------------ | ------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| 키 스키마                | 단순 기본키(파티션 키) 또는복합 기본키(파티션 키 및 정렬 키)                                                  | 기본 키는 반드시복합 기본키(파티션 키 및 정렬 키)여야 함                                                  |
| 키 속성                  | 문자열, 숫자 또는 이진수 형식의 기본 테이블 속성                                                              | 기본 테이블의 파티션 키와 동일한 속성                                                                     |
| 파티션 키 값당 크기 제한 | 크기 제한이 없음                                                                                              | 파티션 키값마다 인덱싱된 모든 항목의 전체 크기가 10GB 이하여야 함                                         |
| 온라인 인덱스 작업       | 테이블을 생성할 때 동시에 GSI를 생성할 수 있음. 기존 테이블에 새 GSI를 추가하거나,기존 GSI를 삭제할 수도 있음 | 테이블을 생성할 때 동시에 LSI가 생성됨. 기존 테이블에 LSI를 추가할 수도 없고, 기존 LSI를 삭제할 수도 없음 |
| 쿼리 및 파티션           | 전체 테이블의 모든 파티션에 대해 쿼리 가능                                                                    | 파티션키가 같은 단일 파티션에 대해 쿼리 가능                                                              |
| 읽기 일관성              | 최종 일관성만 지원                                                                                            | 최종 일관성 또는 강력한 일관성 선택 가능                                                                  |
| 할당된 처리량 소비       | 자체 할당 처리량 설정이 있음GSI의 용량 단위를 소비                                                            | 기본 테이블의 읽기/쓰기 용량 단위를 소비 테이블에 쓸 때 해당 LSI도 업데이트 됨                            |
| 프로젝션 속성            | 인덱스로 프로젝션되는 속성만 요청할 수 있음                                                                   | 인덱스로 프로젝션되지 않는 속성도 요청할 수 있음                                                          |

보조 인덱스를 사용할 때는 각각의 특징을 꼭 잘 확인하고 사용하자.

---

### 5.2 로컬 보조 인덱스(LSI) 예

![lsi](https://raw.githubusercontent.com/berenickt/image-server/main/img/lsi.jpeg)

- 테이블의 파티션 키는 Name이고 정렬 키는 Subject
- LSI의 파티션 키는 Name으로 테이블과 동일하며, 정렬 키는 Score로 테이블과 다른 것을 볼 수 있다.
- 이렇게 로컬 보조 인덱스(LSI)를 만들어서 사용하게 되면,
  - Name과 Score 값을 이용해서 테이블 내에서 아이템을 찾을 수 있다.

---

### 5.3 글로벌 보조 인덱스(GSI) 예

![gsi](https://raw.githubusercontent.com/berenickt/image-server/main/img/gsi.jpeg)

- 글로벌 보조 인덱스의 파티션 키는 Subject가 되고, 정렬 키는 Name이다.
- 글로벌 보조 인덱스를 사용하면 다른 값으로 파티션을 나눌 수 있고,
  - 해당 파티션 내에서 아이템들을 정렬할 수 있다.

---

## 6. DynamoDB 데이터 조회

DynamoDB의 데이터 조회 방식에는 크게 `Query`와 `Scan`이 있다.

- `Query` : 기본 키 값을 기반으로 항목을 찾는 방식
  - 복합 기본 키가 있는 테이블 또는 보조 인덱스를 쿼리할 수 있음
  - 파티션 키 속성의 이름과 해당 속성의 단일 값을 제공해야 하며, 해당 파티션 키 값을 갖는 모든 항목을 반환함
  - 선택적으로 정렬 키 속성을 제공하고, 비교 연산자를 사용하여 검색 결과의 범위를 좁힐 수 있음
- `Scan` : 테이블 또는 보조 인덱스의 모든 항목을 읽어오는 방식
  - 기본적으로 테이블이나 인덱스에 속한 항목의 데이터 속성을 모두 반환한다.
  - ProjectionExpression 파라미터를 사용하면 일부 속성만 가져올 수 있다.
  - 항상 결과 집합을 반환하는데, 만약 일치하는 항목이 없다면 비어있는 결과 집합이 반환된다.
  - 단일 Scan 요청은 최대 1MB까지 데이터를 가져올 수 있다.
  - 이때 옵션으로 필터 표현식을 적용하면 반환되는 결과의 범위를 좁힐 수도 있다.

> 정리 : `Query`는 키 값으로 찾는 것이고, `Scan`은 전체 데이터를 가져와서 필터링 하는 것

e.g. 학교에서 학생을 찾는다면,

- `Query`는 학번으로 곧바로 부르는 것
  - 데이터를 조회하기 위해서는 Query를 사용
- `Scan`은 1명씩 불러서 학번이 일치하는지 확인하는 것

데이터를 조회하기 위해서는 Query를 사용하고, Scan은 속도도 느리고 비싸므로 웬만하면 사용하지 않는다.

---

## 7. (실습) DynamoDB 테이블 설계

DynamoDB의 테이블 설계는 일반적인 DB와는 조금 다르다.

- 전교생의 시험 점수를 DynamoDB에 넣어서 관리하려고 함
- 학생들은 저마다 고유 학번을 갖고 있음
- 시험 과목은 영어, 과학, 수학 총 3과목
- 아래와 같은 데이터 조회가 가능해야 함
  - 한 학생의 영어, 과학, 수학 점수를 다 가져오기
  - 각 과목별 점수로 정렬하여 학생 목록 가져오기

---

### 7.1 기본키 구성

- `단순 기본 키로 할 경우`
  - 파티션 키 : 학생의 학번
- `복합 기본 키로 할 경우`
  - 파티션 키 : 학생의 학번
  - 정렬 키 : 과목명

조건을 만족시키려면, 복합기본키를 사용하고 보조인덱스를 추가해야 한다.

---

### 7.2 보조 인덱스

`로컬 보조 인덱스` : 여기서는 굳이 필요없음

`글로벌 보조 인덱스` :

- 복합 기본 키
  - 파티션 키 : 과목명
  - 정렬키 : 점수

과목명으로 파티션을 나누고 파티션 내에서 점수를 기준으로 정렬할 수 있다.

---

## 8. (실습) DynamoDB 테이블 생성

[DynamoDB] → 왼쪽 메뉴 [테이블]페이지로 이동해서 [테이블 생성] 버튼을 클릭.
그러면 (테이블 생성) 페이지가 나온다.

- `테이블 이름` : StudentScore
- `파티션 키` : id, 숫자 타입
- `정렬 키` : subject, 문자열 타입
- `테이블 설정` : 설정 사용자 지정
  - 선택하면, 테이블 클래스, 용량 계산기 등이 나온다.
- 보조 인덱스에서 [글로벌 인덱스] 생성 버튼을 클릭
  - `파티션 키` : subject, 문자열 타입
  - `정렬키` : score, 숫자 타입
  - [인덱스 생성] 버튼을 클릭
  - 그럼 보조인덱스가 목록에 추가된 것을 볼 수 있다.
- 화면을 제일 하단으로 내려서 [테이블 생성] 버튼을 클릭한다.
- 테이블을 생성하는 것은 대략 1, 2분 정도가 소요된다.

생성된 테이블을 클릭해서 상세 정보를 보면, 파티션 키와 정렬 키도 확인 가능하다.

- [인덱스] 탭을 클릭해보면, 생성한 글로벌 보조 인덱스가 목록에 나온다.

---

## 9. (실습) DynamoDB 테이블 입력

[테이블 상세] 페이지에서 [작업] 메뉴를 클릭한다.

- 이후 나오는 목록에서 [항목 생성]을 클릭한다.
- 그럼 항목을 생성할 수 있는 화면이 나온다.
- [새 항목 추가] 버튼을 눌러서 타입별로 추가할 수 있다.

다음과 같이 입력해준뒤에 [항목 생성] 버튼을 클릭한다.

| 속성 이름 | 값   | 유형   |
| --------- | ---- | ------ |
| id        | 1    | 숫자   |
| subject   | Math | 문자열 |
| score     | 95   | 숫자   |

동일한 과정을 총 9번 반복하여, 다음 데이터들을 모두 입력한다.

| id  | subject | score |
| --- | ------- | ----- |
| 1   | English | 95    |
| 1   | Math    | 95    |
| 1   | Science | 88    |
| 2   | English | 80    |
| 2   | Math    | 100   |
| 2   | Science | 92    |
| 3   | English | 99    |
| 3   | Math    | 86    |
| 3   | Science | 89    |

---

## 10. (실습) DynamoDB 테이블 조회

### 10.1 쿼리

[테이블] 메뉴에서 목록을 클릭해 상세페이지로 이동한다.

- [표 항목 탐색] 버튼을 클릭한다.
- 쿼리는 테이블의 키를 이용해서 항목을 탐색하는 방식이기 때문에,
  - [쿼리]를 선택하면, 인덱스를 선택하는 옵션이 나온다.
- 여기서 테이블 또는 인덱스 선택 메뉴를 펼쳐보면,
  - 테이블의 기본키로 조회할 것인지 보조인덱스로 조회할 것인지 선택할 수 있다.
  - 먼저 테이블의 기본키로 조회할 것이다.

먼저 1번 학생의 전과목 점수를 조회하려면,

- `id : 1`을 입력하고 [실행] 버튼을 클릭

이번에는 과목으로 조회하기 위해서, 직접 만든 글로벌 보조 인덱스를 선택한다.

- `테이블 또는 인덱스 선택` : 만들어둔 subject-score-index 선택
- 글로벌 보조 인덱스를 선택하면, 파티션 키가 id가 아닌 subject로 바뀐다.
- 여기에 조회하려는 과목명을 입력하면 된다. (cf. Math)

---

### 10.2 스캔

스캔 방식은 전체 데이터를 가져온다.

- [스캔] 버튼을 누르고 [실행] 버튼을 클릭한다.
- 그러면, 모든 데이터가 나온다.
- 스캔에서 [필터] 버튼을 누르면, 스캔에서 필터를 추가할 수 있다.

1번 학생의 모든 과목 점수를 조회하려면,

- `속성이름` : id
- `유형` : 숫자
- `조건` : 같음
- `값` : 1
- 위와 같이 설정하고 [실행] 버튼을 클릭

수학 과목의 학생 목록을 조회하려면,

- `속성이름` : subject
- `유형` : 문자열
- `조건` : 같음
- `값` : Math
- 위와 같이 설정하고 [실행] 버튼을 클릭

---

## 11. (실습) DynamoDB 테이블 삭제

테이블 상세 페이지에서 [작업] 메뉴를 클릭한다.

- 이후 [테이블 삭제]를 클릭합니다.
- 그러면 테이블을 삭제하기 전에 한 번 더 확인하기 위한 다이얼로그가 나온다.
  - 여기에 `확인`이라고 입력한다.
  - 테이블 삭제가 진행되고, 시간이 조금 지나면 테이블 삭제가 완료된다.
