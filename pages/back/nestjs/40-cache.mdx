---
title: '40-Cache'
date: 2023/12/25
---

## 1. 캐싱

캐싱이 왜 필요한가?

---

### 1.1 캐싱의 사용처

- 랭킹 시스템 최신 영화, 인기 영화 등
- 사용자 세션 데이터 세션 정보 저장, 토큰 검증 프로세스 스킵, 토큰 밴
- 변화가 적은 데이터 캐싱 영화 상세내용
- 외부 API 캐싱 외부 API 결과를 캐싱해서 외부 리소스 사용 비용 절감
- Rate Limiting, Throttling 사용자의 요청 횟수를 캐싱한 후 특정 횟수를 넘으면 에러를 반환 할 수 있다

---

### 1.2 캐싱의 장점

- `퍼포먼스 향상` : 데이터를 빠르게 가져오고 백엔드 서비스 과부하를 최소화 할 수 있다
- `Scalability` : 캐싱을 사용하지 않을때보다 훨씬 높은 트래픽을 감당 할 수 있다
- `비용 절감` : 비싼 리소스를 캐싱 해두어서 비용절감 효과를 누릴 수 있다
- `UX 개선` : 퍼포먼스가 좋아지며 자연스럽게 UX 개선이 된다

---

### 1.3 캐싱의 단점

- `스테일 (Stale) 데이터` : 데이터 신선도(?)가 부족하다. 즉, 최신 데이터가 아니다
- `메모리 사용 증가` : 캐시는 빠른 접근이 목적이기 때문에 메모리에 저장된다. 메모리 사용량이 늘어난다
- `디자인 복잡성` : 소프트웨어 아키텍처에 캐시가 포함되면서 디자인 복잡도가 높아진다
- `보안 리스크` : 적합한 데이터를 캐싱하지 않으면 보안 리스크가 생길 수 있다

---

## 2. Redis를 활용한 캐싱

### 2.1 Monolithic Architecture

Monolithic Architecture는 모든 기능이 하나의 코드베이스에 포함된 단일 애플리케이션을 의미합니다.
이 아키텍처에서는 모든 모듈이 강하게 결합되어 있으며, 애플리케이션의 모든 부분이 함께 배포되고 확장됩니다.

Monolithic Architecture의 장점

- `단순성`: 개발, 테스트, 배포가 상대적으로 간단하다.
- `성능`: 모듈 간의 통신이 동일한 프로세스 내에서 이루어지기 때문에 성능이 좋다.
- `디버깅`: 단일 코드베이스이기 때문에 디버깅이 용이하다.

Monolithic Architecture의 단점

- `확장성`: 특정 모듈만 확장하기 어렵다.
- `유지보수`: 코드베이스가 커질수록 유지보수가 어렵다.
- `배포`: 작은 변경 사항도 전체 애플리케이션을 다시 배포해야 한다.

---

### 2.2 Microservice Architecture

마이크로서비스 아키텍처(Microservice Architecture)

- 애플리케이션을 여러 개의 작은 독립적인 서비스로 분리하여 개발, 배포, 확장 및 유지보수를 용이하게 하는 소프트웨어 아키텍처다.
- 각 서비스는 특정 비즈니스 기능을 담당하며, 독립적으로 배포되고 확장될 수 있다.

마이크로서비스 아키텍처의 주요 특징

- `독립적인 배포`: 각 서비스는 독립적으로 배포될 수 있어, 특정 서비스에 대한 변경 사항이 전체 시스템에 영향을 미치지 않는다.
- `독립적인 확장`: 각 서비스는 독립적으로 확장될 수 있어, 특정 서비스에 대한 수요 증가에 따라 개별적으로 확장할 수 있다.
- `모듈화`: 각 서비스는 특정 비즈니스 기능을 담당하며, 모듈화된 구조를 가진다.
- `다양한 기술 스택`: 각 서비스는 독립적으로 개발되기 때문에, 각 서비스에 적합한 기술 스택을 사용할 수 있다.
- `작은 팀`: 각 서비스는 작은 팀에 의해 관리될 수 있어, 팀 간의 의사소통이 원활해지고 개발 속도가 빨라진다.

마이크로서비스 아키텍처의 장점

- `유연성`: 새로운 기술을 도입하거나 변경하기가 용이하다.
- `확장성`: 특정 서비스만 확장할 수 있어, 자원을 효율적으로 사용할 수 있다.
- `신뢰성`: 한 서비스의 장애가 전체 시스템에 영향을 미치지 않도록 격리할 수 있다.
- `빠른 배포`: 독립적인 배포가 가능하여, 새로운 기능을 빠르게 배포할 수 있다.

마이크로서비스 아키텍처의 단점

- `복잡성 증가`: 서비스 간의 통신, 데이터 일관성, 배포 관리 등에서 복잡성이 증가한다.
- `운영 비용 증가`: 여러 서비스가 독립적으로 운영되기 때문에, 모니터링, 로깅, 배포 등의 운영 비용이 증가할 수 있다.
- `데이터 관리`: 분산된 데이터베이스를 관리하는 것이 어려울 수 있다.

---

### 2.3 Redis Store

```ts
import type { RedisClientOptions } from 'redis'
import * as redisStore from 'cache-manager-redis-store'
import { Module } from '@nestjs/common'
import { CacheModule } from '@nestjs/cache-manager'
import { AppController } from './app.controller'

@Module({
  imports: [
    CacheModule.register<RedisClientOptions>({
      store: redisStore,
      host: 'localhost',
      port: 6379,
    }),
  ],
  controllers: [AppController],
})
export class AppModule {}
```
