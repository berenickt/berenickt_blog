---
title: '05-서버 프로그램 구현'
date: 2023/12/14
---

# 1. 개발 환경 구축

## 1.1 서버 환경 구축

### 1.1.1 웹 서버 (WEB)

- 클라이언트에게 `정적 파일`(HTML, CSS, JS, 이미지)<u>을 제공하는 웹서버 어플리케이션이 설치된 하드웨어</u>
- 이미지, CSS, JS, HTML 문서를 클라이언트에게 전달
- Apache Web Server, IIS, nginx, GWS 등

### 1.1.2 웹 어플리케이션 서버 (WAS)

- `동적인 웹 서비스를 제공`하기 위한 <u>미들웨어가 설치된 하드웨어</u>
- 클라이언트 요청에 맞는 동적인 컨텐츠를 생성한다.
- DB조회나 다양한 로직을 처리한다.
- Web Logic, Web Spere, Jeus, Tomcat 등

### 1.1.3 데이터베이스 서버 (DBMS)

- `데이터의 저장과 관리`를 위한 데이터베이스 소프트웨어가 설치된 하드웨어
- Oracle, MySQL, MS-SQL 등

### 1.1.4 파일서버

- `사용자의 파일을 저장하고, 파일을 공유`할 목적으로 구성된 하드웨어

### 1.1.5 Load Balancer

- 여러 대의 서버가 존재할 경우 <u>요청을 적절히 분배해주는 역할</u>
- 분배 방식

|      종류      | 설명                                                                 |
| :------------: | -------------------------------------------------------------------- |
|    `Random`    | 요청을 <u>랜덤으로 분배</u>한다.                                     |
| `Least loaded` | <u>가장 적은 양의 작업을 처리하고 있는 서버에게</u> 요청을 할당한다. |
| `Round Robin`  | <u>순서를 정하여 돌아가며 작업 분배</u>한다.                         |

### 1.1.6 CDN(Content Delivery Network)

- 용량이 큰 컨텐츠 데이터(이미지, 비디오 등)를 <u>빠른 속도로 제공</u>하기 위해 <u>사용자와 가까운 곳에 분산되어있는 데이터 저장 서버</u>
- 클라이언트는 용량이 큰 컨텐츠 데이터를 가까운 CDN에 요청해 멀리 있는 <u>웹서버에서 직접 받는 것보다 빠르게 받을 수 있다</u>.

### 1.1.7 시스템 아키텍처 고려사항

- `확장성 (Scalability)` : 클라이언트 수가 늘어났을 때 무리 없이 요청을 처리할 수 있는 <u>확장성을 고려</u>
- `성능 (Performance)` : <u>요청한 내용을 정확하고 빠르게</u> 돌려주어야 한다.
- `응답 시간 (Latency)` : 모든 요청은 <u>클라이언트가 불편해하지 않을 정도로 빠른 시간 안에</u> 돌려주어야 한다.
- `처리량 (Throughput)` : <u>같은 시간 안에 더욱 많은 요청을 처리</u>
- `접근성 (Availability)` : 사용자가 <u>언제든지 시스템에 요청을 보내서 응답</u>을 받을 수 있어야 한다.
- `일관성 (Consistency)` : 사용자가 <u>서버에 보낸 요청이 올바르게 반영</u>되어야 하고, <u>일정한 결과를 돌려주어야</u> 한다.

---

## 1.2 개발 소프트웨어 환경

### 1.2.1 시스템 소프트웨어

#### 1.2.1.1 운영체제(OS, Operation System)

- 하드웨어 운영을 위한 운영체제
- Windows, Linux, UNIX 등의 환경으로 구성됨

#### 1.2.1.2 JVM(Java Virtual Machine)

- `JAVA 관련 프로그램을 기동하기 위한 환경`
- 모든 개발자가 동일한 버전을 적용하는 것이 좋다.

#### 1.2.1.3 Web Server

- `정적 웹 서비스를 수행하는 미들웨어`
- 웹 브라우저 화면에서 요청하는 `정적 파일을 제공`한다. (Image, CSS, Javascript, HTML 등)
- Apache, Nginx, IIS(Internet Information Server), GWS(Google Webserver) 등

#### 1.2.1.4 WAS(Web Application Server)

- `동적 웹 서비스를 수행하는 미들웨어`
- Tomcat, Undertow, JEUS, Weblogic, Websphere 등

#### 1.2.1.5 DBMS(Database Management System)

- `데이터 저장과 관리`를 위한 데이터베이스 소프트웨어
- Oracle, DB2, Sybase, SQL Server, MySQL 등

---

### 1.2.2 개발 소프트웨어

#### 1.2.2.1 요구사항 관리 도구

- 고객의 `요구사항을 수집, 분석, 추적을 쉽게 할 수 있도록 지원`한다.
- JFeature, JRequisite, OSRMT, Trello 등

#### 1.2.2.2 설계/모델링 도구

- 기능을 논리적으로 표현할 수 있는 통합 모델링 언어(UML) 지원
- `Database 설계를 지원하는 도구`
- ArgoUML, StarUML, DB Designer 등

#### 1.2.2.3 구현도구

- `소프트웨어 언어를 통해 구현 및 개발을 지원`하는 도구
- Eclipse, InteliJ, Visual Studio 등

#### 1.2.2.4 테스트 도구

- 개발된 모듈들에 대하여 요구 사항에 적합하게 구현되어 있는지 테스트를 지원하는 도구
- 개발된 `모듈들에 대한 오류가 없는지 테스트를 지원`하는 도구
- 개발된 모듈들에 대하여 성능을 테스트 하는 도구
- JUnit, CppUnit, JMeter, SpringTest 등

#### 1.2.2.5 형상관리 도구

- 산출물 및 소스코드의 `변경 사항을 버전별로 관리`하여, 목표 시스템의 품질 향상을 지원하는 도구
- Git, CVS, SVN 등

---

## 1.3 IDE(Integrated Development Environment) 도구

### 1.3.1 IDE 도구의 개념

- 소프트웨어 `개발에 필요한 많은 도구의 기능을 하나로 묶어 활용`하는 소프트웨어
- 코딩, 디버그, 컴파일, 배포 등 프로그램 개발에 관련된 모든 작업을 하나의 프로그램 안에서 처리하는 환경을제공하는 소프트웨어
- <u>기존의 소프트웨어 개발에서는 컴파일러, 텍스트 편집기, 디버거 등을 따로 사용</u>
  했으나, * <u>편리한 개발을 위해 하나로 묶은 대화형 인터페이스</u>를 제공

### 1.3.2 IDE 도구의 기능

- 소스코드를 작성하기 위한 `텍스트 에디터`
- 작성한 코드를 기계어로 변환해주는 `컴파일`
- 작성한 코드에 문제가 없는지 체크해주는 `디버거`
- 완성된 프로그램을 서버에 업로드 하는 `배포`
- 추가적인 기능을 제공하는 `플러그인`

### 1.3.3 IDE 도구의 종류

- 이클립스 (Eclipse)
- 비주얼 스튜디오 (Visual Studio)
- 엑스코드 (X Code)
- IntelliJ IDEA

### 1.3.4 IDE 도구 선정시 고려 사항

|  기준  | 설명                             |
| :----: | -------------------------------- |
| 적정성 | 대상 업무에 적절한 도구 선정     |
| 효율성 | 프로그래밍의 효율성 고려         |
| 이식성 | 여러 OS에 개발환경 설치 가능     |
| 친밀성 | 프로그래머가 익숙한 언어 및 도구 |
| 범용성 | 다양한 개발 사례가 존재          |

---

## 1.4 협업 도구

### 1.4.1 협업 도구의 개념

- 여러 사용자가 `각기 별개의 작업 환경에서 통합된 하나의 프로젝트를 동시에 수행`할 수 있도록 도와주는 소프트웨어
- 소프트웨어 개발을 진행하는 데는 개발자 뿐만 아니라, 디자이너, 기획자, 현업 관리자 등 많은 사람들이 진행을 하게 되고, 공통의 주제인 <u>소프트웨어 개발을 공유</u>해야 한다.
- 구성원 간 일어나는 모든 커뮤티케이션을 하나의 채널에서 가능하게끔 만들어 준다.
- 협업툴의 주요 기능과 형태는 서비스마다 다르지만 대부분 소프트웨어형 서비스(Saas) 클라우드 기반으로 한다.

### 1.4.2 협업 도구의 기능

- 전사관리 : 전자결재, 조직도 등
- 프로젝트 관리 : 캘린더, 타임라인, `간트차트`, 대시보드 등
- 자체 드라이브 공간
- 문서 공유 지원
- 커뮤니케이션
- 다국어 지원
- `타 협업툴간 연동 지원`

### 1.4.3 협업 도구의 분류

- `SNS 형` : 슬랙, 야머, 아지트, 잔디, 워크플레이스 등
- `프로젝트 관리형` : 트렐로, 구글 스프레드시트, 노션, 아사나 등
- `통합형` : 콜라비, 플로우, 큅, 드롭박스 비즈니스 등

### 1.4.4 협업툴 도입 이유

- 기존 사내 메신저가 불편하다.
- 사용하는 툴이 너무 많다.
- `프로젝트의 일정이 제대로 공유되지 못하여` 스케줄에 이상이 생긴다.
- 인수인계가 원활하지 못하다.
- 자료를 각자 가지고 있어 다른 팀원에게 요청해야 한다.
- 서로의 업무를 모른다.

### 1.4.5 협업 도구 도입 프로세스

- 문제 정의
- 문제에 대한 솔루션, 기대효과 정의
- 협업 도구 분석
- 협업 도구 최종 선정

---

## 1.5 형상 관리 도구⭐

### 1.5.1 형상 관리 도구의 개념

- 소프트웨어 `생명주기 동안 발생하는 변경사항을 통제`하기 위한 관리 방법
- 소프트웨어의 변경사항을 체계적으로 관리하는 것

### 1.5.2 형상 관리의 필요성

- 개발 도중 소스코드를 이전 상태로 되돌릴 필요가 있을 경우
- 각 변경점에 대한 이력 확인
- 여러 개발자의 동시 개발에 따른 충돌 해결
- 버그 및 문제점 발생시 추적이 용이
- 기타 산출물의 이력관리도 용이

### 1.5.3 변경 관리/버전 관리/형상 관리

- `변경 관리`
  - <u>소스의 변경 상황을 관리</u>
  - 문서의 변경 이력과 복원 등의 기능이 제공
- `버전 관리`
  - <u>변경을 관리</u>하기 위한 효과적인 방법
  - 체크인, 체크아웃, 릴리즈, 퍼블리싱의 과정을 버전으로 관리할 수 있다.
- `형상 관리`
  - <u>변경 관리와 버전 관리가 포함</u>되고, 프로젝트 진행상황, <u>빌드와 릴리즈까지 모두 관리</u>할 수 있는 통합 시스템

### 1.5.4 형상 관리 대상

- 프로젝트 수행 계획서, 요구사항 관리대장, SW 기능 구조도
- 엔티티 정의서, 데이터 흐름도, 용어집
- 인터페이스, ERD, UI 정의서
- 소스 코드, 단위 테스트 관리 대장
- 테스트 계획서/시나리오
- 사용자/운영자 매뉴얼, 최종 산출물

### 1.5.5 형상 관리 절차 : `식통감기`⭐

- `형상 식별`
  - 형상 관리의 시작으로 시스템을 구성하는 요소들 중 형상 관리의 대상들을 구분하고 <u>관리 목록의 번호를 정의하여 부여</u>한다.
  - 형상 항목은 단순히 소스파일 뿐만 아니라 산출물, 개발이력, <u>개발과정에서 작성되는 문서까지 모두 포함</u>
- `형상 통제`⭐
  - 소프트웨어 형상 변경 요청을 검토하고 승인하여 <u>현재의 베이스라인에 반영될 수 있도록 통제</u>
  - 형상통제가 이루어지기 위해서는 <u>형상 통제 위원회</u>(Configuration Control Board, CCB)의 승인을 통한변경 통제가 이루어져야 한다.
- `형상 감사` : 형상 항목의 <u>변경이 계획에 따라 제대로 이뤄졌는지를 검토</u>하고 승인
- `형상 기록/보고`
  - 프로젝트 팀, 회사, <u>클라이언트 등에게 소프트웨어 개발 상태에 대한 보고서를 제공</u>
  - 베이스라인 산출물에 대한 변경과 처리 과정에서의 변경을 모두 기록

---

## 1.6 버전 관리 도구

### 1.6.1 소프트웨어 버전 관리 도구 개념

- 동일한 소스 코드에 대한 `여러 버전을 관리`하는 것
- 개발 중인 소스 코드나, 설계 문서 등의 디지털 문서를 관리하는데 사용
- 문서의 변경 사항들에 `숫자나 문자로 이뤄진 버전을 부여`해서 구분
- 버전을 통해서 변경된 시간과 변경된 내용, 작업자를 추적할 수 있다.

### 1.6.2 소프트웨어 버전 관리 도구 유형

#### (1) 공유 폴더 방식 (RCS, SCCS)

- 매일 개발 완료 파일은 `약속된 위치의 공유 폴더에 복사`
- 담당자 한 명이 매일 `공유 폴더의 파일을 자기 PC로 복사`하고 컴파일하여 에러 확인과 정상 동작 여부 확인
- 정상 동작일 경우 다음날 각 개발자들이 동작 여부 확인

#### (2) 클라이언트/서버 방식 (CVS, SVN)

- `중앙에 버전 관리 시스템이 항시 동작`
- 개발자들의 현재 작업 내용과 이전 작업내용 축적 용이
- 서로 다른 개발자가 같은 파일을 작업했을 때 경고 출력
- Trac이나 CVS view와 같은 GUI 툴을 이용 모니터링 가능

#### (3) 분산 저장소 방식 (Git, Betkeeper)

- `로컬 저장소와 원격저장소 구조`
- `중앙의 저장소에서 로컬에 복사(clone)한 순간 개발자 자신만의 로컬저장소에 생성`
- 개발 완료한 파일 수정 이후 `로컬 저장소에 커밋`한 이후 다시 `원격 저장소에 반영(Push)`하는 방식

### 1.6.3 버전 관리 도구별 특징

- `CVS`
  - <u>오랜 기간 사용된 형상 관리 도구</u>로, 다양한 운영체제를 지원
  - 중앙에 위치한 <u>Repository에 파일을 저장</u>하고, <u>인가된 모든 사용자가 파일에 접근</u>할 수 있다.
  - 파일의 히스토리를 보존하기 때문에 과거 이력을 확인할 수 있다.
  - <u>Commit 중 오류가 발생하면 롤백되지 않는다.</u>
  - 다른 개발자가 작업 중인 파일에 덮어쓰기가 방지된다.
  - 상대적으로 속도가 느리다.
  - 등록된 파일이나 <u>디렉토리의 변동이 불편</u>하다.
- `SVN`
  - <u>CVS의 단점을 보완</u>하기 위해 만들어졌다.{' '}
  - 최초 1회에 한해 <u>파일 원본을 저장</u>하고, <u>그 이후에는 실제 파일이 아닌 원본과 차이점을 저장</u>하는 방식
  - 언제든지 원하는 시점으로 복구가 가능
  - Commit 실패시 Rollback 이 가능
  - <u>Trunk, Branches, Tags 의 폴더로 구성</u>하여 형상 관리를 한다.
- `Git`
  - <u>리누스 토발즈가 리눅스 커널의 개발을 위해 만들었다</u>.
  - 원격 서버 Git Repository에 push 하지 않은 채 여러 branch 생성이 가능하다.
  - 로컬 우선 작업을 통해 <u>성능이 SVN, CVS보다 우수</u>하다.
  - 팀 개발을 위한 분산 환경 코딩에 최적화되어 있다.
  - <u>원격 Repository에 장애가 있어도 버전 관리가 가능</u>하다.
- `Clear Case`
  - IBM에서 개발된 유료 버전의 형상 관리 툴
  - 서버가 부족할 때 서버를 하나씩 늘려 확장할 수 있다.
- `BitKeeper` : SVN과 비슷한 중앙 통제 방식으로 대규모 프로젝트에서 빠른 속도를 내도록 개발된 버전관리 도구
- `RCS(Revision Control System)`: 소스 파일의 수정을 한 사람만으로 제한해 다수의 사람이 파일의 수정을 동시에 할 수 없도록 파일을잠금하는 방식으로 버전 컨트롤을 수행

### 1.6.4 버전 관리 주요 용어

|    용어    | 설명                                                   |
| :--------: | ------------------------------------------------------ |
| Repository | 저장소                                                 |
|  Checkout  | Repository에서 로컬로 프로젝트를 복사                  |
|   Commit   | 로컬의 변경된 내용을 Repository에 저장                 |
|   Update   | Repository에 있는 내용을 로컬에 반영                   |
|    Add     | 로컬에서 새로운 파일이 추가되었을 때 Repository에 등록 |
|   Trunk    | Root 프로젝트                                          |
|   Branch   | Root 프로젝트에서 파생된 프로젝트                      |
|   Merge    | Branch에서 진행하던 작업을 Root 프로젝트와 합침        |
|    Diff    | 파일의 비교                                            |

### 1.6.5 버전 관리 소프트웨어 사용 방식

![info-processing_5_1](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_5_1.png)

- 프로젝트 시작시 프로젝트에 사용될 프레임워크, 기본 문서들을 `최초로 import` 한다.
- 프로젝트 참여자들은 `각자의 계정을 생성`하고, 모든 파일들을 `인출(Checkout)` 한다.
- 참여자는 `새로운 파일 생성`시 해당 파일을 버전 관리 시스템에 `추가(add)` 한다.
- 참여자는 `기존 파일 수정시 수정된 내용`을 저장소에 `저장(Commit)` 한다.
- 참여자는 `로컬에 있는 파일과 다른 버전의 파일`이나 신규 파일들을 `동기화(Update)` 한다.
- `동기화시 두 파일의 내용을 비교(Diff)` 할 수 있다.

### 1.6.6 버전 관리 도구 사용 유의점

- 형상 관리 지침에 의거 <u>버전에 대한 정보를 언제든지 접근</u>할 수 있어야 한다.
- 제품 소프트웨어 개발자, 배포자 이외에 <u>불필요한 사용자가 소스를 수정할 수 없도록</u> 해야 한다.
- 동일한 프로젝트에 대해서 <u>여러 개발자가 동시에 개발</u>할 수 있어야 한다.
- <u>에러 발생 시 최대한 빠른 시간 내에 복구</u>한다.

---

## 1.7 빌드 도구

### 1.7.1 빌드의 개념

- 소스코드 파일들을 컴퓨터에서 실행할 수 있는 소프트웨어로 변환하는 일련의 과정
- 빌드의 단계 중 컴파일이 포함이 되어 있는데 컴파일은 빌드의 부분집합
- 빌드 과정을 도와주는 도구를 빌드 툴 이라고 한다.
- 빌드 자동화 도구는 `지속적인 통합(Continuous Integration)을 수행`할 수 있도록 도와준다.

### 1.7.2 빌드 자동화 도구 특징

- `빌드, 테스트, 배포를 자동으로 수행하는 도구`
- 소스 코드를 컴파일, 테스트, 정적분석 등을 실시하여 실행 가능한 애플리케이션으로 자동으로 생성 (war 파일로 만들어줌)
- 계속해서 늘어나는 라이브러리 자동 추가 및 관리 Ÿ 프로젝트를 진행하며 시간이 지남에 따라 라이브러리의 버전을 자동으로 동기화 한다.

### 1.7.3 빌드 자동화 프로세스

![info-processing_5_2](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_5_2.png)

- `빌드`
  - <u>개발자가 저장장소에 코드를 커밋</u>한다.
  - 코드 변경 사항은 운영 환경과 일치하는 환경에 통합한다.
- `테스트`
  - JenKins나 Ansible과 같은 배포 자동화 툴에서 새로운 코드를 인식하고 <u>일련의 테스트를 수행</u>한다.
  - 테스트를 통과한 빌드는 운영 환경으로 릴리즈 할 수 있다.
- `배포`: 소프트웨어를 <u>운영 환경에 배포하여 사용자에게 제공</u>한다

### 1.7.4 빌드 자동화 도구 종류

- `Make`
  - <u>유닉스 계열 운영체제에서 주로 사용</u>되는 프로그램 빌드 도구이다.
  - 파일 간 종속관계를 파악하여 Makefile(기술파일)에 적힌 내용을 컴파일러가 순차적으로 실행하게 한다.
- `Ant`
  - Java 기반의 빌드 도구로 다른 빌드 도구 보다 역사가 오래 되었다.
  - 개발자가 원하는 형태로 개발을 할 수 있다는 유연성에 장점이 있다.
  - XML 기반의 빌드 스크립트로 개발한다.
  - 스크립트의 재사용이 어렵다.
  - Remote Repository를 가져올 수 없다.
- `Maven`
  - 프로젝트에 필요한 모든 Dependency를 리스트 형태로 Maven에게 알려 관리할 수 있도록 돕는 방식이다.
  - 필요한 라이브러리를 특정 파일(pom.xml) 에 정의해 놓으면 해당 <u>라이브러리와 관련된 라이브러리</u>까지 네트워크를 통해
    <u>자동으로 다운</u>받는다.
  - 정해진 라이프사이클에 의하여 작업 수행하며, 전반적인 프로젝트 관리 기능까지 포함한다.
- `Jenkins`
  - <u>Java 기반의 오픈소스</u>로, 소프트웨어 개발 시 `지속적 통합(continuous integration) 서비스를 제공`하는 툴
  - 서블릿 컨테이너에서 실행되는 서버 기반 도구
  - SVN, Git 등 대부분의 형상 관리 도구와 연동이 가능
  - 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트가 가능
- `Gradle`
  - <u>Groovy를 기반</u>으로 한 오픈 소스 형태의 자동화 도구로 `안드로이드 앱 개발 환경`에서 사용
  - 안드로이드 뿐만 아니라 플러그인을 설정하면 Java, C/C++, Python 등의 언어도 빌드가 가능
  - Groovy를 사용해서 만든 DSL(Domain Specific Language)을 스크립트 언어로 사용
  - Gradle은 실행할 처리 명령들을 모아 태스크로 만든 후 테스크 단위 실행

---

# 2. 개발 프레임워크

## 2.1 프레임워크의 개념⭐

- 소프트웨어 개발에 공통적으로 사용되는 <u>구성 요소와 아키텍처를 일반화하여 손쉽게 구현</u>할 수 있도록,
  여러 가지 기능들을 제공해주는 <u>반제품 형태의 소프트웨어</u>
- 소프트웨어 개발에 바탕이 되는 템플릿과 같은 역할을 하는 클래스들과 인터페이스의 집합
- 소프트웨어 개발시 공통적인 부분을 제공

---

## 2.2 프레임워크의 특징: `역모재확`⭐

- `제어의 역흐름(inversion of control)`
  - 프레임워크가 <u>외부의 이벤트에 대해 애플리케이션이 어떠한 메소드들을 수행해야 하는지</u> 결정
- `모듈화 (modularity)`
  - 프레임워크는 <u>구현을 인터페이스 뒤에 감추는 캡슐화</u>를 통해서 <u>모듈화를 강화</u>
  - 설계와 구현의 변경에 따르는 영향을 최소화시킴으로써 쉽게 소프트웨어의 품질을 향상시킴
- `재사용성 (reusability)`
  - 프레임워크가 제공하는 인터페이스는 <u>여러 어플리케이션에서 반복적으로 사용</u>할 수 있는 일반적인 컴포넌트를
    정의할 수 있게 함으로써 <u>재사용성을 높여준다.</u>
  - 소프트웨어의 품질, 성능, 신뢰성, 상호 운용성을 향상시키고, 프로그래머의 생산성을 높여준다.
- `확장성(extensibility)`
  - 다형성(polymorphism)을 통해 애플리케이션의 <u>프레임워크의 인터페이스를 확장</u>할 수 있게 한다.
    - `오버로딩(overloading, 과부화)` : 같은 클래스내에서 같은 이름의 메서드를 사용하는것
      - 하나의 메서드 이름을 끝없이 사용한다는 뜻
    - `오버라이딩(overriding, 가장 우선되는)` : 부모Class에서 정의한 메서드를 자식 Class에서 변경하는 것
      - override : 무시하다, 무효하다

---

## 2.3 프레임워크의 구분

- `Java 프레임워크` : 전자정부 표준 프레임워크, 스트럿츠, 스프링
- `ORM 프레임워크` : 아이바티스(iBatis), 마이바티스(myBatis), 하이버네이트(Hibernate)
- `자바스크립트 프레임워크` : 앵귤러제이에스(AngularJS), ReactJS, ExtJS
- `프론트엔드 프레임워크` : Bootstrap, Foundation, MDL

---

## 2.4 라이브러리(Library)⭐

- 컴퓨터 프로그램에서 빈번하게 사용되는 <u>사전 컴파일된 루틴 또는 리소스</u>(클래스, 템플릿, 설정 데이터 등)<u>를 모아둔 것</u>
- 재사용이 필요한 기능으로 반복적인 코드 작성을 없애기 위해 언제든지 필요한 곳에서 호출하여 사용할 수 있도록 Class나 Function
- `라이브러리`는 <u>어플리케이션의 특정 기능</u>, `프레임워크`는 <u>어플리케이션의 구조</u>⭐

---

## 2.5 API(Application Programming Interface)⭐

- 일종의 소프트웨어 인터페이스이며 <u>다른 종류의 소프트웨어에 서비스를 제공</u>한다.
- API는 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게만든 인터페이스
- API 특징
  - 개발 비용 감축
  - 반복 작업 줄이기
  - 쉬운 유지 관리
  - 새로운 수익 채널의 확대
  - 비즈니스 파이의 확장

---

# 3. 모듈 구현

## 3.1 단위 모듈 구현

### 3.1.1 단위 모듈 구현의 개념

- `소프트웨어를 기능 단위로 분해하여 구현`하는 기법
- 서브시스템, 서브루틴, 작업 단위 등으로 나누어 각 모듈이 `독립적으로 활용될 수 있게 구현`
- 모듈의 크기는 작고, 하나의 일만을 수행
- 모듈의 크기가 작으면 읽기 쉽고, 구현하기 쉬우며, 테스트 부담이 적어진다

### 3.1.2 단위 모듈 구현 시 장점

- 프로그램의 효율적인 관리 및 성능이 향상
- 전체적인 소프트웨어 복잡성 감소 및 이해성 증대
- 테스트, 모듈 통합, 변경 용이성 쉬움
- 기능의 분리가 가능하고 인터페이스가 단순해짐
- 오류의 파급효과 최소화
- `모듈의 재사용으로 개발과 유지보수가 용이`

### 3.1.3 효과적인 모듈화

- `결합도를 줄이고 응집도를 높여 모듈의 독립성을 높임`⭐
- FAN-OUT 최소화, FAN-IN 증가
- 모듈 인터페이스를 평가하여 복잡성과 중복성을 줄이고 일관성을 높인다.
- 기능 예측이 가능한 모듈을 정의
- 하나의 입력과 하나의 출력을 유지

### 3.1.4 단위 모듈 설계의 원리⭐

- `단계적 분해` : 처음엔 간단히 작성하고, 점점 세밀하게 작성
- `추상화` : 복잡한 문제를 일반화하여, 쉽게 이해할 수 있도록 한다.
- `독립성`: 모듈은 응집도는 높이고 결합도는 낮춰 독립성을 가져야 한다.
- `정보은닉`: 모듈 내부의 데이터를 외부에 은폐
- `분할과 정복`: 큰 문제를 작게 나누어 하나씩 해결

### 3.1.5 단위 모듈 작성 원칙 : `정명완일추`⭐

- `정확성 (Correctness)` : <u>해당 기능</u>이 실제 시스템 구현 시 필요한지 여부를 알 수 있도록 <u>정확하게 작성</u>
- `명확성 (Clarity)` : <u>해당 기능</u>에 대해 <u>일관되게 이해</u>되고 한 가지로 해석될 수 있도록 작성
- `완전성 (Completeness)` : 시스템이 구현될 때 <u>필요하고 요구되는 모든 것을 기술</u>
- `일관성 (Consistency)` : 공통 <u>기능들 간에 상호 충돌이 없도록 작성</u>
- `추적성 (Traceability)` : 공통 <u>기능에 대한 요구사항 출처</u>와 관련 시스템 등의 <u>유기적 관계에 대한 식별이 가능하도록</u> 작성

---

## 3.2 결합도

### 3.2.1 결합도(Coupling)의 개념

- `어떤 모듈이 다른 모듈에 의존하는 정도`
- 두 모듈 사이의 연관 관계
- `결합도가 낮을수록` 잘 설계된 모듈이다.

### 3.2.2 결합도 유형 :`내공외제스자`⭐

내부 공사는 외제를 스자

결합도 : 내용 결합도 가장 ↑, 자료결합도가 가장 ↓

|              구분               | 설명                                                                                                               |
| :-----------------------------: | ------------------------------------------------------------------------------------------------------------------ |
| 내용 결합도 (Content Coupling)  | 다른 모듈 내부에 있는 <u>변수나 기능을 다른 모듈에서 사용</u>하는 경우                                             |
|  공통 결합도 (Common Coupling)  | 파라미터가 아닌 <u>모듈 밖에 선언되어 있는 전역 변수를 참조</u>하고 전역 변수를 갱신하는 식으로 상호 작용하는 경우 |
| 외부 결합도 (External Coupling) | 어떤 모듈에서 선언한 데이터(변수)를 <u>외부의 다른 모듈에서 참조</u>하는 경우                                      |
| 제어 결합도 (Control Coupling)  | 단순 처리할 대상인 값만 전달되는 게 아니라 어떻게 처리를 해야 한다는 <u>제어 요소가 전달</u>되는 경우              |
| 스탬프 결합도 (Stamp Coupling)  | 모듈 간의 인터페이스로 <u>배열이나 오브젝트, 스트럭처 등이 전달</u>되는 경우                                       |
|   자료 결합도 (Data Coupling)   | 모듈 간의 인터페이스로 <u>값이 전달</u>되는 경우                                                                   |

---

## 3.3 응집도

### 3.3.1 응집도(Cohesion)의 개념

- 모듈의 독립성을 나타내는 개념으로, `모듈 내부 구성요소 간 연관 정도`
- 정보 은닉 개념의 확장개념으로, 하나의 모듈은 하나의 기능을 수행하는 것을 의미
- `응집도는 높을수록` 좋고 `결합도는 낮을수록` 이상적

### 3.3.2 응집도 유형: `우논시절 통순기`⭐

우리가 논 시절 통순기가 짱이다

응집도 : 우연적 응집도 가장 ↓, 기능적 응집도 가장 ↑

|                  구분                  | 설명                                                                                              |
| :------------------------------------: | ------------------------------------------------------------------------------------------------- |
| 우연적 응집도 (Coincidental Cohesion)  | 모듈 내부의 <u>각 구성 요소들이 연관이 없을 경우</u>                                              |
|    논리적 응집도 (Logical Cohesion)    | <u>유사한 성격을 갖거나 특정 형태로 분류되</u>는 처리 요소들이 <u>한 모듈에서 처리</u>되는 경우   |
|   시간적 응집도 (Temporal Cohesion)    | 연관된 기능이라기보다는 <u>특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리</u>할 경우       |
|  절차적 응집도 (Procedural Cohesion)   | 모듈이 다수의 관련 기능을 가질 때 <u>모듈 안의 구성 요소들이 그 기능을 순차적</u>으로 수행할 경우 |
| 통신적 응집도 (Communication Cohesion) | <u>동일한 입력과 출력</u>을 사용하여 다른 기능을 수행하는 활동들이 모여 있을경우                  |
|  순차적 응집도 (Sequential Cohesion)   | 모듈 내에서 한 활동으로부터 나온 <u>출력값을 다른 활동이 사용</u>할 경우                          |
|  기능적 응집도 (Functional Cohesion)   | 모듈 내부의 모든 기능이 <u>단일한 목적을 위해 수행</u>되는 경우                                   |

---

## 3.4 팬인(Fan-in), 팬아웃(Fan-out)

### 3.4.1 팬인(Fan-in), 팬아웃(Fan-out)의 개념

- 소프트웨어의 구성요소인 모듈을 계층적으로 분석하기 위해 활용
- 팬인과 팬아웃 분석을 통해 시스템의 복잡도를 측정
- 시스템 복잡도를 최적화하기 위해서는 `팬인은 높게, 팬 아웃은 낮게 설계`
  - 조직에서 어디 나갈 떄, 부하들도 같이 데리고 가면 힘드니 낮게

|       구분       | 설명                                                                                           |
| :--------------: | ---------------------------------------------------------------------------------------------- |
|  팬인 (Fan-in)   | - 얼마나 많은 모듈들이 현재 모듈을 호출하는지를 나타낸다.- 해당 `모듈로 들어오는 상위 모듈 수` |
| 팬아웃 (Fan-out) | 해당 `모듈에서 호출하는 하위 모듈 수`                                                          |

### 3.4.2 팬인/팬아웃 계산법⭐

![info-processing_5_3](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_5_3.png)

| 모듈 | 팬인 (Fan-in) | 팬아웃 (Fan-out) |
| :--: | :-----------: | :--------------: |
|  A   |       0       |        3         |
|  B   |       1       |        2         |
|  C   |       1       |        2         |
|  D   |       1       |        1         |
|  E   |       1       |        1         |
|  F   |       1       |        0         |
|  G   |       1       |        1         |
|  H   |       2       |        0         |
|  I   |       2       |        0         |
|  J   |       1       |        1         |

---

## 3.5 공통 모듈 구현

### 3.5.1 공통 모듈 구현 순서

![info-processing_5_4](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_5_4.png)

### 3.5.2 공통 모듈 구현요소

|         구현 요소          | 설명                                                                                                                      |
| :------------------------: | ------------------------------------------------------------------------------------------------------------------------- |
| DTO (Data Transfer Object) | \- 프로세스 사이에서 <u>데이터를 전송하는 객체</u><br />- Getter, Setter 메서드만 포함한다                                |
|     VO (Value Object)      | \- 도메인에서 속성들을 묶어서 <u>특정 값을 나타내는 객체</u><br />- DTO와 동일한 개념이나 차이점은 ReadOnly 속성 객체이다 |
|  DAO (Data Access Object)  | \- 실질적으로 <u>DB에 접근하는 객체</u><br />- DataBase에 접근하기 위한 로직 & 비지니스 로직을 분리하기 위해 사용         |
|          Service           | <u>DAO 클래스를 호출하는 객체</u>                                                                                         |
|         Controller         | <u>비즈니스 로직을 수행하는 객체</u>                                                                                      |

### 3.5.3 공통 모듈 구현

#### (1) DTO/VO 구현

```java
package com.njob.vo; // package ⭐
public class CodeVo{
    private String code;
    private String name;

  	// getter, setter는 값을 전달, 저장할 수 있게하는 함수
    public String getCode(){
        return this.code;
    }
    public void setCode(String code){
        this.code = code;
    }
    public String getName(){
        return this.name;
    }
    public void setCode(String name){
        this.name = name;
    }
}
```

#### (2) SQL 문 구현

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN"
"http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"> <!-- mybatis 문 -->
<mapper namespace="com.njob.sql">
    <select id="getCodeList" resultType="com.njob.vo.CodeVo">
        SELECT
            code, name
        FROM tb_code
    </select>
    <update id="updateCodeInfo" parameterType="com.njob.vo.CodeVo">
        UPDATE tb_code
			 SET
            name = #{name, jdbcType=CHAR}
        WHERE code = #{code, jdbcType=INTEGER}
    </update>
</mapper>
```

#### (3) DAO 구현

```java
package com.njob.dao;
import com.njob.vo.CodeVO; // package, import ⭐

@Repository("codeDao")
public class CodeDao{
    @Autowired
    private SqlSession sqlSession;

    public List<CodeVO> getCodeList() throws Exception {
        return sqlSession.selectList("com.njob.sql.getCodeList");
    }
    public int updateCodeIsUse(CodeVo code) {
        return sqlSession.update("com.njob.sql.updateCodeInfo", code);
    }
}
```

#### (4) Service 구현

```java
package com.njob.service;
import com.njob.vo.CodeVO;
import com.njob.dao.CodeDao;

@Service("codeService")
public class CodeService{
    @Resource(name="codeDao")
    private CodeDao codeDao;

    public List<CodeVO> getCodeList() throws Exception {
        return codeDao.getCodeList();
    }
    public int updateCodeIsUse(CodeDao codeDao) throws Exception {
        return codeDao.updateCodeIsUse(codeDao);
    }
}
```

#### (5) Controller 구현

```java
package com.njob.controller;
import com.njob.vo.CodeVO;
import com.njob.dao.CodeDao;
import com.njob.service.CodeService;

@Controller
public class CodeController{
    @Autowired
    private CodeService codeService
    @RequestMapping(value = "/code/list")
    public ResponseEntity<List<CodeVO>> list(){
        try{
            List<CodeVO> list = codeService.getCodeList();

            if( list != null ){
                return new ResponseEntity<List<CodeVO>>(list, HttpStatus.OK);
            }
            else{
                return new ResponseEntity<List<CodeVO>>(list, HttpStatus.NO_CONTENT);
            }
        }
        catch(Exception e){
            logger.error(e.getMessage());
        }
    }
}
```

### 3.5.4 Annotation

#### (1) Annotation 개념⭐

- `사전적으로는 "주석"이라는 의미`를 가지고 있다.
- 자바코드에 주석처럼 달아 특수한 의미를 부여한다.
- 컴파일 또는 런타임에 해석된다.

#### (2) Annotation 종류

|      종류       | 설명                                                                 |
| :-------------: | -------------------------------------------------------------------- |
|   @Controller   | 스프링 MVC의 컨트롤러                                                |
| @RequestMapping | 특정 URI 에 매칭되는 클래스나 메소드임을 명시                        |
|  @RequestParam  | 요청(request)에서 특정한 파라미터 값을 찾아낼 때 사용하는 어노테이션 |
| @RequestHeader  | 요청(request)에서 특정 HTTP 헤더 정보를 추출할 때 사용               |
|  @PathVariable  | 현재 URI에서 원하는 정보를 추출할 때 사용                            |
|  @CookieValue   | 현재 사용자의 쿠키값을 추출할 때 사용                                |
| @ModelAttribute | 자동으로 해당 객체를 뷰까지 전달하도록 한다.                         |
|  @ResponseBody  | 리턴 타입이 HTTP의 응답 메시지로 전송                                |
|  @RequestBody   | 요청 문자열이 그대로 파라미터로 전달                                 |
|   @Repository   | DAO 객체                                                             |
|    @Service     | 서비스 객체                                                          |
|   @Scheduled    | 스프링에서 지원하는 배치 어노테이션                                  |

---

# 4. 서버 프로그램 구현

## 4.1 서버 프로그램 구현

### 4.1.1 업무 프로세스 확인

#### (1) 업무 프로세스의 개념

개인이나 조직이 한 개 이상의 자원 입력을 통해 가치 있는 산출물을 제공하는 활동

![info-processing_5_5](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_5_5.png)

#### (2) 업무 프로세스 구성 요소

|      구성 요소       | 설명                                                                                                                                                        |
| :------------------: | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   프로세스 책임자    | \- 프로세스의 성과와 운영을 책임지는 구성원<br />- 프로세스를 설계하고 지속적으로 유지한다.                                                                 |
|     프로세스 맵      | \- 상위 프로세스와 하위 프로세스의 체계를 도식화하여 업무의 청사진 표현<br />- <u>구조적 분석 기법 : 자료 흐름도</u><br />- <u>객체지향 분석 기법 : ERD</u> |
| 프로세스 Task 정의서 | 결과물을 산출하기 위해 Task 들의 운영방법을 문서화한다.                                                                                                     |
|  프로세스 성과 지표  | 프로세스의 과정과 결과를 고객 입장에서 정량적으로 표현한 성과 지표                                                                                          |
|    프로세스 조직     | 프로세스를 성공적으로 수행하기 위해 개인들의 업무를 유기적으로 수행하는 구성원                                                                              |
|   경영자의 리더십    | \- 경영자는 프로세스의 중요성을 인식한다.<br />- 기업의 경영 방침을 확고하게 한다.                                                                          |

---

### 4.1.2 서버 프로그램 구현

- 업무 프로세스(BusinessLogic)를 기반으로 개발언어, 도구를 이용하여 <u>서버에서</u> 서비스를 제공하는데 필요한 <u>기능을 구현</u>하는 활동
- 서버 프로그램 구현 절차

![info-processing_5_6](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_5_6.png)

|         구현 요소          | 설명                                                                                                                       |
| :------------------------: | -------------------------------------------------------------------------------------------------------------------------- |
| DTO (Data Transfer Object) | - 프로세스 사이에서 <u>데이터를 전송</u>하는 객체<br />- Getter, Setter 메서드만 포함한다.                                 |
|     VO (Value Object)      | - 도메인에서 속성들을 묶어서 <u>특정 값을 나타내는 객체</u><br />- DTO와 동일한 개념이나 차이점은 Read­Only 속성 객체이다. |
|  DAO (Data Access Object)  | - 실질적으로 <u>DB에 접근하는 객체</u><br />- DataBase에 접근하기 위한 로직 & 비지니스 로직을 분리하기 위해 사용           |
|          Service           | <u>DAO 클래스를 호출</u>하는 객체                                                                                          |
|         Controller         | <u>비즈니스 로직을 수행</u>하는 객체                                                                                       |

---

### 4.1.3 MVC 모델의 계층

#### (1) 프리젠테이션 계층(Presentation Layer)

- 사용자 인터페이스
- 사용자가 선택할 수 있는 기능 및 부가정보를 전달할 양식을 표현한다.
- JSP 와 JSTL 태그 라이브러리를 결합하는 방식(JAVA의 경우)

#### (2) 제어 계층(Control Layer)

- 프리젠테이션 계층과 비즈니스 로직 계층을 분리하기 위한 `컨트롤러를 제공`
- 어떤 요청이 들어왔을 때 어떤 로직이 처리해야 하는지를 결정한다.
- 사용자 요청을 검증하고 로직에 요청을 전달하는 일과 로직에서 전달된 응답을 적절한 뷰에 연결짓는 역할

#### (3) 비즈니스 로직 계층(Business Logic Layer)

- 핵심 업무를 어떻게 처리하는지에 대한 방법을 구현 하는 계층
- 핵심 업무 로직의 구현과 그에 관련된 데이터의 적합성 검증, 트랜잭션 처리 등을 담당한다

#### (4) 퍼시스턴스 계층(Persistence Layer)

- 데이터 처리를 담당하는 계층
- 데이터의 생성/수정/삭제/선택(검색)과 같은 CRUD 연산을 수행한다.

#### (5) 도메인 모델 계층(Domain Model Layer)

- 각 계층 사이에 전달되는 실질적인 비즈니스 객체
- 데이터 전송 객체(DTO) 형태로 개발자가 직접 제작해서 데이터를 넘기게 된다.

---

## 4.2 DBMS 접속기술

### 4.2.1 DBMS 접속기술의 개념

- 프로그램에서 DB에 접근하여 DML을 사용 가능하게 하는 기술
- 프로그램이 DB를 사용할 수 있도록 연결해주는 인터페이스

### 4.2.2 DBMS 접속기술 종류

- `소켓통신`
  - 응용프로그램과 DBMS가 주고 받는 통신
  - DBMS 사에서 <u>프로토콜을 공개하지 않기 때문에 개발은 어렵다.</u>
- `Vender API`
  - <u>DBMS 사에서 공개한 API를 이용해 DBMS와 통신</u>
  - DBMS 사마다 API 사용법이 상이하다.
- `JDBC(Java DataBase Connectivity)`
  - <u>Java 에서 DB에 접속하고 SQL문을 수행할 때 사용</u>되는 표준 API
  - JDBC는 Java SE(Standard Edition)에 포함되어 있다.
  - java.sql 패키지와 javax.sql 패키지에 포함되어 있다.
  - 접속하려는 DBMS에 맞는 드라이버가 필요함
- `ODBC(Open DataBase Connectivity)`
  - <u>데이터베이스에 접근하기 위한 표준 규격</u>{' '}
  - 개발언어에 관계없이 사용할 수 있다.
  - 모든 DBMS에 접근하는 방법을 통일시킴
  - <u>1990년대 초 MS 사에서 개발</u>됨

---

## 4.3 ORM(Object-Relational Mapping) 프레임워크

### 4.3.1 ORM 프레임워크의 개념⭐

- `객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것`
- 객체지향 프로그램에서 클래스(VO)를 생성하고, 관계형 데이터베이스의 테이블의 내용을 매핑(DAO)
- 객체지향 프로그램을 통해 데이터베이스의 데이터를 다룬다.

### 4.3.2 ORM 장/단점

- 장점
  - 비즈니스 로직에 더 집중할 수 있다.
  - 재사용 및 유지보수의 편리성이 증가한다.
  - DBMS에 대한 종속성이 줄어든다.
- 단점
  - 완벽한 ORM 으로만 서비스를 구현하기 어렵다.
  - 프로시저가 많은 시스템에선 ORM의 객체지향 장점을 활용하기 어렵다

### 4.3.3 매핑 기술 비교⭐

- `SQL Mapper`
  - `SQL을 명시`하여 단순히 `필드를 매핑 시키는 것이 목적`
  - SQL 문장으로 직접 데이터베이스 데이터를 다룬다.
  - SQL 의존적인 방법
  - 종류 : <u>iBatis, Mybatis,</u> jdbc Templetes 등
- `OR Mapping (=ORM)`
  - 객체를 통해 간접적으로 데이터베이스를 다룬다.
  - 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑
  - ORM을 이용하면 `SQL Query 가 아닌 직관적인 코드로 데이터를 조작`할 수 있다.
  - 종류 : JPA(Java Persistent API), Hibernate

---

## 4.4 시큐어 코딩 (Secure Coding)

### 4.4.1 OWASP(The Open Web Application Security Project)⭐

- 오픈소스 웹 애플리케이션 보안 프로젝트
- 주로 `웹에 관한` 정보 노출, 악성 파일 및 스크립트 보안 취약점 등을 연구하며 `10대 취약점을 발표`했다.
- OWASP Top 10 : 웹 애플리케이션 취약점 중 빈도가 많이 발생하고, 보안상 영향을 줄 수 있는 `10가지를 선정`하여 발표

### 4.4.2 시큐어 코딩 가이드 개념

- 해킹 등 사이버 공격의 원인인 `보안취약점을 제거`해 안전한 소프트웨어를 개발하는 SW 개발 기법
- 개발자의 실수나 논리적 오류로 인해 발생할 수 있는 문제점을 사전에 차단하여 대응하고자 하는 것

### 4.4.3 시큐어 코딩 가이드

#### (1) 입력 데이터 검증 및 표현⭐

- 프로그램 입력값에 대한 검증 누락 또는 부적절한 검증, 데이터형식을 잘못 지정하여 발생하는 보안 약점
- 보안 약점 종류

|              종류              | 설명                                                                            |
| :----------------------------: | ------------------------------------------------------------------------------- |
|        SQL Injection⭐         | `SQL문을 삽입`하여 DB로부터 정보를 열람 및 조작할 수 있는 공격                  |
| XSS (크로스 사이트 스크립트)⭐ | `악의적인 스크립트를 포함`해 사용자 측에서 실행되게 유도하는 공격               |
|           자원 삽입            | 외부 입력값이 시스템 자원 접근 경로 또는 자원 제어에 사용되는 공격              |
|    위험한 형식 파일 업로드     | 서버측에서 실행될 수 있는 스크립트파일을 업로드 하여 공격                       |
|           명령 삽입            | 운영체제 명령어 삽입, XQuery 삽입, XPath 삽입, LDAP 삽입                        |
|      메모리 버퍼 오버프로      | 입력받는 값이 버퍼를 가득 채우다 못해 넘쳐흘러 버퍼 이후의 공간을 침범하는 공격 |

#### (2) 보안 기능

- 보안 기능을 부적절하게 구현하는 경우 발생할 수 있는 보안 약 점
- 보안 약점 종류

|             종류              | 설명                                                                                                 |
| :---------------------------: | ---------------------------------------------------------------------------------------------------- |
| 적절한 인증 없이 중요기능허용 | 적절한 인증과정이 없이 중요정보(계좌, 개인정보 등)를 열람 할 때 발생하는 보안약점                    |
|         부적절한 인가         | 적절한 접근 제어 없이 외부 입력값을 포함한 문자열로 중요 자원에 접근할 수 있는보안약점               |
|  취약한 암호화 알고리즘 사용  | DES, MD5 등 안전하지 않은 알고리즘 사용                                                              |
|      하드코딩된 패스워드      | 소스 코드 내에 비밀번호가 하드코딩되어 있어 소스코드 유출시 노출되는 보안 약점                       |
|      패스워드 평문 저장       | 계정 정보 탈취 시 패스워드 노출                                                                      |
|     취약한 패스워드 허용      | 비밀번호 조합규칙(영문, 숫자, 특수문자 등)이 미흡하거나 길이가 충분하지 않아노출될 수 있는 보안 약점 |

#### (3) 시간 및 상태

- 동시 수행을 지원하는 병렬 시스템이나 하나 이상의 프로세스가 동작하는 환경에서 시간 및 상태를 부적절하게 관리하여
  발생할 수 있는 보안 약점
- 보안 약점 종류

|                종류                 | 설명                                                                            |
| :---------------------------------: | ------------------------------------------------------------------------------- |
|              경쟁 조건              | 동일 자원에 대한 검사 시점과 사용 시점이 상이하여 동기화 오류, 교착 상태를 유발 |
| 종료되지 않는 반복문 또는 재귀 함수 | 종료 조건이 없어 무한 루프에 빠져 자원 고갈을 유발                              |

#### (4) 에러 처리

- 에러를 처리하지 않거나 불충분하게 처리하여 에러 정보에 중요 정보가 포함될 때 발생할 수 있는 보안약점
- 보안 약점 종류

|         종류          | 설명                                                                                                                    |
| :-------------------: | ----------------------------------------------------------------------------------------------------------------------- |
| 오류 메시지 정보 노출 | \- 응용 프로그램의 민감 정보가 오류 메시지를 통해 노출됨- 오류 메시지는 사용자가 필요한 최소한의 정보만을 노출해야 한다 |
|  오류 상황 대응 부재  | 예외처리 미구현                                                                                                         |
|  부적절한 예외 처리   | 프로그램 수행 중 발생한 예외 조건을 적절히 검사하지 않음                                                                |

#### (5) 코드 오류

- 개발자가 범할 수 있는 코딩 오류로 인해 유발되는 보안 약점
- 보안 약점 종류

|           종류            | 설명                                                  |
| :-----------------------: | ----------------------------------------------------- |
|     널 포인터 역참조      | 널 값을 고려하지 않은 코드에서 발생                   |
|    부적절한 자원 해제     | 자원을 할당받아 사용한 뒤 반환하기 않는 코드에서 발생 |
|     해제된 자원 사용      | 해제한 메모리를 참조하는 코드에서 발생                |
| 초기화되지 않은 변수 사용 | 지역변수를 초기화하지 않고 사용하는 코드에서 발생     |

#### (6) 캡슐화

- 중요한 데이터 또는 기능성을 불충분하게 캡슐화하거나 잘못 사용해 발생하는 보안 약점
- 보안 약점 종류

|             종류             | 설명                                                                |
| :--------------------------: | ------------------------------------------------------------------- |
| 잘못된 세션에 의한 정보 노출 | 멀티 스레드 환경에서 서로 다른 세션 간 데이터가 공유될 수 있음      |
|  제거되지 않은 디버그 코드   | 배포 단계에 디버그 코드가 남아 있는 경우 민감 정보가 노출될 수 있음 |
|       시스템 정보 노출       | 시스템 내부 데이터가 노출될 수 있음                                 |
|      잘못된 접근 지정자      | private, public 잘못된 접근지정자 사용으로 민감 정보 노출될 수 있음 |

#### (7) API 오용

- 의도된 사용에 반하는 방법으로 API를 사용하거나 보안에 취약한 API를 사용하여 발생할 수 있는 보안 약점
- 보안 약점 종류

|          종류          | 설명                                                 |
| :--------------------: | ---------------------------------------------------- |
| DNS에 의존한 보안 결정 | 공격자가 DNS 정보를 변조하여 보안 결정을 우회 가능함 |
|    취약한 API 사용     | 금지되거나 안전하지 않은 함수를 사용함               |

---

# 5. 배치 프로그램 구현

## 5.1 배치 프로그램

### 5.1.1 배치의 개념

- `데이터를 일괄적으로 모아서 처리하는 대량의 작업을 처리`
- 컴퓨터 흐름에 따라 <u>순차적으로 자료를 처리</u>하는 방식
- 배치 프로그램이란, `대량의 데이터를 모아 정기적으로 반복 처리하는 프로그램`이다

### 5.1.2 배치 프로그램의 필수 요소⭐

- `대용량 데이터`: 대용량의 데이터를 처리할 수 있어야 한다.
- `자동화`: 심각한 오류 상황 외에는 사용자의 개입없이 동작해야 한다.
- `견고함`: 비정상적인 동작 중단이 발생하지 않아야 한다.
- `안정성`: 어떤 문제가 발생했을 때, 해당 문제를 추적하고 복구할 수 있어야 한다.
- `성능`: 주어진 시간에 작업을 완료해야 하고, 다른 어플리케이션의 동작을 방해하지 않아야 한다.

### 5.1.3 스케줄 관리 종류

#### (1) 크론탭 (crontab)

- UNIX, LINUX 계열에서 사용
- 크론탭 형식 : `분 시 일 월 요일 명령어`⭐
- 항목의 범위

|   필드    |  의미  |            범위            |
| :-------: | :----: | :------------------------: |
|  첫 번쨰  |   분   |           0 ~ 59           |
|  두 번쨰  |   시   |           0 ~ 23           |
|  세 번쨰  |   일   |           1 ~ 31           |
|  네 번쨰  |   월   |           1 ~ 12           |
| 다섯 번쨰 |  요일  | 0 ~ 6 (0:일요일, 1:월요일) |
| 여섯 번쨰 | 명령어 |        실행할 명령         |

- 허용 특수문자

| 특수문자 | 설명                                                   |
| :------: | ------------------------------------------------------ |
|    \*    | 모든 값 (매시, 매일, 매주)                             |
|    ?     | 특정 값이 아닌 어떤 값이든 상관 없음                   |
|    -     | 범위를 지정할 때 (12-14 : 12시부터 14시)               |
|    ,     | 여러 값을 지정할 때 (12, 14 : 12시, 14시)              |
|    /     | 증분값, 즉 초기값과 증가치 설정 (\*/20 : 매 20분 마다) |

- 설정 예⭐

|           형식           | 설명                                      |
| :----------------------: | ----------------------------------------- |
|   \* \* \* \* \* 명령    | 매분 실행                                 |
|    30 4 \* \* 0 명령     | 매주 일요일 4시 30분 실행                 |
|  10-30 4 \* \* \* 명령   | 매일 오전 4시 10분부터 30분까지 매분 실행 |
| 0,10,20 \* \* \* \* 명령 | 매일 매시간 0분, 10분, 20분 실행          |
|   _/30 _ \* \* \* 명령   | 매 30분 마다 실행                         |
|    30 0 1 1,6 \* 명령    | 1월과 6월, 1일, 0시 30분에 실행           |

#### (2) Spring Batch

- 백엔드의 배치처리 기능을 구현하는데 사용하는 프레임워크
- 대용량 및 고성능 배치 작업을 가능하게 하는 고급 기술 서비스 및 기능을 제공
- 배치가 실패하여 작업 재시작을 하게 된다면 처음부터가 아닌 실패한 지점부터 실행
- Batch Job을 관리하지만 Job을 구동하거나 실행시키는 기능은 지원하진 않는다.
- Batch Job을 실행시키기 위해서는 Quartz, Scheduler, Jenkins등 전용 Scheduler를 사용
- 구성요소 : Job, Job Launcher, Step, Job Repository

#### (3) Quartz Job Scheduler

- 표준 자바 프로그램으로 만들어진 작업을 지정된 일정에 따라 실행시키는데 사용하는 Java 패키지
- 특정한 시간에 특정한 작업을 한다든지 또는 주기적으로 실행해야 할 Java 애플리케이션을 사전에 정해 놓으면 일정에 따라 실행
- 주요 인터페이스 : Scheduler, Job, JobDetail, Trigger, JobBuilder, TriggerBuilder
- 형식 : `초 분 시 일 월 요일 년(생략가능)`⭐

### 5.1.4 배치 스케줄러 클래스 작성

1. 배치 설계서 확인
2. DTO/VO 구현
3. SQL 문 구현
4. DAO 구현
5. Schedule 구현 (매일 1시에 배치 실행)

```java
@Scheduled(cron=“0 0 1 * * ? ”)
public void scheduleExecute(){
    String result = “SUCC”;
    try{
        /* 수행해야 할 업무를 코딩한다 */
    }
    catch(Exception){
        result = “FAIL”;
    }
    logger.info(“스케줄 실행 결과 : ” + result );
}
```
