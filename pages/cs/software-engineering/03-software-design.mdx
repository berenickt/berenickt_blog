---
title: '03-소프트웨어 설계'
date: 2023/12/14
---

# 1. 소프트웨어 설계의 기본 원칙

## 1.1 소프트웨어 설계

### 1.1.1 소프트웨어 설계의 개념

- <u>요구사항 명세서를 참조</u>하여 소프트웨어의 구체적인 <u>설계서를 작성</u>
  하는 단계
- 물리적으로 구현이 가능하도록 시스템을 구체적으로 정의하는 단계

### 1.1.2 소프트웨어 설계의 종류

![info-processing_3_1](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_1.png)

- `상위설계` : 분석, 설계
  - `아키텍처 설계` : 시스템의 전체적인 구조 설계
  - `데이터 설계`
    - 시스템에 필요한 정보를 설계
    - 데이터 베이스 설계
  - `인터페이스 정의` : 시스템의 구조와 서브 시스템들 사이의 인터페이스를 명확히 정의
  - `사용자 인터페이스 설계` : 사용자가 익숙하고 편리하게 사용하도록 인터페이스 설계
- `하위설계` : 구현, TEST
  - `모듈 설계` : 각 모듈의 실제적인 내부를 알고리즘 형태로 표현
  - `자료구조 설계` : 자료구조, 변수 등에 대한 상세한 정보를 설계
  - `알고리즘 설계` : 업무의 처리 절차 등을 설계

### 1.1.3 소프트웨어 설계의 원리⭐

- `분할과 정복(Divide & Conquer)`
  - 규모가 큰 소프트웨어를 여러 개의 작은 서브 시스템으로 나누어 하나씩 완성시킨다.
- `추상화(Abstraction)`

  - 특정한 목적과 관련된 <u>필수 정보만 추출</u>하여 강조하고, 관련이 없는 세부 사항을 생략함으로써, 본질적인문제에 집중할 수 있도록 한다.
  - 자세한 <u>구현 전에</u>, 상위 레벨에서 제품의 구현을 먼저 생각해보는 것
  - 추상화 기법 : `과제데`⭐
    - `과정 추상화`: 자세한 단계를 고려하지 않고 <u>상위 수준에서 수행 흐름만 먼저 설계</u>
    - `제어 추상화`: 여러 <u>명령들을 간단한 표현</u>으로 대체하는 것이다.
    - `데이터 추상화`: <u>데이터 구조</u>를 대표할 수 있는 표현으로 대체하는 것이다.

- `단계적 분해(Gradual Decomposition)`: 기능을 점점 작은 단위로 나누어 점차적으로 구체화 하는 방법
- `모듈화(Modulization)`: 실제로 개발할 수 있는 작은 단위로 나눈다.
- `정보은닉(Information Hiding)`
  - 다른 객체에게 자신의 정보를 숨기고, <u>자신의 연산만을 통해 접근이 가능</u>하도록 한다.
  - 클래스 외부에서 특정 정보에 대한 접근을 막는다는 의미
  - <u>캡슐화와 밀접한 관계</u>가 있다

---

## 1.2 설계 모델링

### 1.2.1 설계 모델링 개념

- 소프트웨어를 구성하는 모듈들을 식별하고, 이것들의 연결을 <u>그림으로 표현한 것</u>
- 소프트웨어를 만들기 위한 계획 또는 만들어야 할 물건을 의미있게 표현한 것
- 소프트웨어에 대하여 여러 엔지니어들이 공통된 개념을 공유하는데 도움을 준다.

### 1.2.2 설계 모델링 원칙

- 소프트웨어 설계는 <u>변경이 용이하도록</u> 구조화되어야 한다.
- 한 함수 안에 특정 기능을 수행하는 데 <u>필요한 자료만을 사용</u>하도록 한다.
- 요구사항 분석에서 얻은 정보를 이용하여 반복적 방법을 통해 이루어져야 한다.
- 독립적이고 기능적인 특성들을 지닌 <u>모듈 단위로 설계</u>되어야 한다.

### 1.2.3 설계 모델링 유형

- `구조 모델링`
  - 소프트웨어를 구성하는 컴포넌트들의 유형, 인터페이스, 내부 설계 구조 및 이들의 <u>연결 구조를 모델링</u>
  - 시스템의 구성 요소들과 이들 사이의 구조적인 관계와 특성들의 모델링
  - <u>UML 정적 다이어그램</u>
- `행위 모델링`
  - 소프트웨어의 구성요소들의 기능들이 언제, 어떠한 순서로 <u>기능을 수행해야 작용하는지를 모델링</u>
  - 시스템의 구성 요소들이 언제 어떠한 순서로 수행되는가와 같은 동적 특성들의 모델링
  - <u>UML 동적 다이어그램</u>

### 1.2.4 소프트웨어 설계 절차 및 유형⭐

![info-processing_3_2](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_2.png)

- `아키텍처 설계` : 시스템을 구성하는 서브시스템들과 그들 간의 관계를 파악하고 명세한다.
- `데이터베이스 설계` : 시스템 구현에 사용되는 데이터의 구조를 자세하게 설계하고 명세한다.
- `서브시스템 설계` : 각 서브시스템이 담당하는 서비스와 제약사항들에 대해 명세한다.
- `컴포넌트 설계` : 서브시스템이 수행하는 기능을 여러 컴포넌트에 할당하고, 컴포넌트들의 인터페이스를설계하고 명세한다.
- `자료구조와 알고리즘 설계` : 컴퓨터에 자료를 효율적으로 저장하는 방식과, 자료구조 내에서 기본적인 연산방법을 설계하고 명세
- `협약에 의한 설계`⭐
  - 클래스에 대한 여러 가정을 공유하도록 명세
  - `선행 조건` : 컴포넌트 <u>오퍼레이션 사용 전에 참</u>이 되어야할 조건
  - `결과 조건` : <u>사용 후 만족되어야 할 결과조건</u>
  - `불변 조건` : <u>오퍼레이션이 실행되는 동안 항상 만족</u>되어야할 조건

---

# 2. 소프트웨어 아키텍처

## 2.1 소프트웨어 아키텍처

### 2.1.1 소프트웨어 아키텍처(SoftWare Architecture) 개념

- 소프트웨어의 골격이 되는 <u>기본구조</u>
- 시스템의 컴포넌트 사이의 관계를 정의한 구조

### 2.1.2 소프트웨어 아키텍처의 특징

- `간략성`: 이해하고 추론할 수 있을 정도의 간결성 유지
- `추상화`: 시스템의 추상적인 표현을 사용
- `가시성`: 시스템이 포함해야 하는 것들을 가시화
- `관점 모형`: 이해당사자의 관심사에 따른 모형 제시
- `의사소통 수단`: 이해당사자 간 원활한 의사소통 수단으로 이용

### 2.1.3 소프트웨어 아키텍처 프레임워크 구성요소

- `아키텍처 명세서(Architecture Description)`: 아키텍처를 기록하기 위한 산출물
- `이해관계자(Stakeholder)` :소프트웨어 시스템 개발에 관련된 모든 사람과 조직 - 고객, 개발자, 프로젝트 관리자 등 포함
- `관심사(Concerns)`
  - 동일한 시스템에 대해 서로 다른 이해관계자 의견
  - e.g.) 사용자 : 기본적인 기능, 신뢰성, 보안등의 요구
- `관점(Viewpoint)` : 서로 다른 역할이나 책임으로 시스템이나 산출물에 대한 서로 다른 관점
- `뷰(View)` : 이해 관계자들과 이들이 가지는 생각이나 견해로부터 전체 시스템을 표현

### 2.1.4 소프트웨어 아키텍처 4+1 뷰

#### (1) 4+1 뷰 개념

- 고객의 <u>요구사항을 정리해 놓은 시나리오를 4개의 관점</u>에서 바라보는 소프트웨어적인 접근 방법
- 복잡한 소프트웨어 아키텍처를 다양한 이해관계자들이 바라보는 관점
- <u>View</u>는 시스템의 여러 가지 측면을 고려하기 위한 <u>다양한 관점을 바탕으로 정의</u>

#### (2) 4+1 View Model 과 구성요소 : `유논프구배`⭐

![info-processing_3_3](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_3.png)

- `유스케이스 뷰 (use case view)`
  - <u>아키텍처를 도출하고 설계하는 작업을 주도</u>하는 뷰
  - <u>다른 뷰를 검증</u>하는데 사용
  - Use Case Diagram이 사용
  - <u>+1 에 해당</u>하며 유스케이스가 <u>나머지 4개 뷰에 모두 참여하면서 영향을 준다.</u>
- `논리 뷰 (logical view)`
  - <u>시스템의 기능적인 요구사항</u>
  - 시스템이 최종 사용자를 위해 해야 하는 것을 나타낸다.
- `프로세스 뷰 (process view)`
  - <u>프로그램 실행시의 시스템 표현</u>
  - Thread와 Process에 의한 동작을 중점적으로 표현
  - 동시성, 분산처리, 시스템 통합, 오류 허용 등을 표현
- `구현 뷰 (implementation view)`
  - <u>개발 환경 안에서 정적인 소프트웨어 모듈의 구성</u>
  - 개발자 관점에서 소프트웨어 구현과 관리적인 측면을 컴포넌트 다이어그램으로 표현
- `배치 뷰 (deployment view)`
  - 다양한 실행 파일과 다른 런타임 <u>컴포넌트가 해당 플랫폼 또는 컴퓨팅 노드에 어떻게 매핑 되는가를 표</u>현
  - 가용성, 신뢰성, 성능, 확장성 등의 시스템의 비기능적인 요구사항 고려
  - 물리적인 노드의 구성과 상호 연결 관계를 배포 다이어그램으로 표현

### 2.1.5 소프트웨어 아키텍처 품질속성⭐

|              속성              | 설명                                                             |
| :----------------------------: | ---------------------------------------------------------------- |
|      정확성 (Correctness)      | 소프트웨어가 사용자의 요구기능을 `충족`시키는가?                 |
|      신뢰성 (Reliability)      | 기능이 오차나 `오류 없이` 동작하는가?                            |
|      효율성 (Efficiency)       | 기능을 수행하는데 `적절한 자원(CPU, 메모리)`이 소요되는가?       |
|       무결성 (Integrity)       | `허용되지 않는 사용이나 자료 변경을 제어`하는가?                 |
|    사용 용이성 (Usability)     | `쉽게 배우고 사용`할 수 있는가?                                  |
|  유지보수성 (Maintainability)  | 변경 및 오류 교정 시 `쉽게 수정`할 수 있는가?                    |
|   시험 용이성 (Testability)    | 개선, 유지보수 등에 있어서 `테스트를 하기 용이`하게 되어 있는가? |
|      유연성 (Flexibility)      | 새로운 요구사항에 대해서도 쉽게 `개선 및 적용` 가능한가?         |
|      이식성 (Potability)       | 다양한 플랫폼 및 하드웨어에서 `동작`하는가?                      |
|     재사용성 (Reusability)     | 개발된 기능을 `다른 목적으로 사용하기 용이`한가?                 |
| 상호 운용성 (Interoperability) | 다른 소프트웨어와 `상호 교류가 용이`한가?                        |

### 2.1.6 소프트웨어 아키텍처 평가

- 소프트웨어 아키텍처 평가 개념
  - 아키텍처의 접근법이 품질속성(보안, 성능, UI 등)에 미치는 영향을 판단하여 아키텍처 적합성을 판단하고평가하는 표준 기법
- 소프트웨어 아키텍처 <u>평가기법 유형</u> : 비가시적 평가(`SACCA, 사카`)

|  관점  |     유형      | 내용                                                             |
| :----: | :-----------: | ---------------------------------------------------------------- |
| 가시성 |  가시적 평가  | `Inspection`, Review, Validation & Verification                  |
|        | 비가시적 평가 | SAAM, `ATAM(품질), CBAM(비용)`, ARID, ADR                        |
|  시점  |   이른 평가   | 아키텍처 구축과정 중 어느 때나 평가 가능                         |
|        |   늦은 평가   | 기존 시스템의 요구사항에 대한 아키텍처의 적합성을 판단할 때 사용 |

---

## 2.2 소프트웨어 아키텍처 패턴

### 2.2.1 소프트웨어 아키텍처 패턴의 개념⭐

- 주어진 문맥 안에서 소프트웨어 아키텍처의 공통적인 <u>발생 문제</u>에 대한 <u>일반적인, 재사용 가능한 해결책</u>
- 소프트웨어 공학의 다양한 문제를 해결
  - 컴퓨터 하드웨어 <u>성능</u>
  - 비즈니스 <u>위험의 최소화</u>
  - `고가용성` : 한 서버가 정지했을 떄, 다른 서버를 이용해 시스템을 이용하게 하는 방법⭐
    - 가용성 : 언제든지 시스템을 이용할 수 있어야 한다
- 일부 아키텍처패턴은 소프트웨어 프레임워크 안에 구현되어 있다.

### 2.2.2 소프트웨어 아키텍처 패턴 종류⭐

- `계층화 패턴(Layered pattern)`
  - n-티어 아키텍처 패턴으로 부른다.
  - 하위 모듈을 그룹으로 나눌 수 있는 <u>구조화된 프로그램에서 사용</u>
  - 각 서브 시스템이 하나의 계층이 되고 하위층이 제공하는 서비스를 상위층의 서브 시스템이 이용할 수 있는구조
  - e.g.) OSI 7계층, TCP/IP 4계층
- `클라이언트-서버 패턴(Client-Server Pattern)`
  - <u>다수의 클라이언트와 하나의 서버</u>로 구성
  - 서버는 클라이언트에게 서비스를 제공하며 데이터를 관리하는 역할
  - e.g.) 일반적인 웹 프로그램
- `마스터-슬레이브 패턴(Master-Slave Pattern)`

  - <u>마스터 컴포넌트</u>가 동등한 구조의 슬레이브 컴포넌트로 <u>작업을 분산</u>
    하고, <u>슬레이브</u>가 결과값을 반환하면 <u>최종결과값을 계산</u>하는 구조

    = 마스터는 연산, 슬레이브는 인용만 한다

  - e.g.) 컴퓨터와 주변장치

- `파이프-필터 패턴(Pipe-Filter Pattern)`⭐

  - <u>데이터 스트림을 생성</u>하고 처리하는 시스템에서 사용 가능한 패턴 * 스트림 : 한 방향으로 보낸다 (동영상 스트리밍)
  - 필터 컴포넌트에서 각 처리과정을 실행하며, 처리된 데이터는 파이프를 통해 전송
  - 서브시스템이 입력데이터를 받아 처리하고 결과를 다음 서브시스템으로 넘겨주는 과정을 반복
  - e.g.) Unix 쉘처리

- `브로커 패턴(Broker Pattern)`
  - 분리된 컴포넌트로 구성된 분산 시스템에서 사용되는 패턴
  - 각 컴포넌트들은 원격 서비스를 통해 서로 상호작용을 할 수 있으며 <u>브로커 컴포넌트</u>가 컴포넌트 간의 <u>통신을 조절</u>

![info-processing_3_4](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_4.png)

- `피어 투 피어 패턴(Peer to Peer Pattern)`
  - <u>피어</u>라 부르는 <u>각 컴포넌트 간에 서비스를 주고 받는 패턴</u>
  - 피어 객체 하나가 클라이언트, 서버의 역할을 모두 수행하는 구조
  - e.g.) 파일 공유(P2P), 토렌트
- `이벤트-버스 패턴(Event-Bus Pattern)`
  - <u>이벤트 버스를 통해 특정 채널로 메시지</u>를 발행
  - 리스너가 구독한 채널에 소스가 서비스를 제공하면 채널이 리스너에게 서비스를 제공
  - e.g.) 알림 서비스
- `모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)`⭐
  - MVC Pattern - 3개의 각 컴포넌트는 각자의 역할을 갖고 사용자에게 서비스를 제공
  - 자료의 저장, 제어, 표현 기능을 분리하여 재사용을 증진
  - `모델(Model)` : 도메인의 기능과 `자료를 저장`하고 보관
  - `뷰(View)` : 사용자에게 `결과를 표시`
  - `컨트롤러(Controller)` : 사용자로부터 입력을 받아 연산을 `처리`
  - e.g.) 일반적인 웹 어플리케이션 설계 아키텍처

![info-processing_3_5](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_5.png)

- `블랙보드 패턴(Blackboard Pattern)` : 명확히 정의된 <u>해결 전략이 알려지지 않은 문제</u>에 대해서 유용한 패턴
- `인터프리터 패턴(Interpreter Pattern)` : <u>특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계</u>할 때 사용되는 패턴

---

# 3. UML

## 3.1 UML(Unified Modeling Language)⭐

### 3.1.1 UML 개념⭐

- 프로그램 설계를 표현하기 위해 사용하는 <u>표기법</u>
- 시스템 개발 과정에서 이해관계자 사이에 <u>의사소통을 원활하게</u> 이루어지게 하기 위하여 표준화한 모델링 언어
- 소프트웨어 시스템, 업무 모델링, 시스템의 산출물을 규정하고 시각화, <u>문서화하는 언어</u>
- 프로그램언어가 아닌 <u>기호와 도식을 이용</u>하여 표현하는 방법을 정의한다.

### 3.1.2 UML 특징 : `가구명문`

- `가시화 언어` : 소프트웨어의 개념 모델을 <u>시각적인 그래픽 형태로 작성</u>한다.
- `구축 언어` : 명세화된 설계모델은 다양한 언어의 소스코드로 변환하여 구축할 수 있다.
- `명세화 언어` : 분석, 설계, 구현 단계의 각 과정에서 <u>필요한 모델을 명세화</u> 할 수 있는 언어
- `문서화 언어` : 일련의 과정을 문서로 남겨 계속 유지 보수한다.

---

## 3.2 UML 구성요소 : `사관다`⭐

### 3.2.1 사물(Things)

- `구조 사물` : 시스템의 개념적, 물리적 요소
  - e.g.) 클래스, 유즈케이스, 컴포넌트 등
- `행동 사물` : 시간과 공간에 따른 요소들의 행위
  - e.g.) 상호작용, 상태머신
- `그룹 사물` : 요소들을 그룹으로 묶은 것
  - e.g.) 패키지
- `주해 사물` : 부가적 설명이나 제약조건
  - e.g.) 주석, 노트

### 3.2.2 관계(Relationships) : `연의 일실 포집`⭐

- `연관관계(Association)`
  - `2개 이상 사물이 서로 관련된 관계`
  - 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때 표시

![info-processing_3_6](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_6.png)

- `의존관계(Dependency)`
  - 연관 관계와 같이 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때 표시
  - 연관 관계와 차이점은 `두 클래스의 관계가 한 메서드를 실행하는 동안과 같이 매우 짧은 시간만 유지`
  - 한 클래스의 명세가 바뀌면 다른 클래스에 영향을 줌
  - 한 클래스가 다른 클래스를 <u>오퍼레이션의 매개변수로 사용</u>하는 경우

![info-processing_3_7](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_7.png)

- `일반화 관계(Generalization)`
  - 한 클래스가 다른 클래스를 포함하는 상위 개념일 때의 관계
  - 객체지향 개념에서는 일반화 관계를 `상속관계(Inheritance)`라고 함

![info-processing_3_8](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_8.png)

- `실체화 관계 (Realization)`
  - 인터페이스를 구현받아 `추상 메서드를 오버라이딩(재정의)` 하는 것을 의미
  - 한 객체가 다른 객체에게 <u>오퍼레이션을 수행</u>하도록 지정

![info-processing_3_9](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_9.png)

- `포함 관계 (Composition)`

  - 부분 객체가 전체 객체에 속하는 관계로 `긴밀한 필수적 관계`

  - 전체 객체의 라이프타임과 부분 객체의 라이프 타임은 <u>의존적</u>

  - 전체 객체가 없어지면 부분 객체도 없어짐

![info-processing_3_11](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_11.png)

- `집합 관계 (Aggregation)`
  - `한 객체가 다른 객체를 소유`하는 ‘has a’ 관계
  - 전체 객체의 라이프타임과 부분 객체의 라이프타임은 <u>독립적</u>
  - 전체 객체가 사라진다 해도 부분 객체는 사라지지 않음

![info-processing_3_10](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_10.png)

---

### 3.2.3 다이어그램(Diagram)⭐

#### (1) 구조 다이어그램 : `클객컴 배복패`

|        종류         | 설명                                                                                               |
| :-----------------: | -------------------------------------------------------------------------------------------------- |
| 클래스 다이어그램⭐ | - <u>클래스의 속성과 클래스 사이의 관계</u>를 표현<br />- 시스템 구조 파악 및 구조상 문제점을 도출 |
|   객체 다이어그램   | 클래스에 속한 객체(인스턴스)를 특정 시점의 <u>객체와 객체 사이 관계</u>로 표현                     |
| 컴포넌트 다이어그램 | <u>컴포넌트 사이 관계</u>나 인터페이스를 표현                                                      |
|   배치 다이어그램   | \- 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 <u>위치를 표현</u><br />- 노드와 통신 경로를 표현 |
|  복합체 다이어그램  | 클래스나 컴포넌트가 <u>복합구조</u>를 가질 시 그 내부 구조를 표현                                  |
| 패키지 다이어그램⭐ | 유즈케이스나 클래스 등 모델 요소들을 <u>그룹화한 패키지들의 관계</u> 표현                          |

#### (2) 행위 다이어그램 : `유시커 상활타`

|          종류           | 설명                                                                                                                                                                                                                                                                       |
| :---------------------: | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 유스케이스 다이어그램⭐ | - 유저의 요구를 분석하며 <u>기능 모델링 작업</u>에 사용<br />- 시스템의 기능을 나타내기 위해 <u>사용자의 요구를 추출하고 분석</u>하는 데 사용<br />- 외부에서 보는 시스템의 동작으로, 내부 객체들이 어떻게 상호작용하는지 모델링<br />- 구성요소 : Actor, Use Case, System |
|   시퀀스 다이어그램⭐   | \- 특정 행동이 <u>어떠한 순서로 어떤 객체와 상호작용</u> 하는지 표현<br />- 현재 시스템이 어떠한 시나리오로 움직이고 있는지를 나타냄<br />- 구성요소 : 활성객체, 메시지, 생명선, 제어사각형<br />- 메시지유형 : 동기 메시지, 비동기 메시지, 반환 메시지, 자체 메시지       |
| 커뮤니케이션 다이어그램 | 동작에 참여한 <u>객체들이 주고받는 메시지</u>와 객체 간 연관까지 표현                                                                                                                                                                                                      |
|    상태 다이어그램⭐    | 객체가 자신이 속한 클래스의 <u>상태 변화 및 다른 객체 간 상호작용</u>에 따라 상태 변화 표현                                                                                                                                                                                |
|     활동 다이어그램     | 시스템이 어떤 기능을 수행하는지에 따라 객체 처리 로직이나 조건에 따른 처리 흐름을 순서에 따라 표현                                                                                                                                                                         |
|    타이밍 다이어그램    | 객체 상태 변화와 시간 제약 명시적 표현                                                                                                                                                                                                                                     |
|   상호작용 다이어그램   | 상호작용 다이어그램 간 제어 흐름 표현                                                                                                                                                                                                                                      |

---

## 3.3 주요 다이어그램⭐

### 3.3.1 클래스 다이어그램

#### (1) 클래스 다이어그램 개념

- 자기만의 속성(attribute)과 일정한 행동(behavior)으로 구성
- 여러 개의 클래스들은 서로 연관이나 상속, 의존 관계 등으로 서로 간의 상호작용을 표현

#### (2) 클래스 다이어그램 표현

![info-processing_3_12](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_12.png)

#### (3) 접근 제한자 표기법

| 표기법 | 접근 제한자 | 사용 범위                            |
| :----: | :---------: | ------------------------------------ |
|   -    |   private   | 해당 클래스 내에서만 접근 가능       |
|   #    |  protected  | 상속, 동일 패키지 내에서만 접근 가능 |
|   +    |   pubilc    | 어디서든 접근 가능                   |

---

### 3.3.2 유스케이스 다이어그램

#### (1) 유스케이스 다이어그램 개념

- 시스템과 사용자의 상호작용을 다이어그램으로 표현
- 사용자의 관점에서 시스템의 서비스 혹은 기능 및 그와 관련한 외부 요소를 보여준다.
- 프로젝트에 대한 요구사항을 정의하고 세부기능을 분석하며 개발 범위를 정할 때 작성한다.

#### (2) 유스케이스 다이어그램 구성요소 : `유액시`

![info-processing_3_13](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_13.png)

|      구성 요소      | 설명                                                              |
| :-----------------: | ----------------------------------------------------------------- |
| 유스케이스(Usecase) | 사용자 입장에서 바라본 시스템의 기능                              |
|     액터(Actor)     | 시스템의 외부에 있고 시스템과 상호작용을 하는 사람, 시스템을 표현 |
|   시스템(System)    | 만들고자 하는 프로그램 명칭                                       |
|   관계(Relation)    | 액터와 유스케이스 사이의 의미있는 관계                            |

#### (3) 유스케이스 다이어그램

![info-processing_3_14](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_14.png)

|            관계             | 설명                                                                                                        |
| :-------------------------: | ----------------------------------------------------------------------------------------------------------- |
|    연관관계(Association)    | - 유스케이스와 액터간의 <u>상호작용이 있음</u>을 표현- 유스케이스와 액터를 실선으로 연결                    |
|    포함 관계(Include)⭐     | - 유스케이스를 <u>수행할 때 반드시 실행</u>되어야 하는 경우- `<<include>>`                                  |
|     확장 관계(Extend)⭐     | - 유스케이스를 수행 할 때 <u>특정 조건에 따라</u> 확장 기능 유스케이스를 <u>수행</u>하는 경우- `<<extend>>` |
| 일반화 관계(Generalization) | 유사한 유스케이스 또는 액터를 모아 추상화한 유스케이스                                                      |

---

### 3.3.3 시퀀스 다이어그램

#### (1) 시퀀스 다이어그램 개념

- 객체간의 상호작용 메시지 시퀀스를 <u>시간의 흐름에 따라</u> 나타내는 다이어그램

#### (2) 시퀀스 다이어그램 구성요소 : `객생메실`

![시퀀스 다이어그램 예시](https://raw.githubusercontent.com/berenickt/image-server/main/img/sequence-diagram.png)

- `객체(Object)` : 객체(활동 주체)는 직사각형으로 표현
- `생명선(Lifeline)`

  - 라이프라인은 객체에서 이어지는 점선으로 표현
  - 점선은 위에서 아래로 갈수록 시간의 경과를 의미

- `실행 박스(Activation Box)`

  - 생명선상에서 길다란 직사각형으로 표현
  - 현재 객체가 어떤 활동을 하고 있음을 의미

- `메시지(Message)` : 인스턴스 간 주고 받은 데이터
  - 메시지의 유형
    - `동기 메시지 (Sync message)`: 요청을 보낸 후에 <u>반환이 올 때까지 대기</u>
      - e.g., TCP
    - `비동기 메시지 (Async message)`: 요청을 보낸 다음 <u>반환을 기다리지 않고</u> 다른 작업을 수행
      - e.g. UDP
    - `자체 메시지 (Self message)`: <u>자기 자신에게 요청</u>을 보냄
    - `반환 메시지 (Reply/Return message)`: <u>요청에 대해 메시지를 반환</u>

![info-processing_4_15](https://raw.githubusercontent.com/berenickt/image-server/main/img/info-processing_3_15.png)

---

### 3.3.4 상태 다이어그램

#### (1) 상태 다이어그램 개념

- 한 객체의 <u>상태 변화를 나타내는</u> 다이어그램

#### (2) 상태 다이어그램 예시

![상태 다이어그램 예시](https://raw.githubusercontent.com/berenickt/image-server/main/img/status-diagram.png)
