---
title: '3ì¥ í•¨ìˆ˜'
date: 2023/12/12
---

# 1. SOLID

ê°ì²´ì§€í–¥ ì„¤ê³„ì˜ 5ê°€ì§€ ì›ì¹™

1. `SRP(Single Responsibility)` : ë‹¨ì¼ ì±…ì„ ì›ì¹™
2. `OCP(Open/Closed Principle)` : ê°œë°©-íì‡„ ì›ì¹™
3. `LSP(Liskov's Substitution Principle)` : ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™
4. `ISP(Interface Segregation)` : ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ ì›ì¹™
5. `DIP(Dependency Inversion)` : ì˜ì¡´ì„± ì—­ì  ì›ì¹™

---

## 1.1 SRP(ë‹¨ì¼ ì±…ì„ ì›ì¹™)

í•œ í´ë˜ìŠ¤ëŠ” í•˜ë‚˜ì˜ ì±…ì„ë§Œ ê°€ì ¸ì•¼ í•œë‹¤.

- í´ë˜ìŠ¤ëŠ” í•˜ë‚˜ì˜ ê¸°ëŠ¥ë§Œ ê°€ì§€ë©°, ì–´ë–¤ ë³€í™”ì— ì˜í•´ í´ë˜ìŠ¤ë¥¼ ë³€ê²½í•´ì•¼ í•˜ëŠ” ì´ìœ ëŠ” ì˜¤ì§ í•˜ë‚˜ë¿ì´ì–´ì•¼ í•œë‹¤.
- SRP ì±…ì„ì´ ë¶„ëª…í•´ì§€ê¸° ë•Œë¬¸ì—, ë³€ê²½ì— ì˜í•œ ì—°ì‡„ì‘ìš©ì—ì„œ ììœ ë¡œì›Œì§ˆ ìˆ˜ ìˆë‹¤.
- ê°€ë…ì„± í–¥ìƒê³¼ ìœ ì§€ë³´ìˆ˜ê°€ ìš©ì´í•´ì§„ë‹¤.
- ì‹¤ì „ì—ì„œëŠ” ì‰½ì§€ ì•Šì§€ë§Œ ëŠ˜ ìƒê¸°í•´ì•¼ í•œë‹¤.

---

## 1.2 OCP(ê°œë°©-íì‡„ ì›ì¹™)

ì†Œí”„íŠ¸ì›¨ì–´ ìš”ì†ŒëŠ” í™•ì¥ì—ëŠ” ì—´ë ¤ ìˆìœ¼ë‚˜ ë³€ê²½ì—ëŠ” ë‹«í˜€ ìˆì–´ì•¼ í•œë‹¤.

- ã…‚ë³€ê²½ì„ ìœ„í•œ ë¹„ìš©ì€ ê°€ëŠ¥í•œ ì¤„ì´ê³ , í™•ì¥ì„ ìœ„í•œ ë¹„ìš©ì€ ê°€ëŠ¥í•œ ê·¹ëŒ€í™”í•´ì•¼ í•œë‹¤.
- ìš”êµ¬ì‚¬í•­ì˜ ë³€ê²½ì´ë‚˜ ì¶”ê°€ì‚¬í•­ì´ ë°œìƒí•˜ë”ë¼ë„, ê¸°ì¡´ êµ¬ì„±ìš”ì†Œì—ëŠ” ìˆ˜ì •ì´ ì¼ì–´ë‚˜ì§€ ì•Šê³ , ê¸°ì¡´ êµ¬ì„± ìš”ì†Œë¥¼ ì‰½ê²Œ í™•ì¥í•´ì„œ ì¬ì‚¬ìš©í•œë‹¤.
- ê°ì²´ì§€í–¥ì˜ ì¶”ìƒí™”ì™€ ë‹¤í˜•ì„±ì„ í™œìš©í•œë‹¤.

---

## 1.3 LSP(ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™)

ì„œë¸Œ íƒ€ì…ì€ ì–¸ì œë‚˜ ê¸°ë°˜ íƒ€ì…ìœ¼ë¡œ êµì²´í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤.

- ì„œë¸Œ íƒ€ì…ì€ ê¸°ë°˜ íƒ€ì…ì´ ì•½ì†í•œ ê·œì•½(ì ‘ê·¼ì œí•œì, ì˜ˆì™¸ í¬í•¨)ì„ ì§€ì¼œì•¼ í•œë‹¤.
- í´ë˜ìŠ¤ ìƒì†, ì¸í„°í˜ì´ìŠ¤ ìƒì†ì„ ì´ìš©í•´ í˜¸ê°€ì¥ì„±ì„ íšë“í•œë‹¤.
- ë‹¤í˜•ì„±ê³¼ í™•ì¥ì„±ì„ ê·¹ëŒ€í™”í•˜ê¸° ìœ„í•´ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ì¢‹ë‹¤.
- í•©ì„±(composition)ì„ ì´ìš©í•  ìˆ˜ë„ ìˆë‹¤.

---

## 1.4 ISP(ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ ì›ì¹™)

ìì‹ ì´ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì¸í„°í˜ì´ìŠ¤ëŠ” êµ¬í˜„í•˜ì§€ ë§ì•„ì•¼ í•œë‹¤.

- ê°€ëŠ¥í•œ ìµœì†Œí•œì˜ ì¸í„°í˜ì´ìŠ¤ë§Œ êµ¬í˜„í•œë‹¤.
- ë§Œì•½ ì–´ë–¤ í´ë˜ìŠ¤ë¥¼ ì´ìš©í•˜ëŠ” í´ë¼ì´ì–¸íŠ¸ê°€ ì—¬ëŸ¬ ê°œê³ , ì´ë“¤ì´ í´ë˜ìŠ¤ì˜ íŠ¹ì • ë¶€ë¶„ë§Œ ì´ìš©í•œë‹¤ë©´, ì—¬ëŸ¬ ì¸í„°í˜ì´ìŠ¤ë¡œ ë¶„ë¥˜í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ê°€ í•„ìš”í•œ ê¸°ëŠ¥ë§Œ ì „ë‹¬í•œë‹¤.
- SRPê°€ í´ë˜ìŠ¤ì˜ ë‹¨ì¼ ì±…ì„ì´ë¼ë©´, ISPëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ ë‹¨ì¼ ì±…ì„

---

## 1.5 DIP(ì˜ì¡´ì„± ì—­ì „ ì›ì¹™)

ìƒìœ„ ëª¨ë¸ì€ í•˜ìœ„ ëª¨ë¸ì— ì˜ì¡´í•˜ë©´ ì•ˆëœë‹¤. ë‘˜ ë‹¤ ì¶”ìƒí™”ì— ì˜ì¡´í•´ì•¼ í•œë‹¤.
ì¶”ìƒí™”ëŠ” ì„¸ë¶€ ì‚¬í•­ì— ì˜ì¡´í•´ì„œëŠ” ì•ˆëœë‹¤. ì„¸ë¶€ ì‚¬í•­ì€ ì¶”ìƒí™”ì— ë”°ë¼ ë‹¬ë¼ì§„ë‹¤.

- í•˜ìœ„ ëª¨ë¸ì˜ ë³€ê²½ì´ ìƒìœ„ ëª¨ë“ˆì˜ ë³€ê²½ì„ ìš”êµ¬í•˜ëŠ” ìœ„ê³„ê´€ê³„ë¥¼ ëŠëŠ”ë‹¤.
- ì‹¤ì œ ì‚¬ìš©ê´€ê³„ëŠ” ê·¸ëŒ€ë¡œì´ì§€ë§Œ, ì¶”ìƒí™”ë¥¼ ë§¤ê°œë¡œ ë©”ì‹œì§€ë¥¼ ì£¼ê³  ë°›ìœ¼ë©´ì„œ ê´€ê³„ë¥¼ ëŠìŠ¨í•˜ê²Œ ë§Œë“ ë‹¤.

ë§Œì•½ ë‹¤ìŒ ì½”ë“œì—ì„œ ìƒˆë¡œìš´ ì¹´ë“œì‚¬ê°€ ì¶”ê°€ëœë‹¤ë©´?

```java
class PaymentController {
	@RequestMapping(value = "/api/payment", method = RequestMethod.POST)
	public void pay(@RequestBody ShinhanCardDto.PaymentRequest req) {
		shinhancarPaymentService.pay(req);
	}
}

class ShinhanCardPaymentService {
  public void pay(ShinhanCardDto.PaymentRequest req) {
    shinhanCardApi.pay(req);
  }
}
```

í™•ì¥ì— ìœ ì—°í•˜ì§€ ì•Šë‹¤.

```java
@RequestMapping(value = "/api/payment", method = RequestMethod.POST)
public void pay(@RequestBody CardPaymentDto.PaymentRequest req) {
	if(req.getType() === CardType.SHINHAN) {
    shinhancarPaymentService.pay(req);
  } else if(req.getType() == CardType.WOORI) {
    wooriCardPaymentService.pay(req);
  }
}
```

ë‘˜ ë‹¤ ì¶”ìƒí™”ëœ ì¸í„°í˜ì´ìŠ¤ì— ì˜ì¡´í•˜ë„ë¡ í•œë‹¤.

```java
class PaymentController {
	@RequestMapping(value = "/payment", method = RequestMethod.POST)
	public void pay(@RequestBody CardPaymentDto.PaymentRequest req) {
    final CardPaymentService cardPaymentService = cardPaymentFactory.getType(req.getType());
    cardPaymentService.pay(req);
	}
}

public interface CardPaymentService {
  void pay(CardPaymentDto.PaymentRequest req);
}

public class ShinhanCardPaymentService implements CardPaymentService {
  @Override
  public void pay(CardPaymentDto.PaymentRequest req) {
    shinhanCardApi.pay(req);
  }
}
```

---

# 2. ê°„ê²°í•œ í•¨ìˆ˜ ì‘ì„±í•˜ê¸°

ë‹¤ìŒ ì½”ë“œëŠ” í•¨ìˆ˜ê°€ ê¸¸ê³ , ì—¬ëŸ¬ê°€ì§€ ê¸°ëŠ¥ì´ ì„ì—¬ìˆìŠµë‹ˆë‹¤.

```java
public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception {
  boolean isTestPage = pageData.hasAttribute("Tset");
  if (isTestPage) {
    WikiPage testPage = pageData.getWikiPage();
    StringBuffer newPageContent = new StringBuffer();
    includeSetupPages(testPage, newPageContent, isSuite);
    newPageContent.append(pageData.getContent());
    includeTeardownPages(testPage, newPageContent, isSuite);
    pageData.setContent(newPageContent.toString());
  }
  return pageData.getHtml();
}
```

ì‘ê²Œ ìª¼ê° ë‹¤. í•¨ìˆ˜ ë‚´ ì¶”ìƒí™” ìˆ˜ì¤€ì„ ë™ì¼í•˜ê²Œ ë§ì¶˜ë‹¤.

```java
public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception {
  if (isTestPage(pageData))
    includeSetupAndTeardownPages(pageData, isSuite);
  return pageData.getHtml();
}
```

---

## 2.1 í•œ ê°€ì§€ë§Œ í•˜ê¸°(SRP), ë³€ê²½ì— ë‹«ê²Œ ë§Œë“¤ê¸°(OCP)

ê³„ì‚°ë„ í•˜ê³ , Moneyë„ ìƒì„±í•œë‹¤. ë‘ ê°€ì§€ ê¸°ëŠ¥ì´ ë³´ì¸ë‹¤. ì´ë–„ 'ìƒˆë¡œìš´ ì§ì› íƒ€ì…ì´ ì¶”ê°€ëœë‹¤ë©´?'

```java
public Money calculatePay(Employee e) throws InvalidEmployeeType {
  switch (e.type) {
    case COMMISSIONED:
      return calculateCommissionedPay(e);
    case HOURLY:
      return calculateHourlyPay(e);
    case SALARIED:
      return calculateSalariedPay(e);
    default:
      throw new InvalidEmployeeType(e.type);
  }
}
```

ê³„ì‚°ê³¼ íƒ€ì…ê´€ë¦¬ë¥¼ ë¶„ë¦¬, íƒ€ì…ì— ëŒ€í•œ ì²˜ë¦¬ëŠ” ìµœëŒ€í•œ Factoryì—ì„œë§Œ

```java
public abstract class Employee {
  public abstract boolean isPayday();
  public abstract Money calculatePay();
  public abstract void deliverPay(Money pay);
}

public interface EmplyeeFactory {
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeTytpe;
}

public class EmployeeFactoryImpl implements EmployeeFactory {
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
    switch (r.type) {
      case COMMISSIONED:
        return calculateCommissionedPay(e);
      case HOURLY:
        return calculateHourlyPay(e);
      case SALARIED:
        return calculateSalariedPay(e);
      default:
        throw new InvalidEmployeeType(e.type);
    }
  }
}
```

---

## 2.2 í•¨ìˆ˜ ì¸ìˆ˜

ì¸ìˆ˜ì˜ ê°œìˆ˜ëŠ” 0~2ê°œê°€ ì ë‹¹í•˜ë‹¤. 3ê°œ ì´ìƒì¸ ê²½ìš°ì—ëŠ”?

```java
// ê°ì²´ë¥¼ ì¸ìë¡œ ë„˜ê¸°ê¸° ğŸ‘
Circle makeCircle(double x, double y, double radius); // âŒ
Circle makeCircle(Point center, double radius); // â­•

// ê°€ë³€ ì¸ìë¥¼ ë„˜ê¸°ê¸° -> íŠ¹ë³„í•œ ê²½ìš°ê°€ ì•„ë‹ˆë©´ ì˜..ğŸ–
String.format(String format, Object... args);
```

---

# 3. ì•ˆì „í•œ í•¨ìˆ˜ ì‘ì„±í•˜ê¸°

## 3.1 ë¶€ìˆ˜ íš¨ê³¼(Side Effect)ì—†ëŠ” í•¨ìˆ˜

ë¶€ìˆ˜ íš¨ê³¼? ê°’ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ê°€ ì™¸ë¶€ ìƒíƒœë¥¼ ë³€ê²½í•˜ëŠ” ê²½ìš°

í•¨ìˆ˜ì™€ ê´€ê³„ì—†ëŠ” ì™¸ë¶€ ìƒíƒœë¥¼ ë³€ê²½ì‹œí‚¨ë‹¤.

```java
public class UserValidator {
  private Cryptographer crytographer;
  public boolean checkPassword(String userName, String password) {
    User user = UserGateway.findByName(userName);
    if (user != User.NULL) {
      String codedPhrase = user.getPhraseEncodedByPassword();
      String phrase = cryptographer.decrypt(codedPhrase, password);
      if ("Valid Password".equals(phrase)) {
        Seesion.initialize();
        return true;
      }
    }
    return false;
  }
}
```

---

# 4. í•¨ìˆ˜ ë¦¬íŒ©í„°ë§

1. ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ëŠ” ì„œíˆ¬ë¥¸ í•¨ìˆ˜ë¥¼ ì‘ì„±í•œë‹¤.
   - ê¸¸ê³ , ë³µì¡í•˜ê³ , ì¤‘ë³µë„ ìˆë‹¤.
2. í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì‘ì„±í•œë‹¤.
   - í•¨ìˆ˜ ë‚´ë¶€ì˜ ë¶„ê¸°ì™€ ì—£ì§€ê°’ë§ˆë‹¤ ë¹ ì§ì—†ì´ í…ŒìŠ¤íŠ¸í•˜ëŠ” ì½”ë“œë¥¼ ì§ ë‹¤.
3. ë¦¬íŒ©í„°ë§ì„ í•œë‹¤.
   - ì½”ë“œë¥¼ ë‹¤ë“¬ê³ , í•¨ìˆ˜ë¥¼ ìª¼ê°œê³ , ì´ë¦„ì„ ë°”ê¾¸ê³ , ì¤‘ë³µì„ ì œê±°í•œë‹¤.

---

# 5. í”„ë¡œì íŠ¸
