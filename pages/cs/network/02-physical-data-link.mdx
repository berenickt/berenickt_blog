---
title: '02-물리 계층과 데이터 링크 계층'
date: 2024/04/13
---

## 1. 이더넷

![self-network_2_1](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_1.png)

`물리 계층`과 `데이터 링크 계층`은 서로 밀접하게 연관되어 있다.
오늘날 두 계층은 `이더넷`이라는 공통 기술을 사용하기 때문이다.

- `이더넷(Ethernet)` : 현대 LAN, 유선 LAN 환경에서 가장 대중적으로 사용되는 기술
- e.g. 두 대의 컴퓨터가 있다고 가정해보면,
  - 이 컴퓨터끼리 정보를 주고받으려면 가장 먼저 케이블과 같은 통신 매체가 필요하다.
  - 그리고 통신 매체를 통해 정보를 송수신하는 방법이 정해져 있다.
- `이더넷`은 다양한 통신 매체의 규격들과 송수신되는 프레임의 형태, 프레임을 주고받는 방법 등이 정의된 네트워크 기술이다.

---

### 1.1 이더넷 표준

- 오늘날의 `유선 LAN 환경`은 **대부분 이더넷을 기반으로 구성**된다.
- 그래서 유선 LAN 환경을 구축했다면,
  - 십중팔구 `물리 계층`에서는 **이더넷 규격 케이블**을 사용했을 것이고,
  - `데이터 링크 계층`에서 주고받는 프레임은 **이더넷 프레임의 형식**을 따를 것이다.
- 현재 이더넷은 국제 표준화가 이루어 졌다.
  - cf. 전기전자공학자협회(IEEE; Institute of Electrical and Electronics Engineers) 국제조직은 이더넷 관련 기술을 IEEE 802.3이라는 이름으로 표준화했다.
  - IEEE 802.3이란 이더넷 관련 다양한 표준들의 모음을 의미한다.
- 서로 다른 컴퓨터가 각기 다른 제조사의 네트워크 장비를 사용하더라도 동일한 형식의 프레임을 주고받고 약속한 듯,
  - **통일된 형태로 작동하는 것**은 통신 매체를 비롯한 **네트워크 장비들이 이더넷 표준을 준수하기 때문**이다.
- 오늘날 **모든 네트워크 장비들은 특정 이더넷 표준을 이해하고 따른다고 봐도 무방**하다.
- IEEE 802.3은 이더넷 표준들의 모음을 뜻하기도 하지만,
  - 이더넷 표준화 작업을 위한 IEEE의 전문가 단체, 이른바 이더넷 작업 그룹(Ethernet working group)의 이름이기도 하다.
- 관련 홈페이지에 방문해보면 오늘날에도 새 표준이 개발되고 있다.
  - cf. https://www.ieee802.org/3/
  - IEEE 802.3의 다양한 표준들은 802.3u 혹은 802.3ab처럼 숫자 802.3 뒤에 버전을 나타내는 알파벳으로 표현한다.
  - 많은 표준들이 있지만, 처음부터 모두 암기할 필요는 없다.
  - 핵심은 이더넷 표준에 따라 지원되는 네트워크 장비, 통신 매체의 종류와 전송 속도 등이 달라질 수 있다.

---

### 1.2 통신 매체 표기 형태

이더넷 표준에 따라 통신 매체의 종류와 전송속도가 달라질 수 있다면,

- 이더넷 표준 규격에 따라 구현된 통신 매체를 지칭할 떄,
- IEEE 802.3i 케이블, IEEE 802.3u 케이블처럼 표기할까?
- 위와 같은 경우도 있지만, 일반적으로 그렇지 않다.

보통 이더넷 표준 규격에 따라 구현된 통신 매체를 지칭할 떄는, 통신 매체의 속도와 특성을 한눈에 파악하기 쉽도록 다음 형태로 표기한다.

- `전송속도BASE-추가특성`
  - 1000BASE-SX, 5GBASE-T, 1000BASE-LX,
  - 10BASE-T, 1000BASE-CX, 25GBASE-LR, 2.5GBASE-T, 100GBASE-LR4 등등

---

#### 1.2.1 전송 속도

- 전송 속도(data rate) : 숫자만 표기되어 있으면 Mbps 속도, 숫자 뒤에 G가 붙는 경우 Gbps 속도를 의미한다.
- e.g. `1000Base-T 케이블` : 100Mbps 속도를 지원하는 케이블
- e.g. `10GBASE-T 케이블` : 10Gbps 속도를 지원하는 케이블

| 전송 속도 표기 | 의미             |
| -------------- | ---------------- |
| 10             | 10Mbps           |
| 100            | 100Mbps          |
| 1000           | 1000Mbps (1Gbps) |
| 2.5G           | 2.5Gbps          |
| 5G             | 5Gbps            |
| 10G            | 10Gbps           |
| 40G            | 40Gbps           |
| 100G           | 100Gbps          |

---

#### 1.2.2 BASE

- `BASE`는 `베이스밴드(BASEband)`의 약자로, `변조 타입(modulation type)`을 의미한다.
- `변조타입` : 비트 신호로 변환된 데이터를 통신 매체로 전송하는 방법을 의미
- 일반적인 LAN 환경에서는 특별한 경우가 아니라면, 대부분 디지털 신호를 송수신하는 베이스밴드 방식을 사용
  - 대부분의 이더넷 통신 매체는 BASE를 사용한다.
- cf. BASE 외에도 BROAD로 표기하는 브로드밴드(BROADband), PASS로 표기하는 패스밴드(PASSband)도 있다.

---

#### 1.2.3 추가 특성

- `추가 특성(additional distinction)`에는 통신 매체의 특성을 명시한다.
- 이곳에 명시할 수 있는 특성의 종류는 다양하다.
  - 10BASE-2, 10BASE-5와 같은 `전송 가능한 최대 거리`가 명시되기도 하고,
  - 데이터가 비트 신호로 변환되는 방식을 `물리 계층 인코딩` 방식이 명시되기도 하며,
  - 비트 신호를 옮길 수 있는 전송로 수를 의미하는 `레인 수`가 명시되기도 한다.
- 다만 처음 이더넷을 학습하는 개발자 입장에서는 추가 특성의 종류와 원리는 모두 알야하는 경우가 많지 않다.

---

### 1.3 통신 매체 종류

| 추가 특성 표기(통신 매체의 종류) |      케이블 종류       |
| :------------------------------: | :--------------------: |
|                C                 |      동축 케이블       |
|                T                 | 트위스티드 페어 케이블 |
|                S                 |  단파장 광섬유 케이블  |
|                L                 |  장파장 광섬유 케이블  |

![self-network_2_2](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_2.png)

추가 특성에 C, T, S, L이라는 글자가 있다면, 이는 각각 `동축 케이블(C)`, `트위스티드 페어 케이블(T)`, 단파장 빛을 활용하는 `광섬유 케이블(S)`, 장파장 빛을 활용하는 `광섬유 케이블(L)`을 의미한다.

- 지금은 `트위스티드 페어 케이블`은 구리선 이용하는 케이블,
- `광섬유 케이블`은 빛을 이용하는 테이블의 일종이다.

이제 통신 매체의 전송 속도와 종류를 중심으로 의미를 파악해보면,

- `10BASE-T 케이블` : 10Mbps 속도를 지원하는 트위스티드 페어 케이블
- `1000BASE-SX 케이블` : 1000Mbps 속도를 지원하는 단파장 광섬유 케이블
- `1000BASE-LX 케이블` : 1000Mbps 속도를 지원하는 장파장 광섬유 케이블

다음 표는 이더넷 표준과 이를 기바으로 하는 통신 매체 일부 예시이다.

- `전송속도BASE-추가특성` 형태의 표기를 볼 때,
  - 어떤 종류의 통신 매체인지, 전송 속도는 어느 정도인지 짐작하기 수월하다.
  - 다만, 이더넷 표준과 통신 매체의 표기가 항상 일대일로 대응되는 것은 아니다.

| 표준 규격    | 통신 매체                |
| ------------ | ------------------------ |
| IEEE 802.3i  | 10BASE-T                 |
| IEEE 802.3u  | 100BASE-TX               |
| IEEE 802.3ab | 1000BASE-T               |
| IEEE 802.3bz | 2.5GBASE-T, 5GBASE-T     |
| IEEE 802.3an | 10BASE-T                 |
| IEEE 802.3z  | 1000BASE-SX, 1000BASE-LX |
| IEEE 802.3au | 10BASE-SR, 10GBASE-LR    |

> 💡 이더넷의 발전
>
> 이더넷은 지금도 발전 중이다. 규격별로 지원되는 속도도 점차 빨라지고 있다.
>
> - 초기 이더넷은 대체로 10Mbps 정도의 속도를 지원했지만,
> - 곧 10배 빠른 100Mbps 가량의 속도를 지원하는 이더넷 기술이 개발되었다.
> - 이처럼 100Mbps 가량의 속도를 지원하는 표준들을 통틀어 `고속 이더넷(Fast Ethernet)`이라 부른다.
> - 최근 고속 이더넷의 10배(1Gbps), 100배(10Gbps), 혹은 그 이상의 속도를 지원하는 이더넷 표준들이 많이 만들어 지고 있다.
> - 1Gbps 가량의 속도를 내는 이더넷 표준은 `기가비트 이더넷(Gigabit Ethernet)`,
> - 10Gbps 가량의 속도를 내는 이더넷 표준은 `10기가비트 이더넷(10 Gigabit Ethernet)`이라 통칭한다.
> - 요컨데, `10BASE-T`는 초기 이더넷, `100BASE-TX`는 고속 이더넷,
>   - `1000BASE-T`는 기가비트 이더넷, `10GBASE-T`는 10기가비트 이더넷의 대표 규격이다.

---

### 1.4 이더넷 프레임

지금까지는 물리 계층과 관련된 이더넷 표준과 통신매체를 알아보았다.
이번에는 데이터링크 계층의 이더넷 프레임에 대해 알아보자.

현대 유선 LAN 환경은 대부분 이더넷을 기반으로 구성되므로,

- 호스트가 `데이터 링크 계층`에서 주고받는 프레임 형식도 정해져 있다.
- 즉, 이더넷 네트워크에서 주고받는 프레임인 `이더넷 프레임(Ethernet frame)` 형식은 정해져 있다.
- `이더넷 프레임`은 상위 계층으로부터 받아들인 정보에 헤더와 트레일러를 추가하는 `캡슐화` 과정을 통해 만들어진다.
- 수신지 입장에서는 프레임의 헤더와 트레일러를 제거한 뒤 상위 계층으로 올려보내는 `역캡슐화` 과정을 거친다.

![self-network_2_3](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_3.png)

- `이더넷 프레임 헤더`는 기본적으로 `프리앰블`, `수신지 MAC 주소`, `송신지 MAC 주소`, `타입/길이`로 구성되고,
- `페이로드`는 데이터, `트레일러`는 FCS로 구성된다.

---

#### 1.4.1 프리앰블

![self-network_2_4](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_4.png)

- `프리앰블(preamble)` : 이더넷 프레임의 시작을 알리는 8바이트(64비트) 크기의 정보
- 프리앰블의 첫 7바이트는 `10101010` 값을 가지고, 마지막 바이트는 `10101011` 값을 가진다.
- `수신지`는 이 프리앰블을 통해 이더넷 프레임이 오고 있음을 알아차립니다.
- 즉, `프리앰블`은 **송수신지 간의 동기화를 위해 사용되는 정보**이다.

---

#### 1.4.2 수신지 MAC 주소와 송신지 MAC 주소

- ‘물리적 주소’라고 불리는 `MAC 주소`는 데이터 링크 계층의 핵심이다.
- `MAC 주소`는 **네트워크 인터페이스마다 부여되는 6바이트**(48비트) 길이의 주소로,
  - **LAN 내의 수신지와 송신지를 특정**할 수 있다.
- 같은 네트워크 내에서 동일한 MAC 주소를 가진 기기들이 있다면,
  - 송신지와 수신지를 특정할 수 없기에 곤란할 것입니다.
- 그래서 `MAC 주소`는 일반적으로 고유하고, 일반적으로 변경되지 않는 주소로써 **네트워크 인터페이스마다 부여**된다.
- 보통 `NIC(Network Interface Controller)`라는 장치가 **네트워크 인터페이스 역할을 담당**한다.
  - 즉, 한 컴퓨터에 **NIC가 여러 개** 있다면, **MAC 주소도 여러 개** 있을 수 있다.

MAC 주소와 관련한 대표적인 오해 중 하나가 바로 `MAC 주소`는 ‘**반드시 고유하고 변경이 불가능하다**’라는 점이다.

- 사실 MAC 주소의 변경이 가능한 경우도 많으며, 따라서 고유하지 않을 수도 있다.
- 다만, 동일 네트워크 내에서 동작하는 기기의 MAC 주소가 우연히 같을 확률은 낮고, 같게 만드는 상황도 흔하지 않다.
- 따라서 `MAC 주소`를 ‘**일반적으로 고유하고, 변경되지 않는 주소**’ 정도로 이해하는 것이 적절하다.

윈도우 운영체제에서 명령프로프트(CMD)를 열고 `getmac /v` 혹은 `ipconfig /all`을 입력한다.

```bash
$ getmac /v
# 물리적 주소 === MAC 주소
연결 이름     네트워크 어댑터       물리적 주소           전송이름
=======    ==============    =================  ===============
Wi-Fi      Intel(R) Wi-Fi    AB-CD-EF-AB-CD-01
Bluetooth  Bluetooth Devic   AB-CD-EF-AB-CD-02
```

맥OS나 리눅스 운영체제는 터미널을 열고 `ifconfig`를 입력한다.

```bash
$ ifconfig
en0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500
	options=50b<RXCSUM,TXCSUM,VLAN_HWTAGGING,AV,CHANNEL_IO>
	ether a1:b2:e3:a4:c5:e6 # MAC 주소
	inet6 fe80::c09:9125:a6f6:a3b8%en0 prefixlen 64 secured scopeid 0x6
	inet 192.168.123.123 netmask 0xffffff00 broadcast 192.168.123.123
	nd6 options=201<PERFORMNUD,DAD>
	media: autoselect (1000baseT <full-duplex>)
	status: active
```

MAC 주소를 보면, 총 48비트, 16진수 12자리로 구성된다.

---

#### 1.4.3 타입/길이

`타입/길이` 필드에는 `타입(type)` 혹은 `길이(length)`가 올 수 있다.

- 필드에 명시된 크기가 `1500(16진수 05DC)이하`면, `프레임의 크기(길이)`를 나타내는데 사용
- 필드에 명시된 크기가 `1536(16진수 0600)이상`면, `타입`를 나타내는데 사용

`타입` : 이더넷 프레임이 ‘어떤 정보를 캡슐화했는지’를 나타내는 정보

- cf. `이더타입(ethertype)`이라고도 부른다.
- 대표적으로 상위 계층에서 사용된 프로토콜이 이름이 명시된다.
- e.g. IPv4 프로토콜이 캡슐화된 정보를 운반한다면, 타입에는 16진수 0800이,
  - 어떤 프레임이 ARP 프로토콜이 캡슐화된 정보를 운반한다면, 타입에는 16진수 0806이 명시된다.

| 타입 | 프로토콜 |
| ---- | -------- |
| 0800 | IPv4     |
| 86DD | IPv6     |
| 0806 | ARP      |

> 💡 이더넷 프레임의 타입은 더 많은 종류가 있다.
>
> - Https://github.com/kangtegong/self-learning-cs2

---

#### 1.4.4 데이터

`데이터` : 상위 계층에서 전달받거나 상위 계층으로 전달해야 할 내용

- 네트워크 계층의 데이터와 헤더를 합친 PDU가 이곳에 포함된다.
- 최대 크기는 1500바이트로, 주의할 점은 반드시 일정 크기(64바이트 이상)이어여 한다.
  - 그 이하의 데이터라면, 크기를 맞추기 위해 `패딩(padding)`이라는 정보가 내부에 채워진다.
  - 보통 46바이트 이상이 될 떄까지 0으로 채워진다.

---

#### 1.4.5 FCS

![self-network_2_5](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_5.png)

`FCS(Frame Check Sequence)` : 수신한 이더넷 프레임에 오류가 있는지 확인하기 위한 필드

- 앞서 데이터 링크 계층에서 오류검출이 일어나기도 한다고 했는데, 바로 여기서 오류검출이 이루어진다.
- 이 필드에는 `CRC(Cyclie Redundancy; 순환 중복 검사)`라는 오류 검출용 값이 들어간다.
- `송신지`는 `프리앰블`을 제외한 나머지 필드 값들 바탕으로 `CRC 값`을 계산한 후, 이 값을 `FCS필드`에 명시한다.
- `수신지`는 수신한 프레임에서 `프리앰블`과 `FCS`필드를 제외한 나머지 필드 값들을 바탕으로 `CRC 값`을 계산한 뒤,
  - 이 값을 `FCS 필드` 값과 비교한다.
- 이떄 **비교 값이 일치하지 않으면, 오류가 있다고 판단하여 해당 프레임을 폐기**한다.

---

### 1.5 토큰 링

![self-network_2_6](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_6.png)

이더넷 외에 다른 LAN 기술도 있다. 대표적으로 `토큰 링(Token Ling)`방식이 있다.

- `토큰 링 네트워크`에서는 `호스트`들이 위 그림처럼 `링(고리)` 형태로 연결된다.
- `호스트`끼리 돌아가며 `토큰`이라는 특별한 정보를 주고받는데,
  - 네트워크 내 다른 `호스트`에게 메시지를 송신하려면, 반드시 이 `토큰`을 가지고 있어야 한다.
- 위 그림을 보면, 현재 토큰이 A에게 있으므로 지금은 A만 메시지 전송이 가능하다.
  - C나 D는 메시지를 송신하고 싶어도 송신할 수 없다.
- A는 메시지 전송이 끝나면, 다음 컴퓨터(가령 B)에게 토큰을 넘겨준다.
  - 만약 B가 송신할 메시지가 없다면, 다음 컴퓨터(가령 C)에게 토큰을 그대로 넘겨준다.
  - C가 송신하고자 하는 메시지가 있었다면, 이제 비로소 송신할 수 있다.

---

## 2. NIC와 케이블

![self-network_2_7](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_7.png)

- `NIC(Network Interface Controller)`: 호스트와 통신 매체를 연결하고, MAC 주소가 부여되는 네트워크 장비
- `케이블(cable)` : NIC에 연결되는 물리 계층의 유선 통신 매체
- 케이블의 종류는 다양하지만, 오늘날 유선 네트워크에 사용되는 대표적인 케이블은 두 종류가 있다.
  - `트위스트 페어 케이블`
  - `광섬유 케이블`
- cf. NIC와 케이블은 호스트뿐만 아니라 네트워크 장비에도 연결될 수 있지만,
  - 편의상 ‘호스트와 연결된다’표현 가능하다.

---

### 2.1 NIC

통신 매체에는 전기, 빛 등 다양한 신호가 흐를 수 있다.
호스트가 이를 제대로 이해하려면,
`통신매체를 통해 전달되는 신호`와 `컴퓨터가 이해할 수 있는 정보` 간에 변환이 이루어 져야 한다.

- 이떄 호스트와 유무선 통신 매체를 연결하고, 이러한 변환을 담당하는 네트워크 장비가 `NIC`다.
- e.g. `통신 매체를 통해 전달되는 신호`를 사람들이 주고 받는 ‘말’에 비유한다면,
  - `NIC`는 ‘귀’와 ‘입’에 비유할 수 있다.
- `호스트`는 `NIC`가 있어야 네트워크에 참여할 수 있다.
- 이런 점에서 `NIC`를 ‘`호스트를 네트워크(LAN)에 연결하기 위한 하드웨어`’라 표현되기도 한다.

---

#### 2.1.1 NIC의 생김새

![self-network_2_8](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_8.png)

`NIC`는 네트워크 인터페이스 카드, 네트워크 어댑터, LAN 카드, 네트워크 카드, 이더넷 카드(이더넷 네트워크인 경우) 등 다양한 명칭으로 불린다.

> `확장 카드(expansion card)`는 컴퓨터에 기능을 추가할 목적으로 연결하는 카드 형태의 회로 기판을 말함

- ‘카드’라는 표현이 붙는 이유는 초기 NIC는 위 그림처럼 확장 카드 형태로 따로 연결해 사용해야 했기 떄문이다.
- 요즘에는 NIC 형태도 다양해졌다. USB로 연결하는 NIC도 있고, 마더보드에 내장된 NIC도 있다.
- 만약 누가 추가 장치를 연결하지 않고도, 네트워크에 연결된 컴퓨터를 사용하고 있다면,
  - 높은 확률로 마더보드에 내장된 NIC를 사용 중일 것이다.

![self-network_2_9](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_9.png)

`마더보드(motherboard)`는 위 그림 오른쪽처럼 CPU, 메모리, 보조기억장치 등 컴퓨터의 주요 부품들을 연결할 수 있는 `기판(baord)`를 말한다. 흔히 `메인보드(mainboard)`라고도 부른다.

---

#### 2.1.2 NIC의 역할

- `NIC`는 `통신 매체에 흐르는 신호`를 `호스트가 이해하는 프레임`으로 변환하거나,
- 반대로 `호스트가 이해하는 프레임`을 `통신 매체에 흐르는 신호`로 변환한다.
- 따라서 `호스트`가 네트워크를 통해 송수신하는 정보는 `NIC`를 거치게 된다.
- 이처럼 `NIC`는 네트워크와의 연결점을 담당하는 점에서 `네트워크 인터페이스(network interface)` 역할을 수행한다.

> `NIC`는 호스트와 통신 매체 사이의 인터페이스 역할을 담당하는 네트워크 장비다.

![self-network_2_10](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_10.png)

`MAC 주소`는 **네트워크 인터페이스마다 할당**되고, `NIC`는 **네트워크 인터페이스 역할**을 수행한다고 했다.

- `NIC`는 MAC 주소를 통해 자기 주소는 물론, **수신되는 프레임의 수신지 주소를 인식**한다.
  - 그래서 어떤 프레임이 자신에게 도달했을 떄,
  - 자신과 관련없는 수신지 MAC 주소가 명시된 프레임이라면 폐기할 수 있고,
  - FCS 필드를 토대로 오류를 검출해 잘못된 프레임을 폐기할 수 있다.

> 💡 NIC의 지원 속도
>
> NIC마다 지원되는 속도가 다르다. 왜냐하면 NIC 지원 속도는 네트워크 속도에 영향을 끼치기 떄문이다.
>
> - 통신 매체에 신호가 고속으로 흐른다면, NIC도 그에 맞춰 빨리 움직여야 빠른 성능을 낼 수 있다.
> - 그래서 내장된 NIC가 있더라도, 높은 대역폭에서 많은 트래픽을 감당해야 하는 서버와 같은 환경에서는 고속의 NIC가 추가로 필요한 경우도 있다.
> - NIC의 지원속도는 10Mbps부터 100Gbps에 이르기까지 NIC마다 다르다.
>   - 물론 후자는 전자에 비해 고가의 장치인 경우가 많다.

---

### 2.2 트위스티드 페어 케이블

이번에는 유선 통신 매체인 케이블을 보자.
통신 매체로 연결된 두 호스트가 아부리 빠르게 데이터를 처리할 수 있어도,
정작 통신 매체가 해당 속도를 따라잡지 못하면 아무 효용이 없다.

`트위스티드 페어 케이블(twisted pair cable)`은 구리선으로 전기 신호를 주고받는 통신매체이다.
LAN 케이블이라고 하면 가장 먼저 떠오를 만큼 대중적인 케이블이다.

---

#### 2.2.1 트위스티드 페어 케이블의 생김새

![self-network_2_11](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_11.png)

트위스티드 페어 케이블은 `케이블 본체`와 케이블의 연결부인 `커넥터(connector)`로 이루어져 있다.
혹시 공유기나 컴퓨터에 인터넷 선을 직접 연결해봤다면, 위 그림처럼 생긴 케이블 커넥터를 볼 수 있다.
이떄 주로 활용되는 커넥터를 RJ-45라고 부른다.

![self-network_2_12](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_12.png)

이번에는 케이블 본체를 뜯어보면, 본체 내부는 케이블의 이름처럼 구리 선이 `두 가닥씩(pair)` `꼬아(twisted)`져 있다.

- 그런데 본체가 구리 선으로 이루어진 상태에서 전기 신호를 주고받다 보면,
- 구리선에 **전자적 간섭이 생길 수 있다는 문제**가 있다.
- 이렇게 전기 신호를 왜곡시킬 수 있는 간섭을 `노이즈(noise)`라고 부른다.

![self-network_2_13](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_13.png)

트위스티드 페어 케이블은 구리 선으로 이루어졌기에 노이즈에 민감하다.

- 그래서 트위스티드 페어 케이블 중에서는 구리 선을 그물 모양의 철사 또는 포일로 감싸 보호하는 경우가 많다.
- 구리 선 주변을 감싸 노이즈를 감소시키는 방식을 `차폐(shielding)`라고 하고,
- 차폐에 사용된 그물 모양의 철사와 포일을 각각 `브레이브 실드(braided shield)` 혹은 `포일 실드(foil shield)`라고 한다.

---

#### 2.2.2 실드에 따른 트위스티드 페어 케이블의 분류

- `STP(Shielded Twisted Pair) 케이블` : 브레이브 실드로 구리 선을 감싸 노이즈를 감소시킨 트위스티드 페어 케이블
- `FTP(Foil Twisted Pair) 케이블` : 포일 실드로 노이즈를 감소시킨 트위스티드 페어 케이블
- `UTP(Unshielded Twisted Pair) 케이블` : 아무것도 감싸지 않은 구리 선만 있는 케이블

이처럼 트위스티드 페어 케이블은 실드에 따라 크게 3종류로 나눌 수 있지만, 이는 일반적인 구분법이다.
실제로는 실드의 종류를 다음과 같은 표기로 더 세분화하여 나누기도 한다.

X와 Y에는 U, S, F를 명시할 수 있다.

> 💡 XX / `Y`TP
>
> - U : 실드없음
> - S : 브레이브 실드
> - F : 포일 실드
>
> `XX`는 케이블 외부를 감싸는 실드의 종류가 명시된다.
> 하나 혹은 두 개일 수도 있다. 그리고 `Y`에는 꼬인 구리 선 쌍을 감싸는 실드의 종류가 명시된다.

![self-network_2_14](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_14.png)

e.g.

- `S/FTP 케이블` : 케이블 **외부는 브레이드 실드로** 보호되며, 꼬인 **각 구리 선 쌍은 포일 실드로** 감싼 케이블을 의미
- `F/FTP 케이블` : 케이블 외부와 각 구리 선 쌍을 **모두 포일 실드로** 감싼 케이블을 의미
- `SF/FTP 케이블` : 케이블 **외부는 브레이드 실드와 포일 실드로** 감싸고, **각 구리 선 쌍은 포일 실드로** 감싼 케이블을 의미
- `U/UTP 케이블` : **아무것도 감싸지 않은 케이블**을 의미

> 실드의 종류는 케이블 본체에 직접 명시된 경우가 많기에 용어를 외우지 말고,
> 어떠한 실드를 어떤 규칙으로 표기하는지 이해하자.

---

#### 2.2.3 카테고리에 따른 트위스티드 페어 케이블의 분류

트위스티드 페어 케이블은 `카테고리(category)`에 따라서도 분류할 수 있다.
카테고리는 트위스티드 페어 케이블 성능의 등급을 구분하는 역할을 한다.
높은 카테고리에 속한 케이블일 수 록 높은 성능을 보인다.

카테고리는 영문 표기 Category에서 앞의 세 글자를 딴 `Cat`이라는 표기로 줄여서 표현하는 경우가 많다.
e.g. 카테고리3은 Cat3(혹은 Cat.3), 카테고리5는 Cat5(혹은 Cat.5)처럼 표기하는 식이다.

|     특징      |    Cat5    |   Cat5e    |    Cat6     |   Cat6a    |   Cat7   |   Cat8    |
| :-----------: | :--------: | :--------: | :---------: | :--------: | :------: | :-------: |
|  지원 대역폭  |   100MHz   |   100MHz   |   250MHz    |   500MHz   |  600MHz  |   2GHz    |
| 주요 대응규격 | 100BASE-TX | 1000BASE-T | 1000BASE-TX | 10GBASE-TX | 10GASE-T | 40GBASE-T |
|   전송 속도   |  100Mbps   |   1Gbps    |    1Gbps    |   10Gbps   |  10Gbps  |  40Gbps   |

표의 내용처럼 카테고리에 따라 지원 대역폭, 주요 대응 규격, 전송 속도와 같은 케이블의 성능이 각각 다르다.
카테고리가 높을 수록 지원 가능한 대역폭이 높아지는데,
이는 카테고리가 높은 트위스티드 페어 케이블은 송수신할 수 있는 데이터의 양이 더 많고, 더 빠른 전송이 가능함을 의미한다.

![self-network_2_15](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_15.png)

카테고리는 케이블을 구매할 떄 확인해야 하는 정보 중 하나다.
위 그림처럼 케이블 자체에 적혀있는 경우도 많다.
자기 집에 트위스티드 페어 케이블이 있고, 케이블 본체에 카테고리가 명시되어 있다면 전송 속도를 한 번 짐작해보자.

---

### 2.3 광섬유 케이블

![self-network_2_16](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_16.png)

`광섬유 케이블(fiber optic cable)` : 빛(광신호)을 이용해 정보를 주고받는 케이블

- 빛을 이용해서 전송하기에 전기 신호를 이용하는 케이블에 비해 속도도 빠르고, 먼 거리까지 전송이 가능하다.
- 또한 노이즈로부터 간섭받는 영향도 적다.
- 그렇기에 광섬유 케이블은 대륙 간 네트워크 연결에도 사용된다.

---

#### 2.3.1 광섬유 케이블의 생김새

![self-network_2_17](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_17.png)

광섬유 케이블도 트위스티드 페어 케이블과 마찬가지로 `케이블 본체`와 `커넥터`로 이루어져 있다.

![self-network_2_18](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_18.png)

다만 광섬유 케이블은 트위스티드 케이블에 비해 활용되는 커텍터 종류가 더 다양하다.
대표적으로 `LC 커넥터`, `SC 커넥터`, `FC 커넥터`, `ST 커넥터`가 있다.

![self-network_2_19](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_19.png)

`광섬유 케이블 본체` 내부는 마치 머리카락과 같은 형태의 `광섬유`로 이루어져 있다.
`광섬유`는 빛을 운반하는 매체다.

![self-network_2_20](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_20.png)

광섬유 한 가닥의 확대해보면, 광섬유 중심에는 `코어(core)`가 있다.

- 코어는 광섬유에서 실질적으로 빛이 흐르는 부분이다.

그리고 코어를 둘러싸는 `클래딩(cladding)`이 있다.

- 클래딩은 빛이 코어 안에서만 흐르도록 빛을 가두는 역할을 한다.
- 코어와 클래딩 간에 빛의 굴절률 차이를 만들어 빛을 코어 내부에 가두는 원리다.

광섬유 케이블은 코어의 지름에 따라
`싱글 모드 광섬유 케이블(SMF: Single Mode Fiber)`과 `멀티 모드 광섬유(MMF; Multi Mode Fiber)`로 나뉜다.

---

#### 2.3.2 싱글 모드 광섬유 케이블

![self-network_2_21](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_21.png)

`싱글 모드 광섬유 케이블`과 `멀티 모드 광섬유 케이블`의 주된 차이점은 `코어의 지름`이다.

- `싱글모드`는 코어의 지름이 8~10um정도로, `멀티 모드`에 비해 작다.
  - cf. `um`는 길이의 단이로, `마이크로미터`라고 읽는다.
- 코어의 지름이 작다면, 빛이 이동할 수 있는 경로가 많지 않다.
- 즉, 코어의 지름이 작다면, 빛의 이동경로가 하나 이상 갖기 어렵고,
  - 이를 두고 `모드(mode)가 하나(single)`라고 표현한다.
- 싱글 모드 케이블은 신호 손실이 적기에 장거리 전송에 적합하다.
- 반면에, 멀티 모드에 비해 일반적으로 비용이 높다는 단점이 있다.

![self-network_2_22](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_22.png)

`싱글 모드 케이블`은 파장이 긴 장파장의 빛을 사용한다.
대표적으로 `싱글 모드 광섬유 케이블` 규격으로는 `1000BASE-LX`, `10GBASE-LR`이 있다.
여기서 `L`은 `장(Long)파장`을 의미한다.

---

#### 2.3.3 멀티 모드 광섬유 케이블

![self-network_2_23](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_23.png)

`멀티 모드 케이블`은 코어의 지름이 50~62.5um 정도로 싱글모드보다 크다.

- 따라서 빛이 여러 경로로 이동할 수 있다.
  - 이를 두고 `모드(mode)가 여러 개(multi)`라고 표현한다.
- `멀티 모드`는 `싱글 모드`보다 전송 시 신호 손실이 클 수 있기에 장거리 전송에 부적합하다.
- 실제로 `싱글 모드 케이블`은 수십 킬로미터까지 전송이 가능한 데 비해,
  - `멀티 모드 케이블`은 일반적으로 수백 미터, 길어야 수 킬로미터 정도만 전송이 가능하다.
  - 그래서 `멀티 모드 케이블`은 비교적 근거리를 연결하는 데 주로 사용된다.

또한 `멀티 모드 케이블`은 `싱글 모드`에 비해 단파장의 빛을 사용한다.

- 대표적인 `멀티 모드 케이블` 규격으로 `1000BASE-SX`, `10GBASE-SR`이 있다.
- 여기서 `S`는 `단(short)파장`을 의미한다.

> 💡 케이블 색상으로 분류하는 싱글모드와 멀티모드
>
> - 싱글 모드 광섬유 케이블과 멀티 모드 광섬유 케이블은 케이블 본체의 색상으로 구분할 수 있다.
> - 일반적으로 `싱글 모드`는 대부분 `노란색과 파란색`을 쓴다.
> - 일반적으로 `멀티 모드`는 대부분 `오렌지색과 아쿠아색`을 쓴다.

---

## 3. 허브

![self-network_2_24](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_24.png)

통신 매체를 통해 송수신되는 메시지는 다른 호스트에게 전달되는 과정에서 네트워크 장비를 거칠 수 있다.

- 대표적이 네트워크 장비로 `물리 계층`에는 `허브`가 있고, `데이터 링크 계층`에는 `스위치`가 있다.
- 먼저 **물리 계층에서 여러 대의 호스트를 연결**하는 `허브`의 특징을 알아보고,
  - 이와 관련해 허브의 동작 방식인 `반이중 모드 통신`에 대해 알아본다.
  - 이와 반대되는 개념인 `전이중 모드`도 함께 배운다.
- 또한 `허브에 발생하는 충돌 문제`와 이를 해결하기 위한 프로토콜인 `CSMA/CD`도 배운다.

---

### 3.1 주소 개념이 없는 물리 계층

![self-network_2_25](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_25.png)

기억할 점은 `물리 계층`에는 **주소 개념이 없다**.

- `송수신지를 특정할 수 있는 주소`는 **데이터 링크 계층부터 존재하는 개념**이다.
- `물리 계층`에서는 단지 호스트와 통신 매체 간의 연결과 통신 매체상의 송수신이 이루어진다.
- 그렇기에 물리 계층의 네트워크 장비는 송수신되는 정보에 대한 어떤 조작(송수신 내용변경)이나 판단을 하지 않는다.

![self-network_2_26](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_26.png)

반면에, `데이터 링크 계층`에는 **주소 개념이 있다**.

- MAC 주소가 이 계층에 속한다.
- 따라서 데이터 링크 계층의 장비나 그 이상의 계층의 장비들은 송수신지를 특정할 수 있고,
  - 주소를 바탕으로 송수신되는 정보에 대한 조작과 판단을 할 수 있다.

이 차이점은 단순해 보여도 물리 계층과 데이터 링크 계층의 장비, 기술, 특징을 이해하는데 중요한 기반이 된다.

---

### 3.2 허브

![self-network_2_27](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_27.png)

물리 계층의 `허브(hub)`는 여러 대의 호스트를 연결하는 장치다.

- `리피터 허브(repeater hub)`라 부르기도 하고,
- 이더넷 네트워크의 허브는 `이더넷 허브(ethernet hub)`라고도 한다.

위 그림에서 커넥터를 연결할 수 있는 4개의 연결지점이 볼 수 있다.

- 이를 `포트(port)`라고 한다.
- `포트`에 호스트와 연결된 통신 매체를 연결할 수 있다.
- cf. `포트(port)`라는 용어는 다른 의미로도 사용된다.

---

#### 3.2.1 허브의 특징

사실 허브는 오늘날 인터넷 환경에서는 잘 사용되지 않는다.
그런데도 수 많은 네트워크 서적들이 허브를 설명하는 이유는 허브가 가진 2가지 특징 떄문이다.
이 특징은 중요한 네트워크 개념을 내포하고 있으며, 곧 허브의 한계와도 직결되기도 한다.

---

(1) **전달받은 신호를 다른 모든 포트로 그대로 다시 내보낸다.**

![self-network_2_28](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_28.png)

- `허브`는 물리 계층에 속한 장비고, 물리 계층에는 주소 개념이 없기에, **허브는 수신지를 특정할 수 없다**.
- 따라서 신호를 전달받으면, 어떤 조작이나 판단을 하지 않고, 송신지를 제외한 모든 포트에 그저 내보내기만 한다.
- 허브를 통해 신호를 전달받은 모든 호스트는 `데이터 링크 계층`에서 패킷의 MAC 주소를 확인하고 자신과 관련없는 주소는 폐기한다.

---

(2) **반이중 모드로 통신한다.**

![self-network_2_29](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_29.png)

`반이중(half duplex) 모드`는 마치 **1차선 도로처럼 송수신을 번갈아 가면서 하는 통신 방식**이다.

- e.g. 위 그림처럼 호스트 A가 B에게 메시지를 송신할 떄 호스트 B는 A에게 송신할 수 없다.
  - 반대의 경우도 마찬가지다. 즉, 동시에 송수신이 불가능하다.
  - 다른 쪽의 말이 끝나야지만, 이쪽에서 말할 수 있는 무전기를 떠올려보면 쉽다.

![self-network_2_30](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_30.png)

반대로, `전이중(full duplex) 모드`는 **송수신을 동시에 양방향으로 할 수 있는 통신 방식**이다. (e.g. 2차선 도로)

> 💡 리피터(repeater)
>
> - `허브` 외의 물리 계층의 대표적인 장비로 `리피터(repeater)`가 있다.
> - e.g. 매우 긴 트위스티드 페어 케이블이 있다고 가정하면,
>   - 트위스티드 페어 케이블에 흐르는 전기 신호는 전송 거리가 길어질 수록 감소하거나 왜곡될 수 있다.
> - `리피터`는 이렇게 전기 신호가 감소하거나 왜곡되는 것을 방지하기 위해 **전기 신호를 증폭시켜 주는 장비**다.
>   - 물리 계층의 장비이므로 신호에 대해 어떤 판단이나 조직을 하지 않고, 그저 신호를 증폭시키기만 한다.
>   - `허브`는 이런 리피터의 기능을 포함하는 경우가 많다.

---

#### 3.2.2 콜리전 도메인

![self-network_2_31](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_31.png)

`허브`는 `반이중 통신`을 지원한다.

- 한 호스트가 `허브`에 송신하는 동안, 다른 호스트는 송신하고 싶은 것이 있어도 기다려야 한다.
- 그런데 만일 동시에 `허브`에 신호를 송신하면, `충돌(collision, 콜리전)`이 발생한다.

![self-network_2_32](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_32.png)

`허브`에 호스트가 많이 연결되어 있을 수록, 충돌 발생 가능성이 높다.

- 불시에 다른 호스트가 `허브`로 신호를 송신할 수 있다.
- 이렇게 **충돌이 발생할 수 있는 영역**을 `콜리전 도메인(collision domain)`이라 한다.
- `허브`에 연결된 모든 호스트는 같은 `콜리전 도메인`에 속한다.

콜리전 도메인은 작으면 작을 수록 충돌 발생 가능성이 줄어들기 때문에 좋다.

- `허브`에 연결된 모든 호스트가 하나의 `콜리전`에 속하는 것은 바람직하지 않다.
- `허브`의 넓은 `콜리전 도메인`으로 인한 충돌 문제를 해결하려면,
  - `CSMA/CD 프로토콜`을 사용하거나 `스위치 장비`를 사용해야 한다.

> 💡 허브를 정리해보면,
>
> - 허브는 여러 대의 호스트를 연결할 수 있는 물리 계층 장비이다.
> - 전달받은 신호를 송신지 포트를 제외한 모든 포트로 내보내고, 반이중 모드로 통신한다.
> - 허브에 연결된 모든 호스트는 하나의 콜리전 도메인에 속하는데,
>   - 콜리전 도메인의 범위가 클 수록, 충돌 발생 가능성이 높다.

---

### 3.3 CSMA/CD

![self-network_2_33](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_33.png)

허브에서 **충돌이 발생하는 가장 근본적인 이유**는 **허브가 반이중 모드로 통신하기 때문**이다.

- e.g. 같은 허브에 연결된 A와 B가 동시에 허브에 신호를 송신하면, 위 그림과 같이 신호 충돌이 발생한다.
- 이런 충돌 문제를 해결하기 위한 프로토콜이 `CSMA/CD`이다.
  - CSMA/CD는 반이중 이더넷 네트워크에서 충돌을 방지하는 대표적인 프로토콜이다.
  - (반이중) 이더넷을 대표하는 송수신 방법이라 볼 수 있다.
- cf. 여러 호스트가 공유하는 `통신 매체(media)`에 `접근(access)`할 떄,
  - `사용 가능한 제어(control)` 방식이라는 점에서
  - `매체 접근제어(MAC; Media Access Control)` 방법의 일종이라 볼 수 있다.
- `CSMA/CD`는 Carrier Sense Multiple Access with Collision Detection의 약자다.

---

(1) `CS`는 `Carrier Sense(캐리어 감지)`를 의미

![self-network_2_34](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_34.png)

- `CSMA/CD 프로토콜`을 사용하는 반이중 이더넷 네트워크에서는
  - **메시지를 보내기 전에, 현재 네트워크상에서 전송 중인 것이 있는지를 먼저 확인**한다.
- 즉, **현재 통신 매체의 사용 가능 여부를 검사하는 것**이다.
  - 이를 `캐리어 감지(Carrier Sense)`라고 한다.
- cf. `Carrier Sense`는 엄밀히 말하면 `반송파 감지`를 의미한다.
  - `반송파 감지`는 ‘**통신 매체 상에서 흐르는 신호 감지**’라고 생각하면 된다.

---

(2) `MA`는 `Multiple Access(다중 접근)`을 의미

![self-network_2_35](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_35.png)

- `캐리어 감지`를 하는데도 2개 이상의 호스트가 부득이하게 동시에, 네트워크를 사용하려 할 떄가 있다.
- **복수의 호스트가 네트워크에 접근하려는 상황**을 `다중 접근(Multiple Access)`이라 한다.
- 이떄 충동이 발생한다.

---

(3) `CD`는 `Collision Detection(충돌 검출)`을 의미

![self-network_2_36](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_36.png)

- 충돌이 발생하면, 이를 `충돌 검출(Collision Detection)`이라 한다.
- 충돌이 감지하면, 전송이 중단되고,
  - 충돌을 검출한 호스트는 **다른 이들에게 충돌이 발생했음을 알리고자**,
  - `잼 신호(jam signal)`라는 특별한 신호를 보낸다.
  - 그리고 **임의의 시간 동안 기다린 뒤에 다시 전송**한다.

> 💡 CSMA/CD를 정리해보면,
>
> 호스트들은 메시지를 전송하기 전에
>
> 1. 현재 전송이 가능한 상태인지를 확인하고,
> 2. 다른 호스트가 전송 중이지 않을 때 메시지를 전송한다.
> 3. 만일 부득이하게 다수의 호스트가 접근하여 충돌이 발생하면 임의의 시간만큼 대기한 후에 다시 전송한다.

---

## 4. 스위치

`허브`는 **주소 개념이 없는 물리 계층 장비**다.

- 전달받은 신호를 다른 모든 포트로 내보내기만 할 뿐이다.
- 그리고 `반이중 모드`로 통신하므로, 허브에 연결된 모든 호스트가 충돌이 발생할 범위, 즉 `콜리전 도메인`에 속한다.

CSMA/CD를 통해 충돌 문제를 어느정도 완화할 수는 있지만, 더 근본적인 해결방법이 존재한다.

- 전달받은 신호를 수신지 호스트가 연결된 포트로만 내보내고, `전이중 모드`로 통신하면 된다.
- 그러면 포트별로 `콜리전 도메인`이 나누어지기에, 충돌 위험이 감소한다.
  - `CSMA/CD`를 이용할 필요도 없다.
- 이런 기능을 지원하는 네트워크 장비가 바로 데이터 링크 계층의 `스위치`이다.

`스위치`가 전달받은 신호를 원하는 포트로만 내보낼 수 있는 것은 **스위치가 MAC 주소를 학습할 수 있기 때문**이다.

- 스위치를 이용하면, 논리적으로 LAN을 분리하는 가상의 LAN, `VLAN`을 구성할 수 있는 장점도 있다.

---

### 4.1 스위치

`스위치(switch)`는 데이터 링크 계층의 네트워크 장비다.

- 2계층에서 사용해서 `L2 스위치(L2 switch)`라고도 부른다.
- 스위치의 여러 포트에는 호스트를 연결할 수 있는데, 이런 점은 허브와 유사하다.
- 다만 `스위치`는 허브와 달리, **MAC 주소를 학습해** 특정 MAC 주소를 가진 호스트에만 프레임을 전달할 수 있고,
  - `전이중 모드의 통신`을 지원한다.
- 그렇기에 스위치를 이용하면, 포트별로 `콜리전 도메인`이 나뉘고,
  - `전이중 모드`로 통신하므로, `CSMA/CD 프로토콜`이 필요하지 않다.

![self-network_2_37](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_37.png)

CSMA/CD 프로토콜의 대기 시간이 없어지면, 당연하게 성능 상의 이점이 있다.
이런 장점 덕에 스위치는 오늘날까지도 이더넷 네트워크 구성 시 자주 사용된다.

> 💡 L3 스위치, L4 스위치
>
> - 데이터 링크 계층 상위 계층에서 사용되는 L3 스위치, L4 스위치 등도 있지만,
> - 여기서는 혼동을 방지하기 위해 `스위치`라는 용어를 데이터 링크 계층의 `L2 스위치`에 한정해서 사용한다.

---

#### 4.1.1 스위치의 특징

스위치의 중요한 특징은 ‘**특정 포트와 해당 포트에 연결된 호스트의 MAC 주소와의 관계를 기억한다**’는 점이다.

- 이를 통해 원하는 호스트에만 프레임을 전달할 수 있다.
- 스위치의 이런 기능을 `MAC 주소 학습(MAC address learnning)`이라 부른다.

스위치는 MAC 주소 학습을 위해, **포트와 연결된 호스트의 MAC 주소 간의 연관 관계를 메모리에 표 형태로 기억**한다.

- 스위치의 포트와 연결된 호스트의 MAC 주소 연관 관계를 나타내는 정보를 `MAC 주소 테이블(MAC address table)`이라 부른다.

실제 스위치에 접속해보면, 다음과 같은 형태의 MAC 주소 테이블을 조회해볼 수 있다.

- MAC 주소와 연결된 포트를 볼 수 있다.

```bash
switch# show mac-address-table
VLNA.   MAC Address        Type      Age    Port
-------+------------------+--------+------+----------------
1       abcd.abcd.0123     dynamic   10     Eth1/3
1       abcd.abcd.1234     dynamic.  200.   Eth1/3
Total MAC Address: 2
```

---

### 4.2 MAC 주소 학습

MAC 주소 테이블은 어떻게 채워지고 유지될까? 그리고 스위치는 어떻게 원하는 수신지가 연결된 포트에만 프레임을 내보낼 수 있을까? 이는 스위치의 3가지 기능을 통해 이루어진다. 해당 용어를 이해하면, 스위치의 기본 작동 방식을 이해할 수 있다.

1. 플러딩
2. 포워딩과 필터링
3. 에이징

![self-network_2_38](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_38.png)

위 그림처럼 구성된 네트워크에서 `호스트 A`가 `호스트 C`로 프레임을 전송하는 상황을 가정해보면,
`호스트 A, B, C, D`는 각각 포트 1, 2, 3, 4번에 연결되어 있다.

![self-network_2_39](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_39.png)

스위치는 처음에는 `호스트 A, B, C, D`의 `MAC 주소`와 연결된 포트의 연관 관계를 알지 못한다.

- 아직 어떤 포트에 어떤 MAC 주소를 가진 호스트가 연결되어 있는지 학습하지 않았기 떄문이다.

![self-network_2_40](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_40.png)

`스위치의 MAC 주소 학습`은 프레임 내 ‘**송신지 MAC 주소**’필드를 바탕으로 이루어진다.

- `스위치`가 처음 `호스트 A`에서 프레임을 수신하면,
  - 프레임 내 ‘**송신지 MAC 주소**’정보를 바탕으로,
  - `호스트 A`의 MAC 주소와 연결된 포트를 `MAC 주소 테이블`에 저장한다.
- 하지만 여전히 `수신자 호스트 C`가 어느 포트에 연결되어 있는지는 알지 못한다.
- 이 상황에서 스위치는 마치 허브처럼 **송신지 포트를 제외한 모든 포트로 프레임을 전송**한다.
  - 이러한 스위치의 동작을 `플러딩(flooding)`이라고 부른다.
  - 그렇게 `호스트 B, C, D`는 프레임을 전달받는다.
  - 그 중에서 `호스트 B와 D`는 **자신과 관련없는 프레임을 전송받은 셈이므로 이를 폐기**한다.

![self-network_2_41](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_41.png)

한편 `호스트 C`는 `스위치`로 응답 프레임을 전송한다.

- 이 프레임의 ‘송신지 MAC 주소’ 필드에는 `호스트 C`의 MAC 주소가 명시되어 있다.
- 이를 통해 `스위치`는 `호스트 C`의 MAC 주소와 연결된 포트를 알아내어, 이 정보를 `MAC 주소 테이블`에 기록한다.
- 이제 `호스트 A와 C`의 MAC 주소와 연결된 포트를 알고 있으므로,
  - 두 호스트가 프레임을 주고받을 떄는 다른 포트로 프레임을 내보낼 필요가 없게 된다.

**전달받은 프레임을 어디로 내보내고 어디로 내보내지 않을지 결정하는 스위치의 기능**을 `필터링(filtering)`이라 한다.

- 비유하면, 프레임을 내보낼 포트만을 제외하고, 다른 모든 포트를 가리개로 가리는 것와 유사하다.
- 그리고 **프레임이 전송될 포트에 실제로 프레임을 내보내는 것**을 `포워딩(forwarding)`이라 한다.
- 위 예시에서 `호스트 A`가 `호스트 C`에게 프레임을 전송하면,
  - `스위치`는 `호스트 B, D`가 **연결된 포트로는 내보내지 않도록 필터링**하고,
  - `호스트C`가 **연결된 포트로 프레임을 포워딩**한다.

만약 MAC 주소 테이블에 등록된 특정 포트에서 일정 시간 동안 프레임을 전송받지 못했다면, 해당 항목은 삭제된다.

- 이를 `에이징(aging)`이라 한다.
- 위 예시로 볼 떄,
  - 일정시간 동안 ‘`송신지 MAC 주소`'가 `ab:cd:ab:cd:00:01` 인 프레임을 1번 포트에서 전송받지 못했다면,
  - 이 항목은 삭제된다.
- cf. `스위치`는 `MAC 주소 테이블`을 통해 MAC 주소를 학습하여 **원하는 포트로 패킷**을 `포워딩`하고,
  - **원치 않는 포트**는 `필터링`할 수 있다.

> 💡 브리지
>
> ![self-network_2_42](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_42.png)
>
> - 데이터 링크 계층의 스위치와 유사한 장비로 `브리지(bridge)` 라는 장비가 있다.
>   - cf. `브리지`는 영어로 ‘다리’라는 뜻이다.
>   - 이름에 볼 수 있듯 위 그림처럼 네트워크 영역을 구획하여 `콜리전 도메인`을 나누거나, 네트워크를 확장하는 용도로 사용된다.
> - 브리지는 위에서 설명한 스위치의 기능들도 제공한다.
>   - **MAC 주소를 학습**할 수 있고, **특정 호스트가 연결되어 있는 포트로 프레임을 포워딩하거나 필터링**할 수 있다.
> - 다만, 단일 장비로서의 브리지는 비교적 최근에 대중화된 스위치에 비해 사용 빈도가 줄어드는 추세다.
>   - 브리지를 이용한 네트워크 구획 및 확장은 스위치를 통해서도 얼마든지 가능하고,
>   - 최근 스위치의 기능은 일반적으로 브리지의 기능을 포괄할 뿐만 아니라, 더 다양하며 프레임의 처리 성능 면에서도 우수하기 때문이다.

---

### 4.3 VLAN

![self-network_2_43](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_43.png)

스위치의 또 다른 중요한 기능으로 VLAN이 있다.

- `VLAN`은 `Virtual LAN`의 줄임말로, 이름 그대로 ‘**한 대의 스위치로 가상의 LAN을 만드는 방법**’이다.
- `허브`는 **송신지 포트를 제외한 모든 포트로 신호를 내보내기**에,
  - **네트워크상에 불필요한 트래픽이 늘어날 수 밖에 없고**, 이는 **성능의 저하**로 이어진다.
- 스위치를 이용해도 마찬가지다.
  - `스위치에 연결된 호스트` 중에서도 서로 메시지를 주고받을 일이 적거나,
  - 브로드캐스트 메시지를 받을 필요가 없어서,
  - 굳이 `같은 네트워크(LAN)`에 속할 필요가 없는 호스트가 있을 수도 있다.
- 그렇다고 이들을 분리하고자, 매번 새로운 스위치 장비를 구비하는 것은 낭비이다.
  - 이떄 구성하는 것이 `VLAN`이다.

![self-network_2_44](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_44.png)

`VLAN`을 구성하면, **한 대의 물리적 스위치**라 해도, **여러 대의 스위치가 있는 논리적 단위로 LAN을 구획**할 수 있다.

- 즉, **호스트의 물리적 위치와 관계없는 논리적인 LAN을 구성할 수 있다**.
- 위 그림처럼, `VLAN`을 구성하면, `VLAN1에 속한 호스트 A, B, C, D`는 서로 동일한 LAN에 있는 것으로 인식하지만,
  - `다른 VLAN에 속한 호스트 E, F, G, H, I`는 물리적 거리와 관계없이 다른 LAN에 있는 것처럼 인식한다.
- 만약 `VLAN1에 속한 호스트`가 `VLAN2에 속한 호스트`와 통신하려고 한다면,
  - `데이터 링크 계층의 장비`가 아니라, `네트워크 계층 이상의 상위 계층 장비`가 필요하다.

![self-network_2_45](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_45.png)

한편으로 `브로드캐스트 도메인`도 달라진다.

- 가령 `한 VLAN에 속한 호스트`가 브로드캐스트를 하게되면, `다른 VLAN에 속한 호스트`에게까지는 전달되지 않는다.
- 서로 다른 네트워크로 간주하기 때문이다.

---

#### 4.3.1 포트 기반 VLAN

VLAN을 구성하는 방법을 알아보면, 가장 단순하지만 대중적인 방식으로 `포트 기반 VLAN`이 있다.

- `포트 기반 VLAN(port based VLAN)`은 **스위치의 포트가 VLAN을 결정하는 방식**이다.
- 사전에 **특정 포트에 VLAN을 할당**하고, 해당 포트에 **호스트를 연결함으로써 VLAN에 포함**시킬 수 있다.

![self-network_2_46](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_46.png)

위 그림의 보면, `호스트 A와 B`는 `VLAN2를 할당한 포트`에 연결되어 있으므로, **같은 LAN에 속한 셈**이다.

- 반면, `호스트 C`는 `VLAN3`에 속해 있으므로, `호스트 A, B`와는 **다른 LAN에 속한 셈**이다.

![self-network_2_47](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_47.png)

그런데, 사실 `한 대의 스위치`만으로 `포트 기반 VLAN`을 나누면 문제가 있다.

- `포트 수`가 부족해질 수도 있기 때문이다.
- e.g. VLAN1 호스트 4개, VLAN2 호스트 3개, VLAN3 호스트 3개를 포트가 8개인 하나의 스위치에 연결하기는 어렵다.
- 물론 위 그림처럼 `VLAN 스위치 여러 대`를 구비해, **VLAN 포트끼리 연결하여 VLAN을 확장하는 방법**도 있지만,
  - 이 또한 **포트의 낭비**이다.

이럴 떄 사용할 수 있는 방법이 `VLAN 트렁킹`이다.

- `VLAN 트렁킹(VLAN Trunking)`은 **2대 이상의 VLAN 스위치를 효율적으로 연결해 확장하는 방법**이다.
- 스위치 간의 통신을 위한 특별한 포트인 트렁크 포트(trunk port)에 VLAN 스위치를 서로 연결하는 방식이다.

> 💡 태그 포트와 액세스 포트
>
> - `트렁크 포트`는 `태그 포트(tagged port)`라고도 부른다.
> - 그리고 `트렁크 포트`가 아닌 **하나의 VLAN이 할당된 일반적인 포트**는 `액세스 포트(access port)`라고 부른다.

![self-network_2_48](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_48.png)

위 그림을 보면, `트렁크 포트`를 통해 `스위치 A`와 `스위치 B`가 연결된 것을 볼 수 있다.

- 낭비되는 포트를 최소화하는 동시에,
- **같은 스위치에 연결되어 있지 않아도, 같은 LAN에 속하게 네트워크를 구성할 수 있다**.

> 💡 트렁크 포트로 전달받은 프레임이 어떤 VLAN에 속하는지 파악하는 방법
>
> ![self-network_2_49](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_49.png)
>
> `프레임`이 `스위치 A`가 `트렁크 포트`를 타고 `스위치 B`로 넘어왔다고 가정해보자.
>
> - 그럼 `스위치 B`는 `트렁크 포트`로 전달받은 프레임이 어떤 VLAN에 속하는지 어떻게 알 수 있을까?
>   - `스위치`가 아직 학습되지 않은 MAC 주소를 포함하고 있을 경우,
>   - 일반적인 `이더넷 프레임`만으로는 알 수 없다.
> - 그래서 이런 경우 어떤 VLAN에 속하는지 식별하기 위한 정보까지 추가된 확장된 이더네 프레임을 사용한다.
> - 이를 `802.1Q 프레임`이라고 한다.
>
> ![self-network_2_50](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_50.png)
>
> 위 그림은 `802.1Q 프레임`의 간략화된 그림이다.
>
> - `이더넷 프레임` 사이에 32비트 크기의 `VLAN 태그`라는 정보가 추가된 것을 볼 수 있다.
>   - 이곳에 `VLAN을 식별하는 정보`가 포함된다.
> - `스위치 B`는 이 정보를 보고, 해당 프레임이 어떤 VLAN에 속한 프레임인지 알 수 있다.
>   - `802.1Q 프레임`은 `트렁크 포트`를 통과하여, VLAN을 식별할 수 있는 프레임인 셈이다.

---

#### 4.3.2 MAC 기반 VLAN

![self-network_2_51](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_2_51.png)

`포트 기반 VLAN` 외에도 **사전에 설정된 MAC 주소에 따라, VLAN이 결정**되는 `MAC 기반 VLAN(MAC based VLAN)`도 있다.

- 이는 포트가 VLAN을 결정하는 것이 아니라,
  - `송수신하는 프레임 속 MAC 주소`가 `호스트가 속할 VLAN을 결정`하는 방식이다.
- 위 그림처럼 `호스트 A의 MAC 주소`가 `VLAN3`에 할당되었다면,
  - 어떤 포트에 연결되든, `호스트 A`는 `VLAN3에 속한 호스트`로 동작한다.
