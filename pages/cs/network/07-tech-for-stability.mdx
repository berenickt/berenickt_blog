---
title: '07-안정성을 위한 기술'
date: 2024/04/13
---

## 1. 안정성을 위한 기술

웹 서비스를 개발했다고 가정해보자. 여러분의 목적은 최대한 많은 사용자를 모으는 것이고, 많은 사람을 끌어모았다.

- 그러다 이런 고민이 든다. : ‘사용자가 폭증하면 서버가 불안정해주고 부하가 가중된다고 들었는데, 괜찮은가?’
- 하지만 그러다고 사용자를 덜 받는 것은 적절한 해결책이 아니다.
- 즉, 안정성을 높여야 한다.
- 안전성을 수치로 표현하는 `가용성`이란 용어를 배우고,
  - 안정성을 높이기 위한 방법으로 물리적 장비나 프로그램 등을 여러 개 두는 기술인 `이중화`와 `다중화`,
  - 그리고 트래픽을 고르게 분산하는 기술인 `로드 밸런싱`에 대해 배운다.

---

### 1.1 가용성

‘네트워크가 안정적이다’, ‘서버가 불안정하다’와 같은 표현은 흔히 사용되는 표현이다.
여기서 ‘안전성’이란 용어란 무엇을 의미할까요?

- `안전성`은 ‘**특정 기능을 언제든 균일한 성능으로 수행할 수 있는 특성**’으로 정의할 수 있다.
- e.g. `안정적인 웹 서버`는 **언제든지 응답 메시지를 제공할 수 있는 서버**를 의미하며,
- e.g. `안정적인 라우터`는 **언제든지 라우팅 기능을 제공할 수 있는 라우터**를 의미한다.

`안정성`을 수치화하기 위해, 안전성의 정도를 나타내는 `가용성(availability)`, `고가용성(High Availability)`라는 용어가 있다.

- `가용성`은 ‘**컴퓨터 시스템이 특정 기능을 실제로 수행할 수 있는 시간의 비율**’을 의미한다.
  - 여기서 컴퓨터 시스템은 서버가 될 수도 있고, 네트워크가 될 수도 있으며, 프로그램이 될 수도 있다.
  - 다시 말해, `가용성`은 ‘**전체 사용 시간 중에서 정상적인 사용 시간**’을 의미한다.
- 이를 수식으로 나타내면 다음과 같다.
  - `가용성 = 업타임 / 업타임 + 다운타임`
  - **정상적인 사용 시간**을 `업타입(uptime)`, **정상적인 사용이 불가능한 시간**을 `다운타임(downtime)`으로 정의한다.

해당 **수식의 결과값이 크다는 것**은 전체 사용 시간 중에서 대부분을 사용가능하다는 말과도 같다.

- 이를 ‘**가용성이 높다**’라고 표현하며, **가용성이 높은 성질**을 `고가용성`이라고 한다.
- 고가용성은 영어로 ‘High Availability’이고, 앞 글자를 따서 `HA`라고도 줄여 부른다.
- 고가용성을 유지하는 것은 모든 웹 서비스 업체들의 대단히 중요한 목표다.

그렇다면 이 수식을 백분율로 표기했을 떄, 안정적인 수준은 몇 퍼센트일까요?

- 일반적으로 ‘안정적’이라고 평가받는 시스템은 99.999% 이상을 목표로 한다.
- 99.999%라는 수치는 ‘9가 다섯 개’라는 의미에서 `파이브 나인스`라고도 한다.
- 이 수치를 달성하면 시스팀에 정상적으로 운영되지 않는 다운타임이 대략 1년에 5.26분, 1개월로 하면 26.3초가 된다.
- 다음은 퍼센트별 다운타임을 수치로 정리한 표다.

|       가용성(%)        | 1년간 다운타임 | 한 달간 다운타임 | 한 주간 다운타임 |
| :--------------------: | :------------: | :--------------: | :--------------: |
|      90%(원 나인)      |    36.53일     |    73.05시간     |     16.8시간     |
|     99%(투 나인스)     |     3.65일     |     7.31시간     |     1.68시간     |
|         99.5%          |     1.83일     |     3.65시간     |      50.4분      |
|   99.9%(쓰리 나인스)   |     8.77일     |     43.83분      |     10.08분      |
|         99.95%         |     4.38일     |     21.92분      |      5.04분      |
|   99.99%(포 나인스)    |    52.56분     |      4.38분      |      1.01분      |
| 99.999%(파이브 나인스) |     5.26분     |      26.3초      |      6.05초      |
| 99.9999%(식스 나인스)  |    31.56초     |      2.63초      |     0.604초      |
| 99.99999%(세븐 나인스) |     3.16초     |     0.262초      |     0.0604초     |

가용성을 높이려면 다운타임을 낮춰야 한다. 그렇다면 다운타임은 어떻게 낮출 수 있을까?

- 서비스가 다운되는 원인은 다양하다.
- 과도한 트래픽으로 인해 서비스가 다운될 수 있고, 예기치 못한 소프트웨어상의 오류,
  - 하드웨어 장애가 원인일 수도 있으며, 때로는 보안 공격이나 자연재해로 인해 서비스가 다운될 수도 있다.
- 따라서 다운타임의 발생 원인을 모두 찾아 원천적으로 차단하기는 현실적으로 어렵다.

핵심은 문제가 발생하지 않도록 하는 것이 아니라, 문제가 발생하더라도 계속 가능할 수 있도록 설계하는 것이다.

- 문제가 발생하더라도 기능할 수 있는 능력을 `결함 감내(fault tolerance)`라 부른다.
- 즉, 다운타임을 낮추고 가용성을 높이기 위해서는 결함을 감내할 수 있도록 서비스나 인프라를 설계하는 것이 중요하다.

---

### 1.2 이중화

`이중화`란 말 그대로 ‘**무언가를 이중으로 두는 기술**’이다.

- 이는 결함을 감내하여 가용성을 높이기 위한 가장 기본적이고 대표적인 방법으로,
- 쉽게 말해, ‘**예비(백업)를 마련하는 방법**’이다.
- 그렇다면 무엇을 이중으로 준비할 수 있을까?

이중화할 수 있는 대상은 다양하다. 표현의 편의를 위해 ‘시스템을 이중화한다’ 또는 ‘장비를 이중화한다’고 표현하겠지만,

- 서버 컴퓨터, 네트워크 인터페이스(NIC), 스위치와 같은 물리적 장비뿐만 아니라,
  - 데이터베이스, 웹 서버 프로그램 등도 이중화할 수 있는 대상이다.
- 그리고 이중화할 수 있는 대상들은 대부분 ‘문제가 발생할 경우 시스템 전체가 중단될 수 있는 대상’이란 공통점이 있다.

![self-network_7_1](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_1.png)

방금 필자가 ‘**문제가 발생할 경우, 시스템 전체가 중단될 수 있는 대상**’이라는 표현을 썻죠?

- 이를 가리키는 용어가 `단일 장애점(SPoF; Single Point Of Failure)`이다.
- e.g. 위 그림에서 SPOF는 라우터다.
  - 라우터가 고장나면 서버로부터 제공받는 서비스 전체가 동작하지 않으니까요.
  - 짐작할 수 있듯, SPOF는 최대한 없애는 것이 좋다.
  - 즉, 가용성을 높이기 위해서는 SPOF를 이중화하는 것이 좋다.

![self-network_7_2](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_2.png)

이중화 구성에는 크게 `액티브/스탠바이(active-standby)`와 `액티브/액티브(active-active)` 2가지 방식이 있다.

- `액티브/스탠바이`는 **한 시스템은 가동**하고, **다른 시스템은 백업 용도로 대기 상태**(스탠바이)로 두는 이중화 구성 방식
  - `액티브`는 **가동 상태**를 의미
  - `스탠바이`는 **액티브의 백업으로서 대기하는 상태**를 의미
- `액티브/액티브`는 **두 시스템 모두를 가동 상태로** 두는 구성 방식

`액티브/스탠바이`로 구성하면,

- `액티브 상태`인 시스템에 문제가 발생할 경우, `스탠바이 시스템`이 자동으로 `액티브 시스템`을 대신하여 동작한다.
- 이는 안전한 구성 방식이지만, 하나의 장비를 사용할 떄에 비해 **성능 상의 큰 변화를 기대하기는 어렵다**.
- 두 장비가 **동시에 가동되지 않고, 한 번에 하나만 가동되기 떄문**이다.

> 💡 cf. 액티브 시스템에 문제가 생겼을 경우,
> 예비된 스탠바이 시스템으로 자동 전환되는 기능을 `페일오버(failover)`라고 한다.

![self-network_7_3](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_3.png)

`액티브/액티브`로 구성하면,

- 부하를 분산시킬 수 있고, 두 시스템이 함께 가동되므로 성능상의 이점도 있다.
- 다만 한 시스템에 문제가 발생하면,
  - **순간적으로 다른 시스템에 부하가 급증할 수 있으며, 이로 인해 추가적인 문제가 발생**할 수 있다.
- 이중화 기술은 더욱 확장될 수 있는데, `이중화`를 ‘**무언가를 이중으로 두는 기술**’이라 설명했듯,
  - 더 일반적인 개념으로 ‘**무언가를 여러 개 두는 기술**’이 `다중화`라고 한다.
- 위 그림처럼 3개 이상의 장비를 구성하면,
  - 즉 다중화하면 당연히 이중화된 구성에 비해 더욱 안정적인 운영이 가능하다.

![self-network_7_4](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_4.png)

이중화/다중화의 사례로 `티밍(teaming)`과 `본딩(bonding)`이 있다.

- 전자는 주로 윈도우, 후자는 주로 리눅스에서 사용되는 용어다.
- 이 두 기술은 여러 개의 `네트워크 인터페이스(NIC)`를 이중화/다중화하여,
  - 마치 더 뛰어나고 안정적인 성능을 보유한 **하나의 인터페이스처럼 보이게 하는 기술**이다.
- 위 화면은 1Gbps 속도를 지원하는 인터페이스 3개를 티밍하는 모습을 나타낸 화면이다.
  - 티밍 시에 `액티브/액티브`로 구성할지, `액티브/스탠바이`로 구성할지 선택할 수 있다.
- 모든 인터페이스를 `액티브 상태`로 구성할 경우,
  - 마치 **하나의 3Gbps 인터페이스를 사용하는 것과 같은 효과**를 얻을 수 있다.

---

### 1.3 로드 밸런싱

고가용성을 요구하는 호스트는 클라이언트보다는 일반적으로 서버다.

- 그러나 서버의 입장에서 가용성을 보면, 서버를 다중화했더라도 아직 해결해야 할 문제가 남아있다.
  - 바로 `트래픽 분배`다.
  - `트래픽`은 **서버의 가용성에 큰 영향을 끼치는 요소**다.
- `트래픽(traffic)`의 정의는 ‘**주어진 시점에 네트워크를 경유한 데이터의 양**’이지만,
  - 일반적인 트래픽 측정은 노드에서 이루어지므로 일반적으로 표현하면,
  - ‘**주어진 시점에 특정 노드를 경유한 패킷의 양**’을 `트래픽`이라고 볼 수 있다.

![self-network_7_5](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_5.png)

서버는 과도한 트래픽이 몰리면 온갖 문제가 발생할 수 있다.

- 높은 부하로 인해 CPU는 발열이 심해지고, 메모리 공간은 수많은 트래픽 내용을 저장하기에 부족해질 수 있다.
- 제한된 대역폭과 병목 현상으로 인해 응답이 느려지거나 일부 요청에 대한 응답이 누락될 수도 있으며,
  - 프로그램의 일관성이 손상될 수도 있다.
  - 요컨대 과도한 트래픽은 서버의 가용성을 떨어뜨린다.
- 이는 서버를 다중화해도 마찬가지다.
  - 특정 서버에만 트래픽이 몰릴 경우 가용성이 떨어질 수 있다.
  - 따라서 서버를 다중화했더라도, 트래픽을 고르게 분산해야 가용성이 높아진다.

트래픽의 고른 분배를 위해 사용되는 기술이 `로드 밸런싱(load balancing)`이다.

- 로드 밸런싱은 부하를 의미하는 단어인 `로드(load)`와 균형 유지를 나타내는 단어인 `밸런싱(balancing)`의 합성어다.
- 로드 밸런싱은 `로드 밸런서(load balancer)`에 의해 수행된다.
- 로드 밸런서는 ‘L4 스위치’, ‘L7. 스위치’라 불리는 네트워크 장비로도 수행할 수 있지만,
  - 로드 밸런싱 기능을 제공하는 소프트웨어를 설치하면, 일반 호스트도 로드 밸런서도 사용할 수 있다.
- 대표적인 소프트웨어로 HAProxy, Envoy 등이 있다.
- 대표적인 웹 서버 소프트웨어인 Nginx에도 로드 밸런싱 기능이 내포되어 있다.

![self-network_7_6](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_6.png)

`로드 밸런서`는 일반적으로 위 그림처럼 이중화나 다중화된 서버와 클라이언트 사이에 위치한다.

- `클라이언트`들은 `로드 밸런서`에 요청을 보내고, `로드 밸런서`는 해당 요청을 각 서버에 균등하게 분배한다.

> 💡 L4 스위치는 주로 IP 주소와 포트 번호와 같은 전송 계층까지의 정보를 바탕으로 로드 밸런싱을 수행한다.
>
> - 반면, L7 스위치는 URI, HTTP 메시지 일부, 쿠키 등 응용 계층의 정보까지 활용해 로드 밸런싱을 수행할 수 있다.

> 💡 서버의 상태를 검사하는 헬스 체크
>
> ![self-network_7_7](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_7.png)
>
> 다중화된 서버 환경에서 어떤 서버에 문제가 생긴다면, 다른 서버들이 이를 빠르게 감지할 수 있어야 한다.
>
> - 그래서 다중화된 서버 환경에서는 현재 문제가 있는 서버는 없는지,
>   - **현재 요청에 대해 올바른 응답을 할 수 있는 상태인지를 주기적으로 검사하는 경우**가 많다.
>   - 이러한 검사를 `헬스 체크(health check)`라고 한다.
>   - 서버들의 건강 상태를 주기적으로 모니터링하고 체크하는 것이죠.
> - `헬스 체크`는 위 그림과 같이 주로 로드 밸런서에 의해 이루어지는 경우가 많으며,
>   - HTTP, ICMP 등 다양한 프로토콜을 활용할 수 있다.
> - cf. 로드 밸런서가 주도하는 `헬스 체크` 외에도
>   - 서버 간에 `하트비트(heartbeat)`라는 **메시지를 주기적으로 주고받는 방법**도 있다.
>   - **서버끼리 주기적으로 하트비트 메시지를 주고받다가, 신호가 끊겼을 떄 문제 발생을 감지하는 방법**이다.

로드 밸런서가 요청을 전달할 수 있는 서버가 여러 개가 있을 경우, 어떤 서버에 요청을 전달해야 할까요?

- 어떤 서버를 선택해야 부하가 고르게 분배될까요?
- 부하가 균등하게 분산되도록 부하 대상을 선택하는 방법을 `로드 밸런싱 알고리즘`이라 부른다.

![self-network_7_8](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_8.png)

`로드 밸런싱 알고리즘`의 종류는 다양하며 로드 밸런서마다 이해하는 알고리즘에는 차이가 있을 수 있다.

- 대표 알고리즘은 위 그림처럼 단순히 서버를 돌아가며 부하를 전달하는 `라운드 로빈(round robin)` 알고리즘이 있고,
- 연결이 적은 서버부터 우선적으로 부하를 전달하는 `최소 연결(least connection)` 알고리즘이 있다.
- 때로는 단순히 무작위로 고르기도 하고,
  - `해시(hash)`라는 자료구조를 이용하기도 하고, 응답 시간이 가장 짧은 서버를 선택하기도 한다.

![self-network_7_9](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_9.png)

`라운드 로빈 알고리즘`이나 `최소 연결 알고리즘`에서는 **서버마다 가중치를 부여**할 수 있다.

- 이는 알고리즘에 따라 동작하되, **가중치가 높은 서버가 더 많이 선택되어 더 많은 부하를 받도록 하는 것**이다.
- 이렇게 가중치가 부여된 알고리즘은 각각 `가중치 라운드 로빈(weight round robin)` 알고리즘과
  - `가중치 최소 연결(weight least connection)` 알고리즘이다.
- 위 그림은 가중치 라운드 로빈 알고리즘의 예시다.
  - 서버 1에는 가중치가 5, 서버 2에는 가중치가 1로 부여되어 있다.
  - 서버 1, 2에 클라이언트 1~6의 요청 부하를 분산할 경우,
    - 서버를 돌아가며 선택하되 서버1에 5배 많은 부하를 전달한다.
  - 서버 간 성능이 다른 경우에는 주로 이렇게 가중치가 적용된 알고리즘이 사용된다.

---

### 1.4 포워드 프록시와 리버스 프록시

![self-network_7_10](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_10.png)

처음 네트워크를 학습할 떄는 단순화를 위해 클라이언트와 서버가 나란히 붙어 있는 것처럼 서술하는 경우가 많지만,

- 실제로는 클라이언트와 서버 사이에는 수많은 서버들이 존재할 수 있다.
- 이떄 `클라이언트`가 최종적으로 메시지를 주고받는 대상(서버),
  - 다시 말해, 자원을 생성하고 클라이언트에게 권한있는 응답을 보낼 수 있는 HTTP 서버를 `오리진 서버(origin server)`라고 한다.
- 즉, 클라이언트와 오리진 서버 사이에는 많은 중간 서버가 있을 수 있다.
- 클라이언트와 중간 서버, 그리고 다중화된 오리진 서버는 위 그림과 같이 표현할 수 있다.

> 💡 이때, `인바운드(inbound)` 메시지는 오리진 서버를 향하는 메시지를 의미하고,
> `아웃바운드(outbound)` 메시지는 클라이언트를 향하는 메시지를 의미한다.

대표적인 HTTP 중간 서버의 유형으로 `프록시`와 `게이트웨이`가 있다.

- `프록시`는 `포워드 프록시`, `게이트웨이`를 `리버스 프록시`라고도 부른다.
- cf. `프록시`는 `게이트웨이`와 다른 개념이지만 혼용되어 사용되거나 모호하게 정의되는 경우가 많다.

명확한 정의를 위해 인터넷 표준 문서 정의를 알아보면,

> 💡 RFC 9110
>
> ![self-network_7_11](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_11.png)
>
> - A "proxy" is a message-forwarding agent that is **chosen by the clinet**, ...
>   - 프록시(proxy)는 **클라이언트가 선택한** 메시지 전달 대리자이다.
> - 핵심은 색칠된 부분으로, 어떤 프록시를 언제 어떻게 사용할 지는 클라이언트가 선택한다.
> - 따라서 일반적으로 `프록시`는 위 그림과 같은 구성하에 `오리진 서버`보다 `클라이언트`와 더 가까이에 위치해 있다.
>   - `프록시`는 주로 캐시 저장, 클라이언트 암호화 및 접근 제한 등의 기능을 제공한다.

`게이트웨이`는 일반적으로 ‘**네트워크 간의 통신을 가능케 하는 입구 역할을 하는 하드웨어 혹은 소프트웨어**’를 의미한다.

- 하지만 ‘HTTP 중간 서버’라는 맥락에서 게이트웨이는 다음과 같이 정의된다.

> 💡 게이트웨이
>
> ![self-network_7_12](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_12.png)
>
> - A “gateway” (a.k.a “reverse proxy”) is an intermediary that **acts as an origin server** for the outbound connection but translates received requests and forwards them inbound to another server or servers.
>   - 게이트웨이(gateway, 리버스 프록시)는 아웃바운드 연결에 대해 **오리진 서버 역할**을 하지만,
>   - 수신된 요청을 변환하여 다른 인바운드 서버(들)로 전달하는 중개자 역할을 한다.
> - 이번에도 색칠된 부분을 보면, `게이트웨이`는 네트워크 외부에서 보면 `오리진 서버`와 같이 보인다.
>   - 하지만 게이트웨이에 요청을 보내면, 오리진 서버에게 요청을 전달하게 된다.
>   - 따라서 일반적으로 게이트웨이는 위 그림과 같은 구성 하에 오리진 서버(들)에 더 가까이 위치한다.
>   - 게이트웨이도 캐시를 저장할 수 있고, 로드 밸런서도 동작할 수 있다.

`다중화된 오리진 서버들의 네트워크`를 ‘**오리진 서버들이 사는 대저택**’에 비유한다면,

- `프록시`는 `클라이언트들`을 대신해 **대저택에 심부름을 가는 심부름꾼**,
- `게이트웨이`는 **대저택을 지키는 경비**에 비유하 수 있다.

---

## 2. 안전성을 위한 기술

멀리 떨어진 컴퓨터와 통신할 떄 평문으로 메시지를 주고받아도 괜찮을까요?

- 민감한 정보를 주고받을 떄는 그래서는 안된다.
- 제 3자가 여러분이 주고받는 메시지를 훔쳐보거나 메시지를 가로채 변조할 수 있기 때문이다.
- 그래서 암호화가 필요하다.

![self-network_7_13](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_13.png)

`암호화(encryption)`는 **원문 데이터를 알아볼 수 없는 형태로 변경하는 것**을 의미한다.

- 반대로 `복호화`란 **암호화된 데이터를 원문 데이터로 되돌리는 과정**을 말한다.
- `암호화`와 `복호화`는 비단 안전한 데이터 송수신뿐만 아니라 인증서 기반의 검증도 가능하게 한다.

---

### 2.1 암호와 인증서

먼저 암호화와 복호화의 핵심은 `키(key)`다.

- 소중히 보호해야 하는 물건을 자물쇠로 잠가 놓는 것처럼,
- 컴퓨터 세상에도 소중히 보호해야 할 데이터를 `키(key)`로 암호화할 수 있다.

---

#### 2.1.1 대칭 키 암호화 방식과 공개 키 암호화 방식

![self-network_7_14](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_14.png)

`키(key)`는 자물쇠의 영문 표현이지만, 컴퓨터 보안에서 사용되는 키는 언뜻 보면, 무작위해보이는 문자열처럼 생겼다.

- `키`와 `원문 데이터에 수학적 연산 과정`을 거치면 `암호문`이 생성된다.
  - 이 수학적 연산 과정을 `암호화 알고리즘`이라 부른다.
- 그리고 암호문을 수신자 측에서 복호화하면, 원문 메시지를 얻을 수 있다.
- 당연하게도 복호화하지 않은 암호문은 제 3자가 몰래 본다 해도 그 의미를 알 수 없다.

주고받는 데이터를 암호화하고 복호화하는 방법에는 `대칭 키 암호화`와 `비대칭 키 암호화`라는 2가지 방식이 있다.

> cf. `비대칭 키 암호화`는 `공개 키 암호화`라고도 부른다.

![self-network_7_15](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_15.png)

먼저 `대칭 키 암호화(symmetric key cryptography)` 방식을 살펴보면,

- `대칭 키 암호화 방식`에서는 **암호화와 복호화에 동일한 키를 사용**한다.
- 다시 말해, 메시지를 암호화할 떄 사용하는 키와 복호화할 떄 사용하는 키가 동일하다.
- 위 그림은 A와 B가 대칭 키 암호로 메시지를 주고받는 과정을 나타낸 그림이다.
- 데칼코마니처럼 두 호스트가 메시지를 같은 키로 암호화 및 복호화를 수행하고 있죠?
  - 그래서 `대칭 키`라는 이름이 붙은 것이다.

![self-network_7_16](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_16.png)

하지만 `대칭 키 암호화 방식`에는 한 가지 문제가 있다.

- 바로 **상대방에게 안전하게 키를 전달하기가 어렵다**는 점이다.
- `대칭 키 암호화 방식`은 **암호화와 복호화에 동일한 키를 사용하므로 키가 유출되면 큰 문제가 발생**한다.
- 지금까지의 암호화 통신이 모두 무용지물이 될 수도 있다.
- 그렇기에 상대방에게 키를 안전하게 전달하는 방법이 필요하다.

애초에 암호화를 사용하는 목적 자체가 ‘제 3자의 도청과 변조를 피해 상대방에게 안전하게 정보를 전달하는 것’이다.

- 만약 상대방에게 키를 안전하게 전달할 수 있는 방법이 있다면,
- 그 방법으로 메시지를 주고받으면 됐지, 굳이 암호화할 필요가 없을 것이다.

![self-network_7_17](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_17.png)

그래서 등장한 것이 `공개 키 암호화(public key cryptograhpy)` 방식이다.

- `비대칭 키 암호화(asymmetric key cryptography)`라고도 부른다.
- 암호화와 복호화에 단일한 키를 사용했던 `대칭 키 암호`와는 달리,
  - `공개 키 암호 방식`에서는 **암호화를 위한 키와 복호화를 위한 키가 다르다**.
- 한 키로 `암호화`했다면, 다른 키로 `복호화`할 수 있다.
  - 이 한 쌍의 키를 `공개 키(public key)`와 `개인 키(private key)`라 부른다.
  - 그래서 `비대칭 키 암호화`라는 이름이 붙었다.
- cf. 한 키로 암호화하고 다른 키로 복호화가 가능하다 해도, **한 키로 다른 키를 유추할 수 없다**.
  - 다시 말해, `공개 키`만으로는 `개인 키`를 유추할 수 없고, 반대로 `개인 키`만으로 `공개 키`를 유추할 수도 없다.

`공개 키`로 암호화하고 `개인 키`로 복호화할 수 있다면, `공개 키`는 이름처럼 **누구에게나 공개해도 무방**하다.

- 암호화만을 위해 사용되었기 때문에, `공개 키`를 안다고 해서 원문 메시지를 유추할 수 있는 것은 아니다.
- 반면에, `개인 키` 만큼은 **절대로 유출되지 않도록 보안을 유지**해야겠죠.

![self-network_7_18](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_18.png)

e.g. A가 B에게 ‘안녕, 나는 A야’라는 문자열을 안전하게 전송하려고 한다면, 위와 같은 과정을 거친다.

- 일단 A가 B의 `공개 키`를 요청하고, B는 A에게 `공개 키`를 전달한다.
- 앞서 설명했듯, `공개 키`는 누구에게나 공개해도 무방하므로, 그냥 전송해도 된다.

A는 전달받은 B의 `공개 키`로 메시지를 암호화한 뒤, 그 암호문을 B에게 전송한다.

- 암호문이기에 제 3자가 메시지를 봐도 이를 이해할 수 없다.
- 반면, B는 `개인 키`가 있으므로sda 암호를 복호화해서 ‘안녕, 나는 A야’라는 문자열을 확인할 수 있다.

반대로, B가 A에게 메시지를 안전하게 보내고 싶을 떄는 동일한 과정을 거친다.

- A는 자신의 공개 키를 B에게 전달하고, B는 A의 공개 키로 메시지를 암호화한 뒤 A에게 전송한다.
- A는 개인 키로 암호를 복호화해서 B가 보낸 메시지를 확인한다.

`대칭 키 암호화 방식`과 `공개 키 암호화 방식`은 각각 장단점이 있다.

- `대칭 키 암호화`는 키를 안전하게 전송하기 어렵지만, **적은 부하 덕분에 암호화 및 복호화를 빠르게 수행**할수 있다.
- `공개 키 암호화`는 암호화 및 복호화에 시간과 부하가 상대적으로 많이 들지만, **키를 안전하게 공유**할 수 있다.

![self-network_7_19](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_19.png)

이런 장단점을 고려해 `대칭 키 암호화 방식`과 `공개 키 암호화 방식`을 함께 사용하는 경우가 많다.

- e.g. `대칭 키(세션 키)`를 상대에게 안전하게 전달하기 위해 `공개 키`로 `대칭 키(세션 키)`를 암호화하고,
  - `개인 키`로 암호화된 `대칭 키(세션 키)`를 복호화할수 있다.
- 이렇게 하면 **대칭 키를 안전하게 공유**하면서, **공유한 대칭 키를 이용해 빠르게 암호화/복호화를 수행**할 수 있다.
  - cf. 이런 방식으로 활용하는 대칭 키를 `세션 키(session key)`라고 부른다.

---

#### 2.1.2 인증서와 디지털 서명

`인증서(certificate)`는 네트워크뿐만 아니라 일상 생활에서도 자주 사용되는 용어다. 말 그대로 무엇인가를 증명하기 위한 문서를 의미한다.

![self-network_7_20](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_20.png)

네트워크(인터넷)에서 사용되는 ‘**인증서**’라는 용어는 일반적으로 `공개 키 인증서`를 말한다.

- `공개키 인증서(public key certificate)`란 **공개 키와 공개 키의 유효성을 입증하기 위한 전자 문서**다.
- e.g. 여러분이 컴퓨터와 웹 서버가 공개 키 암호화 방식으로 통신한다고 가정하면,
  - 여러분의 컴퓨터는 웹 서버로부터 공개 키를 전달받게 된다.
- 이떄 여러분이 전달받은 공개 키가 절말 신뢰할 수 있는지, 전송 도중에 조작되지 않았는지 확신할수 있을까요?
  - 단순히 공개 키 하나만 전달받는다면 확신할 수 없다.
- 그래서 `웹 서버`는 공개 키뿐만 아니라 누가 생성했는지, 조작되지는 않았는지,
  - **유효 기간은 언제까지인지 등의 내용을 포함한 인증서를 전송**한다.
- 외울 필요는 없지만, ‘**공개 키가 포함되어 있다**’는 점은 기억해두세요.

이러한 인증서는 `인증 기관(CA; Certification Authority)`이라는 제 3의 기관에서 발급한다.

- `인증 기관`은 인증서의 발급, 검증, 저장과 같은 역할을 수행할 수 있는 공인 기관이다.
  - 일반적으로는 CA라고 줄여서 부른다.
- 전 세계적으로 다양한 CA들이 존재하며, 대표적으로 IdenTrust, DigiCert, GlobalSign 등이 있다.

![self-network_7_21](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_21.png)

CA가 발급한 인증서에는 ‘이 공개 키 인증서는 진짜야, 내가 보증할게’라는 내용을 담은 `서명값(signature)`이 있다.

- 클라이언트는 이 `서명값`을 바탕으로 인증서를 검증할 수 있다.

![self-network_7_22](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_22.png)

`서명값`은 (1) 인증서 내용에 대한 해시 값을 (2) CA의 개인 키로 암호화하는 방식으로 만들어 진다.

- CA는 이렇게 얻어낸 정보를 `서명값`으로 삼아 클라이언트에게 인증서와 함께 전송한다.
- cf. (1)의 결과인 ‘인증서 내용에 대한 해시 값’을 `지문(fingerpoint)`이라 한다.

> 💡 해시 값
>
> 앞의 (1)번에서 해시 값이라는 새로운 용어가 등장했죠? `해시 값`은 **해시 함수를 적용시킨 결과값을 의미**한다.
>
> - 그리고 `해시 함수`란 ‘**임의의 길이의 데이터를 고정된 길이의 데이터로 변환해주는 함수**’를 의미한다.
> - 이 함수를 적용시키면 일정한 길이의 데이터가 생성되는 것이죠.
> - 대표적인 해시 함수로 MD5, SHA-1, SHA-2(SHA-256, SHA-384, SHA-512) 등이 있다.
>
> 해시 함수는 입력 데이터가 조금 달라져도 완전히 다른 결과가 나온다는 특징이 있다.
>
> - e.g. ‘he’라는 단어에 대해 특정 해시 함수를 적용시킨 해시 값은
>   - 30F088EA6673877C2E2C1EDBE7513FF90EDA9A6F다.
>   - 그런데 여기서 단 한글자만 바꾼 ‘hi’의 해시 값은
>   - C22B5F91783426009428D6F51B2C5AF4C9BDE6A42다.
>   - 완전히 다른 값이 되버리죠.
> - 해시 함수와 그에 따른 해시 값은 입력값의 변화에 매우 민감하므로, 주로 데이터 변조 여부를 검사하는데 사용된다.
>
> 어떤 데이터를 송신할 떄, ‘**보내고자 하는 데이터**’와 더불어 ‘**그 데이터에 대해 특정 해시 함수를 적용시킨 해시 값**’을 같이 전송한다고 가정해보면,
>
> - `수신자`가 전달받은 데이터에 대한 **해시 값을 직접 계산**한 뒤,
> - **계산 결과를 전달받은 해시 값과 비교**했을 떄,
> - **같은 값이 도출된다면**, **데이터 전송 도중 변조되거나 소실되지 않았다고 판단**할 수 있다.

![self-network_7_23](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_23.png)

여러분이 위 그림처럼 웹 브라우저를 통해 서버로부터 서명 값이 붙은 인증서를 전달받았다고 가정해보면,

- 인증서 검증을 위해 가장 먼저 할 일은 `서명값과 인증서를 분리하는 것`이다. (그림 속 1번)
  - `서명 값`은 ‘**인증서 내용에 대한 해시 값**’을 **CA의 개인 키로 암호화한 것**이었죠.
- `CA의 공개 키`는 공개되어 있기에, `서명 값`은 `CA의 공개 키`로 복호화할 수 있다.
  - 서명 값은 `CA의 공개 키`로 복호화하면, ‘**인증서 내용에 대한 해시 값**’을 얻을 수 있겠죠? (그림 속 2번)
- 다음으로 인증서 데이터에 대한 해시 값을 직접 구한 뒤(그림 속 3번), 이를 복호화한 값과 비교한다. (그림 속 4번)

만일 값이 일치한다면, 전달받은 인증서는 확실히 `CA의 개인 키`로 만들어졌다고 보장할 수 있습니다.

- `CA의 공개 키`로 `복호화`가 가능하다는 뜻이니까요.
- 따라서 인증서에 포함된 공개 키를 안심하고, 사용할 수 있습니다.
- **개인 키로 암호화된 메시지를 공개 키로 복호화함**으로써,
  - **신원을 증명**하는 이런 절차를 `디지털 서명(digital signature)`이라 부른다.

---

### 2.2 HTTPS: SSL과 TLS

지금까지 `대칭 키 암호화`와 `공개 키 암호화 방식`, 그리고 `공개 키 인증서`를 학습했다.

- 이를 기반으로 동작하는 프로토콜로 `SSL(Secure Sockets Layer)`, `TLS(Transport Layer Security)`가 있다.
- `SSL`과 `TLS`는 **인증과 암호화를 수행하는 프로토콜**이며, `TLS`는 **SSL을 계승한 프로토콜**이다.
- 초기 SSL 2.0과 SSL 3.0을 거쳐 TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3이 순차적으로 출시되었다.
  - cf. SSL 1.0은 출시되지 않았다.
- 따라서 SSL과 TLS의 작동 과정은 사용되는 암호 알고리즘과 버전에 따라 세부적인 차이가 있을 수 있으나,
  - 큰 틀에서 보면 유사하다.

![self-network_7_24](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_24.png)

`SSL/TLS`를 사용하는 대표적인 프로토콜은 `HTTPS(HTTP over TLS)`이다.

- HTTPS는 HTTP 메시지의 안전한 송수신을 위해 개발된 프로토콜이다.
- 웹 브라우저를사용해 웹 서핑을 하다보면, 위 그림에 있는 것처럼 도메인 네임 좌측의 자물쇠 모양을 볼 수 있다.
- 이는 **해당 사이트가 HTTPS를 사용한다**는 의미로,
  - ‘**해당 웹 사이트와 여러분의 브라우저 간에 SSL/TLS 기반 암호화 통신이 이뤄진다**’는 점을 시사한다.

![self-network_7_25](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_25.png)

오늘날 주로 사용되는 `TLS 1.3`을 기반으로 HTTPS가 어떻게 동작하는지 간략하게 알아봅시다.
HTTPS 메시지는 크게 다음과 같은 3단계를 거쳐 송수신된다.

1. TCP 3-way-handshake
2. TLS handshake
3. 암호화된 메시지 송수신

첫 번째 단계는 4장에서 학습했다. TCP 연결을 수립하기 위해 **두 호스트가 각각 SYN, SYN+ACK, ACK 플래그가 설정된 TCP 세그먼트를 주고받는 것**이 `3-way-handshake`이다.

![self-network_7_26](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_26.png)

두 번쨰 단계는 `TLS handshake`로 위 그림은 `TLS 1.3 handshake` 과정의 주요 메시지를 나타낸다.

- `클라이언트`가 처음으로 서버에게 요청을 보내고, 인증서를 응답받는 상황을 가정합니다.
- `TLS`는 암호학에 대한 기반 지식을 요하기 때문에, 처음부터 모든 메시지와 의미를 외울 필요는 없다.
- `TLS handshake`의 핵심은 2가지다.
  - 하나는 **암호화 통신을 위한 키를 교환한다**는 점이고,
  - 또 하나는 **인증서 송수신과 검증이 이루어진다**는 점이다.

![self-network_7_27](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_27.png)

굵은 글자로 표기한 메시지를 위주로 보면, 가장 먼저 `클라이언트`는 **ClientHello 메시지를 보낸다**.

- 이 메시지는 **암호화된 통신을 위해 서로 맞춰 봐야 할 정보들을 제시하는 메시지**다.
  - 지원되는 TLS 버전, 사용 가능한 암호화 방식과 해시 함수,
  - 키를 만들기 위해 사용할 클라이언트의 난수 등이 포함되어 있다.
- 이떄, ‘**사용 가능한 암호화 방식과 해시 함수**’를 담은 정보를 `암호 스위트(cipher suite)`라고 한다.
- 위 쪽 그림과 같이 생긴 정보다.

![self-network_7_28](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_28.png)

`서버`는 ClientHello 메시지에 대한 응답으로 **ServerHello 메시지를 전송**한다.

- `ClientHello 메시지`가 **암호화 이전에 맞춰 봐야할 정보들을 제시하는 메시지**라면,
  - `ServerHello 메시지`는 **제시된 정보들을 선택하는 메시지**다.
- 따라서 이 메시지에는 선택된 TLS 버전, 암호 스위트 등의 정보, 키를 만들기 위해 사용할 서버의 난수 등이 포함되어 있다.
- `ClientHello 메시지`와 `ServerHello 메시지`를 주고받으면,
  - 암호화된 통신을 위해 사전협의해야 할 정보들이 결정된다.
- 이렇게 결정된 정보를 토대로 `서버`와 `클라이언트`는 **암호화에 사용할 키를 만들어낼 수 있다**.
  - 이것이 `TLS 핸드셰이크`에서의 키 교환이다.
- 이 단계 이후부터 `클라이언트`와 `서버`는 **키로 암호화된 암호문을 주고받을 수 있게 된다**.

![self-network_7_29](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_29.png)

또 서버는 `Certificate 메시지`와 `CertificateVerify 메시지`를 전송한다.

- 이는 각각 인증서와 검증을 위한 `디지털 서명`을 의미한다.
- `클라이언트`는 이 메시지를 토대로 `서버의 공개 키`를 검증하게 된다.
- 이어서 `서버`와 `클라이언트`는 `TLS 핸드셰이크`의 마지막을 의미하는 `Finished 메시지`를 주고 받는다.

이제 `TLS 핸드셰이크`를 통해 얻어낸 키를 기반으로 암호화된 데이터를 주고받으면 된다.
cf. 위 그림처럼 `TLS 1.3`에서는 `Finished 메시지`와 함께 `암호화된 메시지(Application Data)`를 전송할 수 있다.

---

## 3. 무선 네트워크

![self-network_7_30](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_30.png)

카페에 가서 주변을 둘러보면, 많은 사람이 노트북이나 스마트폰으로 인터넷을 사용하고 있지만,

- 카페의 공유기나 라우터에 직접 유선으로 연결된 기기는 없다.
- 모든 사람이 무선 네트워크를 이용하고 있다는 증거죠.

이처럼 많은 사람들이 유선 연결 네트워크보다는 무선 연결 네트워크에 더 익숙할 것이다.

- 유선 네트워크와 관련된 연결 매체와 표준, 네트워크 장비가 있듯이,
- 무선 네트워크에도 `전파`라는 연결 매채, `802.11`이라는 표준, 그에 기반한 `Wi-Fi`라는 기술, `AP`라는 장비가 있다.

---

### 3.1 전파와 주파수

무선 네트워크를 이해하기 위해서는 먼저 무선 통신의 기반이 되는 `전파(radio wave)`를 간략하게나마 이해해야 한다.

- `전파`는 **약 3kHz부터 3THz 사이의 진동수를 갖는 전자기파**이다.
- 쉽게 말해, ‘**눈에 보이지 않는 전자기파의 일종**’정도로 정의할 수 있다.

![self-network_7_31](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_31.png)

TV, 라디오, 무전기, 노트북, 스마트폰처럼 수많은 무선 통신 기기가 전파를 이용해 통신한다.

- 이러한 기기들이 주고받는 정보들은 눈에 보이지 않는 전파의 형태를 띠고 있고,
  - 지금 이 순간에도 우리 주변 공간에 흐르고 있다고 볼 수 있다.
- 무선 통신 기기가 사용하는 전파는 대부분 인위적으로 생성되고 관측되지만,
  - 사실 전파는 자연적으로도 생성되고 관측된다.
- 번개에서도 전파가 생성되고, 태양에서도 전파가 발생하며, 우주에서도 전파가 존재한다.

![self-network_7_32](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_32.png)

많은 기기가 전파를 통해 통신한다면, 서로 다른 전파 신호가 같은 공간에 혼재할 수도 있겠죠?

- 이런 상황을 위해 서로 다른 전파 신호를 구분할 수 있는 방법이 필요하다.
- 그래서 통신에서 사용되는 전파에는 ‘주파수 대역’이 미리 정해져 있다.

어떤 주파수 대역을 어떤 용도로 사용할지는 나라마다 다르다.

- 2020년을 기준으로 대한민국에서는 주파수 대역을 위 사진과 같이 분배된다. (암기할 필요는 없다.)
- 방송용 주파수, 위성 통신용 주파수, 항공/해양 통신을 위한 주파수 등으로 나누어져 있는 것을 알 수 있다.
- cf. https://ballpen.blog/wp-content/uploads/2021/08/frequency_tbl_01.pdf
- cf. [전파누리](https://spectrummap.kr/index.do)

![self-network_7_33](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_33.png)

전파는 자연적으로도 발생할 수 있다.

- 번개, 태양의 활동 등으로 인해 발생한 전파의 주파수가 우연히 할당된 주파수 대역과 겹친다면,
  - 통신 중 잡음이 발생할 수 있다.
- 번개가 심하게 치는 날에 라디오를 들을 떄,
  - ‘지직’ 소리와 함께 음질이 떨어지는 일이 빈번하게 발생하는 것은 이러한 이유 때문이다.

---

### 3.2 와이파이와 802.11

이제 무선 통신 네트워크에서 사용되는 주파수를 알아보면,

- 2장에서 ‘오늘날 LAN 환경에서의 유선 통신은 IEEE 802.3으로 표준화되어 있다’고 했던 것을 기억하나요?
- IEEE 802.3의 다양한 표준들은 802.3u 혹은 802.3ab처럼,
  - 숫자 802.3 뒤에 버전을 나타내는 알파벳으로 표현한다고 했다.
- 이와 유사하게 오늘날 LAN 환경에서의 무선 통신은 `IEEE 802.11`로 표준화되어 있고,
  - `802.11b`, `802.11g`처럼 숫자 802.11 뒤의 알파벳으로 다양한 규격을 표현한다.

![self-network_7_34](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_34.png)

그리고 `IEEE 802.11` 표준은 대부분 `2.4GHz, 5GHz 대역`을 사용한다.

- 무선 네트워크를 사용하기 위해 와이파이를 선택할 떄,
  - 2.4G(2.4GHz), 5G(5GHz)라는 글귀가 자주 보이는 것은 이러한 이유 때문이다.

IEEE 802.3 버전에 따라 지원되는 네트워크 장비의 종류와 속도 등이 달라질 수 있는 것처럼,

- 무선 통신 규격인 IEEE 802.11 버전에 따라 사용되는 주파수 뿐만 아니라,
  - 전송 속도, 대역폭, 전송 가능한 거리, 변조 방식 등 많은 것이 달리진다.
- 다음 표를 참고해보면, IEEE 802.11 규격에 따른 주파수 대역과 최대 전송 속도다.

|   표준 규격   | 주파수 대역 | 전송 속도 |
| :-----------: | :---------: | :-------: |
| IEEE 802.11a  |    5GHz     |  54Mbps   |
| IEEE 802.11g  |   2.4GHz    |  54Mbps   |
| IEEE 802.11n  |  2.4/5GHz   |  450Mbps  |
| IEEE 802.11ac |    5GHz     |  6.9Mbps  |
| IEEE 802.11ax | 2.4/5/6GHz  |  9.6Mbps  |
| IEEE 802.11be | 2.4/5/6GHz  | 46.1Mbps  |

> 💡 `변조(modulation)`란 **정보를 원하는 형태의 신호로 변환하는 것**을 의미한다.
> 반대로 `복조(demodulation)`는 **변조된 신호를 원래의 정보로 다시 변환하는 것**을 의미한다.

무선 통신 기술을 설명할 떄, 와이파이를 빼놓을 수는 없겠죠.

- `와이파이(Wi-Fi)`라는 용어는 ‘IEEE 802.11 표준을 따르는 무선 LAN 기술’을 가리키는 말로도 많이 사용되지만,
  - 본래는 `와이파이 얼라이선스(Wi-Fi Alliance)`라는 비영리 단체의 트레이드마크(브랜드) 이름이다.
- 와이파이는 다음 표처럼 ‘와이파이 4’, ‘와이파이 5’ 등으로 구분할 수 있는 세대가 있고,
  - 각 세대는 각기 다른 IEEE 802.11 표준 규격을 준수한다.

| 세대 이름 |   표준 규격   |
| :-------: | :-----------: |
|  Wi-Fi 7  | IEEE 802.11be |
|  Wi-Fi 6  | IEEE 802.11ax |
|  Wi-Fi 5  | IEEE 802.11ac |
|  Wi-Fi 4  | IEEE 802.11n  |

![self-network_7_35](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_35.png)

이러한 이유로 와이파이는 일종의 인증 마크 역할을 한다.

- 특정 제품에 특정 와이파이 인증 마크가 붙어 있을 경우,
  - 해당 제품이 특정 IEEE 802.11 규격을 지켰음을 알 수 있고, 다른 제품과의 호환성도 알 수 있기 때문이다.
- 그래서 무선 LAN 제품을 개발한 회사에서는
  - 위 그림과 같이 인증 시험을 거쳐 Wi-Fi 인증과 인증 로고 사용 권한을 얻게 된다.

![self-network_7_36](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_36.png)

윈도우 노트북을 사용하는 독자들은 현재 사용 중인 무선 네트워크의 속성을 자세히 확인해보면,

- 위 화면처럼 와이파이 버전과 802.11 표준을 확인할 수 있다.

> 💡 2.4GHz 와이파이 vs 5GHz 와이파이, 무엇이 더 좋은가?
>
> 오늘날 대부분 IEEE 802.11 표준은 2.4GHz, 5GHz 대역을 사용한다고 했다.
>
> - 그렇다면 2.4GHz 대역 와이파이와 5GHz 대역 와이파이 중에서 무엇이 더 좋을까요?
> - 언뜻 보면 5GHz가 무조건적으로 좋아 보일 수 있지만, 사실 답은 ‘상황에 따라 다르다’이다.
>
> `5GHz 와이파이`는
>
> - `2.4GHz 와이파이`에 비해 일반적으로 송수신 속도가 빠르지만,
> - `2.4GHz 와이파이`에 비해 장애물의 영향을 크게 받는다는 단점이 있다.
>
> 반대로 `2.4GHz 와이파이`는
>
> - `5GHz 와이파이`에 비해 일반적인 송수신 속도는 느리지만, 장애물의 영향을 덜 받는다.
>
> ![self-network_7_37](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_37.png)
>
> 왜 그럴까? 주파수에 따른 `회절성`때문이다.
>
> - `회절성`이란 **파동이 장애물이나 좁은 틈을 통과**할 떄, **파동이 그 뒤편까지 전파되는 현상을 의미**한다.
> - `2.4GHz 와이파이`처럼 상대적으로 낮은 주파수는 회절성이 좋지만,
>   - `5GHz 와이파이`처럼 주파수가 상대적으로 높으면 회절성이 저하된다. (위 그림처럼 말이죠.)
> - 이는 비단 전파 뿐만 아니라 소리, 빛과 같은 다른 파동에서도 마찬가지다.
>
> 따라서 와이파이 공유기와 여러분의 기기 사이에 벽과 장애물이 많으면,
>
> - `5GHz 와이파이` 신호는 금방 약해지는 것을 확인할 수 있다.
> - 와이파이 목록들만 봐도 유독 `5GHz 와이파이` 신호의 약화가 두드러지게 나타난다.
>   - 반면, `2.4GHz 와이파이`는 비교적 일정한 성능으로 이용할 수 있다.
> - 결론적으로 장애물이 많다면, `2.4 GHz 와이파이`를 이용하는 것이 좋고,
>   - 장애물이 적은 상황에서 속도가 필요하다면 `5GHz 와이파이`가 좋다.

같은 주파수 대역(2.4GHz 혹은 5GHz)을 사용하는 네트워크라 할지라도 별개의 무선 네트워크들이 존재할 수 있다.

- e.g. `2.4GHz 대역`에서 통신하는 **여러 독립적인 무선 네트워크들이 있을 수 있고**,
  - `5GHz 대역`에도 **여러 독립적인 무선 네트워크들이 존재할 수 있다**.
- 이러한 경우, 같은 대역을 사용할지라도 별개의 무선 네트워크는 서로의 신호에 간섭하지 말아야겠죠?

![self-network_7_38](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_38.png)

그래서 2.4GHz, 5GHz 주파수 대역은 `채널(channel)`이라 불리는 하위 주파수 대역으로 또 한 번 세분화되고,

- 해당 채널 대역에서 통신이 이루어진다. 통신 주파수 대역을 채널로 간주하는 것이죠.
- 채널에는 번호가 할당되어 있다.
- 위 그림에는 각각 2.4GHz, 5GHz 대역의 일부 채널들을 표현한 그림이다.
  - `각 포물선`은 **주파수 대역에 따른 채널**을 나타내며, **포물선 상단에 표시된 번호**는 `채널 번호`다.
- 동일한 `2.4GHz` 혹은 `5GHz 대역의 네트워크`를 이용할지라도,
  - **세부적인 주파수는 채널에 따라 달라진다**는 점을 알 수 있다.

`채널`은 일반적으로 **자동으로 설정되지만, 수동으로 설정할 수도 있다**.

- 그러나 같은 공간에서 같은 대역의 서로 다른 네트워크를 구성하거나 이용할 떄는 가급적 간섭을 일으키지 않는 채널을 이용하는 것이 좋다.
- e.g. 위 그림에서 1, 6, 11번 채널은 주파수가 서로 중첩되지 않다.
  - 간섭이 많은 채널이 설정된 경우, 이는 성능 저하의 주 원인이 될 수 있다.
- e.g. 같은 공간에서 위 그림의 1, 2, 3번 채널을 이용하면,
  - 신호가 중첩될 여지가 많아 간섭이 자줄 발생하고, 원활한 통신이 어려워질 수 있다.

---

### 3.3 AP와 서비스 셋

![self-network_7_39](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_39.png)

이제 무선 네트워크 관련 네트워크 장비를 알아보자면,

- 무선 네트워크를 생성하기 위해서는 `무선 네트워크 포인트(이하 AP)`라는 네트워크 장비가 필요하다.
- `AP(Access Point)`는 무선 통신 기기들을 연결하여 무선 네트워크를 구성하는 장치다.
- **가정에 무선 공유기**가 있다면, 그것이 AP 역할을 수행하는 장치라 볼 수 있다.
  - 일반적으로 AP에는 유선 연결 매체를 연결할 수 있는 지점이 함께 제공되어,
  - `유선 네트워크`와 `무선 네트워크`의 **연결을 담당하는 역할도 수행**할 수 있다.

![self-network_7_40](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_40.png)

무선 LAN의 기기들은 AP를 경유해 인터넷에 접속하거나 서로 메시지를 주고받을 수 있다.

- 달리 말해, AP는 무선 LAN에서 통신을 중개하는 역할을 한다.
- 이렇게 **AP를 경유하여 통신이 이루어지는 무선 네트워크 통신 방식**을 `인프라스트럭처 모드(infrastructure mode)`라고 한다.
- 오늘날 많은 무선 LAN이 API가 중개하는 `인프라스트럭처 모드`로 동작한다.

> 💡 AP의 간섭없이 호스트 간에 일대일로 통신하는 무선 통신 모드를 `애드 혹 모드(Ad Hoc mode)`라 한다.

위 그림을 보면, AP를 중심으로 연결된 여러 장치가 무선 네트워크를 형성한다는 것을 볼 수 있다.

- 이처럼 **무선 네트워크를 이루는 AP와 여러 장치들의 집합**을 `서비스 셋(Service Set)`이라 부른다.
- **같은 서비스 셋에 속한 장치들은 같은 무선 네트워크에 속한다**고 볼 수 있다.

![self-network_7_41](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_41.png)

이떄, **각기 다른 서비스 셋을 구분할 수 있는 수단**이 필요하다.

- 그래서 서비스 셋을 식별하기 위해 `서비스 셋 식별자(SSID; Service Set Identifier)`를 사용한다.
- `SSID`는 **무선 네트워크를 구분짓는 수단이자 무선 네트워크를 지칭하는 고유한 이름**이다.

> 💡BSS와 ESS는 무엇인가?
>
> `인프라스트럭처 모드`로 구성된 무선 LAN은 하나의 AP만으로 구성될 수도 있고, 여러 AP로도 구성될 수 있다.
>
> - **하나의 AP로 구성된 무선 LAN**을 `BSS(Basic Service Set)`,
>   - **여러 AP로 구성된 무선 LAN**을 `ESS(Extended Service Set)`라 한다.
> - 여기서 언급하는 `서비스 셋`, `무선 LAN`, `무선 네트워크`라는 용어는 기본적으로 `BSS`를 기준으로 한다.

사실 우리는 `SSID`라는 용어를 직접적으로 사용하지 않더라도, 이미 일상에서 다양한 `SSID`들을 접하고 있다.

- 일반적으로 특정 무선 네트워크에 접속하려면 무엇을 먼저 확인하나요?
  - 와이파이 이름(들)을 확인하죠? **와이파이 이름**이 바로 `SSID`입니다.
- 현재 사용 중인 무선 네트워크의 속성을 확인해보면, `SSID`에 **와이파이 이름이 명시된 것을 확인**할 수 있다.

![self-network_7_42](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_7_42.png)

`AP`는 외부에 자신의 존재를 지속해서 알려야 한다.

- `AP`가 **자신의 존재를 알리지 않는다면, 호스트는 연결 가능한 무선 네트워크가 존재한다는 사실조차 알 수 없죠**.
- 따라서 `AP`는 **불특정 다수 모두에게 자신을 알리는 브로드캐스트 메시지를 주기적으로 전송**한다.
  - 이 브로드캐스트 메시지를 `비턴 프레임(beacon frame)`이라 한다.
- 비컨 프레임 안에는 `SSID`와 `AP의 MAC 주소` 등이 포함되어 있다.
- 여러분의 장치에 와이파이를 연결하고자 할 떄,
  - **연결 가능한 와이파이 목록이 뜨는 것**은 **여러분의 장치가 AP로부터 비컨 프레임을 받았기 떄문**이다.
