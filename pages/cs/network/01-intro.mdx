---
title: '01-시작'
date: 2024/04/13
---

## 1. 컴퓨터 네트워크를 알아야 하는 이유

### 1.1 네트워크의 네트워크, 인터넷

- `컴퓨터 네트워크(computer network)` : 여러 개의 장치가 마치 그물처럼 서로 연결되어 정보를 주고받을 수 있는 통신망, 줄여서 `네트워크`
- `인터넷` : 여러 네트워크를 연결한 ‘네트워크의 네트워크‘
  - 데스크탑 프로그램과 모바일 앱에서 인터넷 연결이 필요한 앱과 그렇지 않은 앱이 있다.
  - 이 중 인터넷이 필요한 프로그램과 앱이 훨씬 많다.
  - 즉, 개발 직군이 네트워크를 제대로 이해해야 하는 이유이기도 하다.

---

### 1.2 개발자가 컴퓨터 네트워크를 알아야 하는 이유

개발자의 업무는 크게 2종류로 나뉜다.

1. 프로그램을 만드는 업무
2. 만들어진 프로그램을 유지보수하는 업무

---

#### 1.2.1 프로그램을 만드는 업무에서 네트워크 지식을 활용하는 경우

- 프로그래밍 언어나 웹 프레임워크 혹은 라이브러리를 사용할 떄, 네트워크에 대한 배경지식이 있어야만 활용할 수있는 기능들이 있다.
- e.g. 스프링 프레임워크의 TCP/UDP 관련 기능 문서, 파이썬의 HTTP와 쿠키 문서
- e.g. 그 외에도 배포할 떄도, DNS, HTTP/HTTPS, 포트 번호 등 다양한 네트워크 배경지식들이 필요

---

#### 1.2.2 프로그램을 유지 보수하는 업무에서 네트워크 지식을 활용하는 경우

- 갑자기 인터넷이 연결이 안되는 문제, 잘 동작하던 웹 서버가 동작하지 않는 문제 등 네트워크 지식은 문제 발생 시 해결을 위한 실마리가 된다.
- 프로그램을 유지보수할 떄 사용하는 도구나 명령어 중에서도 네트워크 지식이 있어야만 이해할 수 있다.
- e.g. `netstart -ano`

> 💡 네트워크 관련 기술 면접 예시
>
> 1. DNS의 정의와 동작 과정에 대해 설명하세요.
> 2. TCP와 UDP의 차이는 무엇인가요?
> 3. HTTP와 HTTPS의 차이는 무엇인가요?

---

## 2. 네트워크 거시적으로 살펴보기

네트워크는 여러 장치가 서로 연결되어 있는 통신망으로, 그래프의 형태를 띠고 있다.

- `그래프(graph)` : 노드(node)와 노드를 연결하는 간선(edge)로 이루어진 자료구조
  - cf. 노드를 `정점(vertex)`, 간선은 `링크(link)`라고도 부름

---

### 2.1 네트워크의 기본 구조

![self-network_1_1](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_1.png)

모든 네트워크는 3가지로 구성된다.

1. `노드` : 정보를 주고받을 수 있는 장치
2. `간선(노드를 연결)` : 정보를 주고받을 수 있는 유무선의 통신 매체
3. `메시지(노드 간 주고받는)`

---

#### 2.1.1 호스트

`호스트(Host)` : 네트워크에서 가장자리에 있는 노드

- cf. 호스트는 네트워크를 통해 흐르는 정보를 최초로 생성 및 송신하고, 최종적으로 수신한다.
- e.g. 이는 서버가 될 수도 있고, 개인 PC, 노트북, 스마트폰이 될 수도 있다.
- cf. 호스트는 네트워크의 가장자리에 자리잡고 있는 점에서 `종단 시스템(end system)`이라고도 한다.

![self-network_1_2](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_2.png)

호스트가 네트워크 상에서 특정 역할을 수행하는데, 대표적으로 서버와 클라이언트가 있다.

- `서버(server)` : 어떠한 서비스를 제공하는 호스트
  - ‘어떠한 서비스’는 파일(파일 서버)이 될수도, 웹페이지(웹 서버)가 될 수도, 메일(메일 서버)이 될 수도 있다.
  - cf. 서버는 서브(serve: 제공하다)에서 비롯했다.
    - 식당에서 손님에게 음식을 서빙(serve + ing)처럼 알바생 역할을 하는 호스트가 ‘서버’이다.
- `클라이언트(client)` : 서버에게 어떠한 서비스를 요청하고 서버의 응답을 제공하는 호스트
  - e.g. 알바생한테 서빙을 받으려면 손님이 먼저 요청해야 한다.
    - 손님이 음식을 요청하면, 알바생이 음식을 서빙한다.
  - 이처럼 클라이언트는 요청(request)을 보내고 그에 대한 응답(response)을 제공받는다.

---

#### 2.1.2 네트워크 장비

`중간 노드(네트워크 장비)` : 네트워크 가장자리에 위치하지 않은 노드

- cf. 호스트 간 주고받을 정보가 중간에 거치는 노드들
- e.g. 이더넷 허브, 스위치, 라우터, 공유기 등
- 이러한 중간 노드들을 `네트워크 장비`로 통칭할 수 있다.

> 💡 호스트, 네트워크 장비, 서버, 클라이언트는 배타적인 개념인가?
>
> 위와 같은 개념들은 그저 노드의 역할에 따라 구분한 기준에 불과하다. 즉, 칼로 자르듯이 명확하게 구분되지 않는다.
>
> - 호소트 또는 네트워크 장비로서의 역할만은 수행할 수 있는 노드도 있고,
> - 반대로, 그 모든 역할을 할 수 있는 노드도 존재한다.
> - 서버와 클라이언트도 마찬가지로, 웹 브라우저를 통해 클라이언트로서 네트워크에 참여할 수 있지만,
> - 동시에 간단한 프로그램을 설치와 설정을 통해 웹 서버로도 사용할 수있다.
>
> 일반적으로 다음과 같이 기억하면 된다.
>
> - 호스트 역할을 수행할 수 있는 노드, 네트워크 장비 역할을 수행할 수 있는 노드가 있다.
> - 서버 역할을 수행할 수 있는 노드, 클라이언트 역할을 수행할 수 있는 노드가 있다.

---

#### 2.1.3 통신 매체

`통신 매체` : 각 노드를 연결하는 간선

- 그래프는 노드와 이를 연결하는 간선(링크)로 이루어지기에,
  - 호스트와 네트워크 장비 또한 유무선 매체를 통해 연결되어 있어야 한다.
- `유선 매체` : 노드들을 유선으로 연결
- `무선 매체` : 노드들을 무선으로 연결

---

#### 2.1.4 메시지

`메시지(message)` : 통신 매체로 연결된 노드가 주고받는 정보

- 메시지는 웹페이지가 될 수도, 파일이 될 수도, 메일이 될 수도 있다.

![self-network_1_3](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_3.png)

- 네트워크는 다음과 같은 요소들로 구성된다.
  1. 가장자리 노드인 `호스트`
  2. 중간 노드인 `네트워크 장비`
  3. 노드들을 연결하는 간선인 `통신 매체`
  4. 노드들이 주고받는 정보인 `메시지`

---

### 2.2 범위에 따른 네트워크 분류

위 요소들이 모이고 모여서 네트워크를 형성한다.
이렇게 형성된 네트워크의 범위는 일반 가정이 될 수도 있고, 때로 도시나 국가가 될 수도 있다.

네트워크의 구성 범위에 따라 분류하는 기준도 다르다.

---

#### 2.2.1 LAN

![self-network_1_4](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_4.png)

`LAN (Local Area Network)` : 가정, 기업, 학교처럼 한정된 공간에서의 네트워크

- 위 그림의 AB 집합, CDE 집합, FG집합 모두 LAN이라 볼 수있다.

---

#### 2.2.2 WAN

`WAN (Wide Area Network)` : 먼 지역을 연결하는 광역 통신망을 의미

- 인터넷이 WAN으로 분류됨
- 같은 LAN에 속한 호스트끼리 메시지를 주고받아야 할 떄는 인터넷 연결과 같은 WAN이 필요없지만,
  - 다른 LAN에 속한 호스트와 메시즈를 주고받아야 할 때는 WAN이 필요하다.

인터넷을 사용하기 위해 접속하는 WAN은 `ISP(Internet Service Provider)`라는 인터넷 서비스 업체가 구축하고 관리한다.

- ISP는 WAN에 연결하는 회선을 임대하는 등 다양한 서비스를 제공한다.
- e.g. 국내 대표적인 ISP 3사 : KT, SK 브로드밴드, LG 유플러스
- cf. 추가로 멀리 떨어진 LAN을 연결하기 위해, 특정 조직에서 불특정 다수에게 공개되지 않은 WAN을 구축할 수도 있다.

> 💡 CAN과 MAN
>
> 크게는 LAN과 WAN으로 나눌 수 있지만, 더 세밀하게 나눌 수 있다.
> LAN보다 넓고, WAN보다는 좁은 범위의 CAN과 MAN이 있다.
>
> - `CAN (Campus Area Network)` : 학교 또는 회사의 여러 건물 단위로 연결되는 규모의 네트워크를 의미
> - `MAN (Metropolitan Area Network)` : 도시나 대도시 단위로 연결되는 규모의 네트워크를 의미
>
> 네트워크 범위를 기준으로 분류하면 WAN > MAN > CAN > LAN 순으로 작아진다.

---

### 2.3 메시지 교환 방식에 따른 네트워크 분류

네트워크로 메시지를 주고받는 방식은 크게 ‘회선 교환 방식’과 ‘패킷 교환 방식’으로 나눌 수 있다.

---

#### 2.3.1 회선 교환 방식

`회선 교환(circuit switching)` : 메시지 전송로인 `회선(circuit)`을 설정하고, 이를 통해 메시지를 주고받는 방식

- cf. ‘회선을 설정한다’ === ‘두 호스트가 연결되었다’, ‘전송로를 확보했다’ 같은 말이다.
- 회선 교환 네트워크에서는 호스트들이 메시지를 주고받기 전에 두 호스트를 연결한 후, 연결된 경로로 메시지를 주고받는다.

![self-network_1_5](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_5.png)

e.g. 위 그림과 같이 회선 교환 네트워크에서 A와 B가 통신하려면,

- 메시지를 주고받기 전에, A와 B 사이를 연결하는 회선(붉은 선)을 설정해야 이 경로를 통해 메시지를 주고 받을 수 있다.

e.g. 위 그림의 회선 교환 네트워크에서 A와 D가 통신하려면,

- 메시지를 주고받기 전에, A와 D 사이를 연결하는 회선(붉은 선)을 설정해야 이 경로를 통해 메시지를 주고 받을 수 있다.

---

##### (1) 장점

- 두 호스트 사이에 연결을 확보한 후에 메시지를 주고받는 특성 덕분에,
- **주어진 시간 동안 전송되는 정보의 양이 비교적 일정**하다

![self-network_1_6](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_6.png)

회선 교환 네트워크가 잘 동작하기 위해서는 호스트 간의 회선을 적절하게 설정해야 한다.
이 역할을 수행하는 회선 교환 네트워크 장비는 `회선 스위치`가 있다.
즉, 회선 스위치는 **호스트 사이에 1대1 전송로를 확보**하는 네트워크 장비다.

e.g. 회선 교환 네트워크의 대표적인 사례가 `전통적인 전화망`이다.

- 누군가에게 전화를 걸면 수신자가 전화받기 전에, 송신자와 수신자 사이에 연결이 설정되어야 하고,
- 한 번 연결이 설정되면 연결된 전송로를 통해서만 통화가 가능하다.

---

##### (2) 단점

![self-network_1_5](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_5.png)

회선 교환의 문제점은 회선의 이용효율이 낮다.

- 가능한 모든 회선에 끊임없이 메시지가 흘러야만 회선의 이용효율이 높아진다.
- 이를 반대로 이야기하면, **메시지를 주고받지 않으면서 회선을 점유하는 것은 낭비**이다.

e.g. 위 그림을 보면, 회선 교환 네트워크 상에서 A, B, C, D가 각각 회선 스위치와 연결되어 있고, A, B회선이 설정되었다.

- 호스트 A, B는 회선이 설정되어 있으니 당장이라도 메시지를 주고받을 수 있다.
- 그러나 호스트 A, B가 회선을 점유하여 연결만 된 채로 메시지를 주고받지 않으면,
  - 회선(붉은 선)에는 어떠한 메시지도 흐르지 않는다.
- 호스트 C가 A에게, D가 B에게 메시지를 보내고 싶어도 보낼 수 없는 상황이 발생한다.

---

#### 2.3.2 패킷 교환 방식

`패킷 교환(packet switching)` : 회선 교환 방식의 문제를 개선해, 메시지를 `패킷`이라는 작은 단위로 쪼개어 전송한다.

- cf. `패킷(packet)` : 패킷 교환 네트워크상에서 송수신되는 메시지의 단위
- cf. 현재 인터넷은 대부분 패킷 교환 방식을 이용한다. (따라서 패킷 교환 방식을 중점으로 배움)

e.g. 패킷 교환 방식으로 2GB 크기의 영화 파일을 다운로드한다면,

- 2GB 한 번에 전송되는 것이 아니라, 패킷의 크기만큼 분할되어 전송된다.
- 쪼개진 패킷들은 수신지인 사용자의 컴퓨터의 도달해서 재조립된다.

![self-network_1_7](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_7.png)

패킷 교환 네트워크는 회선 네트워크와는 달리 메시지를 송수신하는 두 호스트가 하나의 전송 경로를 점유하지 않기에,
네트워크 이용 효율이 상대적으로 높다. 위 그림을 보면, 회선 교환 방식에 비해 전송로에 메시지가 쉴 틈없이 흐르고 있다.

![self-network_1_8](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_8.png)

e.g. 만약 패킷이 패킷 교환 네트워크를 통해 지구 반대편의 먼 곳까지 이동해야 한다면?

- 사전에 설정된 경로만으로 통신하는 `회선 교환 방식`과는 달리,
- `패킷 교환 방식`은 정해진 경로만으로 메시지를 송수신하지 않는다.
  - 이 과정에서 메시지는 다양한 중간 노드를 거치는데, 이떄 중간 노드인 `패킷 스위치`는 패킷이 수신지까지 올바르게 도달할 수 있도록 최적의 경로를 결정하거나, 패킷의 송수신지를 식별한다.
- e.g. 대표적인 패킷 스위치 네트워크 장비로는 `라우터(router)`와 `스위치(switch)`가 있다.

![self-network_1_9](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_9.png)

e.g. 패킷 교환 방식에서 주고받는 `패킷`은 본래 ‘소포, 꾸러미’라는 뜻이다.

- 택배를 보내려면, 상자 안에 보내고자 하는 물품을 담아야 한다.
- 그리고 상자 겉에 붙이는 송장(쪽지)에는 보내는 주소(송신지 주소)와 받을 주소(수신지 주소),
- 보내는 사람(송신자)과 받는 사람(수신자) 등 부가 정보를 적는다.
- 이것들이 있어야지 올바르게 배송이 된다.

네트워크 패킷도 마찬가지이다.

- `페이로드(payload)` : 패킷을 통해 전송하고자하는 데이터 === 택배 상자에 넣을 물품
- `헤더(header)` : 패킷 앞에 포함된 정보 === 택배 상자에 붙이는 송장정보
- `트레일러(trailer)` : 패킷 뒤에 포함된 정보 === 택배 상자에 붙이는 송장정보

`헤더`와 `트레일러`는 `패킷`에 붙는 일종의 제어정보, 내지는 제어 정보이다.
`패킷`은 `페이로드`와 `헤더`로 구성되고, 때로는 `트레일러`도 포함된다.

---

### 2.4 주소와 송수신지 유형에 따른 전송 방식

패킷의 헤더에 담기는 대표적인 정보로는 `주소(address)`가 있다.

- `주소` : 송수신지를 특정하는 정보를 의미
- 택배 송장에 송수신지를 명시하는 것처럼, 네트워크에 흐르는 수많은 패킷에는 모두 송수신지가 담겨있다.
- IP 주소, MAC 주소 모두 네트워크에서 사용되는 주소이다.
- 송수신지를 특정할 수 있는 주소가 있다면, 송수신지 유형에 따라 다양한 방식으로 메시지를 보낼 수 있다.
  - e.g. 수신지를 특정 호스트 하나로 지정할 수 있고, 네트워크 내 모든 호스트로 지정할 수도 있다.
  - e.g. 수신지를 자신과 동일한 그룹에 속한 호스트로 지정할 수도 있다.

송수신지 유형별 전송 방식은 다양하지만,
기본 네트워크 동작을 파악하기 위해 알아야할 중요한 방식은 `유니캐스트`와 `브로드캐스트`이다.

- `유니캐스트(unicast)` : 하나의 수신지에 메시지를 전송하는 방식
  - 송신지와 수신지와 1vs1로 메시지를 주고받는 경우
  - 가장 일반적인 형태의 송수신 방식
- `브로드캐스트(broadcast)` : 자신을 제외한 네트워크상의 모든 호스트에게 전송하는 방식
  - 브로드캐스트가 전송되는 범위를 `브로드캐스트 도메인(broadcast domain)`이라 한다.
  - `브로드캐스트의 수신지`는 `브로드캐스트 도메인`이며, 이는 자신을 제외한 네트워크 상의 모든 호스트이다.

이 외에도 다양하 방식이 존재한다.

- `멀티캐스트(multicast)` : 네트워크 내의 동일 그룹에 속한 호스트에게만 전송하는 방식
- `애니캐스트(anycast)` : 네트워크 내의 동일 그룹에 속한 호스트 중 가장 가까운 호스트에게 전송하는 방식

> 주소는 송수신지를 특정할 수 있는 정보로, 이를 토대로 유니캐스트, 브로드캐스트 방식 등의 전송이 가능하다.

---

## 3. 네트워크 미시적으로 살펴보기

### 3.1 프로토콜

현대 인터넷은 대부분 `패킷 교환 방식`을 사용한다. 네트워크로 정보를 주고받는 방식은 택배와 유사하다.

> 💡 e.g. 영수에게 책을 택배보내기
>
> 1. 선물할 책(페이로드)을 택배 상자(패킷)에 담는다.
> 2. 배송주소 등 택배 기사가 읽을 메시지(헤더)를 작성한다.
> 3. 택배 기사(네트워크 장비)를 통해 발송한다.
>
> 또한 택배기사가 송장에 적힌 메시지를 읽고 이해하려면, 택배 기사가 이해할 수 있는 언어로 작성되어야 한다. (e.g. 같은 한국어)
> 이러한 점에서 ‘언어’는 올바르게 정보를 주고받기 위해 합의된 의사소통 방식이라 볼 수 있다.

네트워크에서 언어를 주고받기 위해 사회적으로 합의된 의사소통 방식을 `프로토콜(protocol)`이라 부른다.

- `프로토콜` : 노드 간에 정보를 주고받기 위해 합의된 네트워크 규칙이나 방법을 의미
- 서로 다른 통신 장치들이 정보를 주고받으려면, 프로토콜을 통해야 한다.
- e.g. 인터넷을 이용하는 것도, 이메일, 파일을 주고받을 수 있는 것도 모두 상대 호스트와 동일한 프로토콜을 사용하기 떄문
- cf. 다만 일상 속 언어와는 달리, 통신 과정에서는 하나의 프로토콜만 사용하지 않고, 여러 프로토콜을 함께 사용한다.
  - e.g. HTTP, FTP 등

> 💡 다양한 프로토콜들
>
> `IP` : 패킷을 수신지까지 전달하기 위해 사용되는 프로토콜
>
> - IP라는 규칙으로 정보를 주고받음으로써 패킷을 수신지까지 올바르게 전달할 수 있음을 의미
>
> `ARP` : 192.168.1.1과 같은 형태의 ‘IP주소’를 A1:B2:C3:D4:E5:F6과 같은 형태의 ‘MAC 주소’로 대응하기 위해 사용되는 프로토콜
>
> - IP주소를 MAC주소로 대응하기 위해서는 ARP라는 규칙으로 정보를 주고받아야 함을 의미
>
> `HTTPS` : HTTP에 비해 보안상 더 안전한 프로토콜
>
> - HTTP와 HTTPS는 모두 프로토콜이다. HTTP라는 규칙으로 정보를 주고받는 것보다 HTTPS라는 규칙으로 정보를 주고받는 것이 보안상 더 안전함을 의미
>
> `TCP` : UDP에 비해 일반적으로 느리지만, 신뢰성이 높은 프로토콜
>
> - TCP라는 규칙으로 정보를 주고받는 것은 UDP라는 규칙으로 정보를 주고받는 것에 비해 데이터를 더 확실하게 전송할 수 있다
>
> 위 예시들로 인해 모든 프로토콜은 각자의 목적과 특징이 있다. 패킷에는 페이로드, 헤더라는 부가정보가 있다고 했다.
> 프로토콜마다 목적과 특징이 다르기에, 특정 프로토콜로 주고받는 패킷의 부가정보도 달라진다.
> 즉, **프로토콜마다 패킷의 헤더 내용이 달라진다**.

![self-network_1_10](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_10.png)

`TCP`와 `UDP`라는 규칙으로 패킷을 주고받을 떄는 위 그림과 같은 정보가 페이로드에 추가된다.

- `TCP`는 `UDP`에 비해 더 확실하게 데이터를 전송할 수 있다.
- 그렇기에 `TCP`는 신뢰성 높은 전송을 수행하기 위한 정보로 구성되어 있고, **헤더에는 더 많은 정보가 포함**된다.

---

### 3.2 네트워크 참조 모델

![self-network_1_11](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_11.png)

네트워크로 메시지를 수신하는 것은 택배를 주고받는 것과 유사하다. 택배를 전달받은 입장에서는 보내는 것의 정반대 과정이다.
과정을 잘 보면, 택배를 주고받는 과정에는 정형화된 순서가 있다. 이는 계층으로 표현할 수 있다.

![self-network_1_12](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_12.png)

네트워크도 마찬가지로, 정보를 주고받을 떄는 정형화된 여러 단계를 거친다. 이 과정은 계층으로 표현할 수 있다.
이렇게 통신의 각 과정을 계층으로 나눈 구조를 `네트워크 참조 모델(network reference model)`이라 한다.
계층으로 표현한다는 점에서 `네트워크 계층 모델`이라 부른다.

통신 과정을 계층으로 나눈 이유는 크게 2가지이다.

1. **네트워크 구성과 설계가 용이하다.**
   - 각 계층이 수행해야 할 역할이 정해져 있으므로, 계층의 목적에 맞게 프로토콜과 네트워크 장비를 계층별로 구분 가능
   - e.g. 2계층에는 2계층 목적에 부합한 프로토콜과 네트워크 장비를 사용
   - e.g. 3계층에는 3계층 목적에 부합한 프로토콜과 네트워크 장비를 사용
2. **네트워크 문제 진단과 해결이 용이하다.**
   - 통신 과정에서 문제가 발생하더라도 문제 원인을 계층별로 진단하기 수월하다.
   - e.g. 잘되던 인터넷이 갑자기 안되면, 가장 최하위 1계층에서 발생한 문제인지 판단하기 위해 케이블 등 유무선 매체의 접속 상태를 확인해볼 수 있다.
   - e.g. 이상이 없다면, 다음 2계층에서 발생한 문제인지 판단하기 위해 정보가 수신지까지 제대로 전달되었는지 진단
   - e.g. 2계층에도 이상이 없다면, 3계층에서 이상이 없는지 순서대로 진단한다.

대표적인 네트워크 참조모델로는 OSI 모델과 TCP/IP 모델이 있다.

---

#### 3.2.1 OSI 모델

![self-network_1_13](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_13.png)

`OSI 모델` : 국제 표준화 기구(ISO; International Organization for Standardization)에서 만든 네트워크 참조 모델

- 통신 단계를 7계층을 나누는데, 최하위 계층에서 최상위 계층순으로,
- 물리 > 데이터링크 > 네트워크 > 전송 > 세션 > 표현 > 응용 계층이 있다.
  - cf. 외우는 법 : 아파서 티내다, 피내다(APS TND, P)

---

(1) 물리 계층

- `물리 계층(physical layer)` : OSI 모델의 최하단에 있는 계층
- 1과 0으로 표현되는 비트 신호를 주고 받는 계층
- 가장 근원적인 통신이 이뤄지는 계층
- 1과 0으로 표현된 비트 데이터(e.g. 이메일, 사진, 동영상)는 다양한 통신 매체를 통해 다양한 신호로 운반될 수 있다.
- 가령 같은 비트 데이터라도 통신 매체에 따라 전기, 빛, 전파 등의 신호로 운반될 수 있다.

---

(2) 데이터링크 계층

- `데이터링크 계층(data link layer)` : 네트워크 내 주변 장치간의 정보를 올바르게 주고받기 위한 계층
- LAN 기술이 데이터링크 계층에 녹아있음
- 물리 계층을 통해 주고받은 정보에 오류가 없는지 확인하고,
- MAC 주소라는 주소체계를 통해 네트워크 내 송수신지를 특정할 수 있다.
- 때로는 전송과정에서 발견할 수 있는 충돌문제를 해결하는 계층

---

(3) 네트워크 계층

- `네트워크 계층(network layer)` : 메시지를 (다른 네트워크에 속한) 수신지까지 전달하는 계층
- `데이터링크 계층`에서 네트워크 내의 주변 장치간의 통신이 이뤄진다면,
  - `네트워크 계층`에서는 네트워크 간의 통신이 이뤄짐
  - e.g. 네트워크 계층은 인터넷을 가능하게 하는 계층
- 네트워크 계층에서는 IP 주소 체계를 통해 통신하려는 수신지 호스트와 네트워크를 식별하고,
  - 원하는 수신지에 도달하기 위한 최적 경로를 결정한다.

---

(4) 전송 계층

- `전송 계층(transport layer)` : 신뢰성있고 안전성있는 전송을 해야할 떄, 필요한 계층
- `전송 계층`은 패킷의 흐름을 제어하거나 전송 오류를 점검해 신뢰성있고 안정적인 전송이 이루어지게 한다.
  - e.g. 패킷이 정상적으로 보내졌는지, 중간에 유실된 정보는 없는지,
  - e.g. 여러 개의 패킷을 보낼 때, 순서가 뒤바뀐 것은 없는지 확인해야 할 떄
- 이 외에도 포트라는 정보를 통해 실행 중인 응용 프로그램의 식별이 이뤄지기도 한다.

> 💡 응용 프로그램(application software)
>
> - 사용자가 특정 목적을 위해 사용하는 일반적인 프로그램을 의미
> - e.g.) 워드 프로세서, 인터넷 브라우저, 메모장, 게임 등

---

(5) 세션 계층

- `세션 계층(session layer)` : ‘세션’을 관리하기 위해 존재하는 계층
- `세션(session)` : 다양한 상황에서 폭넓게 사용되지만,
  - 일반적으로 **통신을 주고받는 호스트의 응용 프로그램 간 연결 상태**를 의미
- `세션 계층`에서는 연결상태를 생성하거나 유지하고, 종료되었을 떄 끊어주는 역할을 담당한다.

---

(6) 표현 계층

- `표현 계층(presentation layer)` : 마치 번역가와 같은 역할을 하는 계층
- 사람이 이해할 수 있는 언어인 문자를 컴퓨터가 이해할 수 있는 코드로 변환하거나,
  - 압축, 암호화와 같은 작업이 표현 계층에서 이루어진다.

---

(7) 응용 계층

- `응용 계층(application layer)` : OSI 참조 모델 최상단에 있는 계층으로 사용자 및 사용자가 이용하는 응용 프로그램과 가장 밀접히 맞닿아 있는 계층
- 응용 계층은 **사용자가 이용할 응용 프로그램에 다양한 네트워크 서비스를 제공**한다.
- e.g. 웹 브라우저 프로그램에 웹 페이지를 제공하거나,
- e.g. 이메일 클라이언트 프로그램에 송수신된 이메일을 제공하는 등 실질적 네트워크 서비스가 제공되는 계층
- 응용 프로그램에 다양한 서비스가 제공될 수 있을 만큼 타 계층에 비해 응용 계층에 속한 프로토콜이 많다.

---

#### 3.2.2 TCP/IP 모델

- `OSI 모델`은 주로 네트워크를 이론적으로 기술하고 이해할 떄 사용하는 반면,
- `TCP/IP 모델`은 이론보다는 구현에 중점을 둔 네트워크 참조모델이다.
  - `OSI 모델`의 목적이 ‘이상적 설계’에 가깝다면, `TCP/IP 모델`은 ‘실용적 구현’에 가깝다.
  - `TCP/IP 모델`은 `TCP/IP 4계층`, `인터넷 프로토콜 스위트`, `TCP/IP 프로토콜 스택`이라고도 부른다.
- TCP와 IP라는 용어는 프로토콜의 이름이며, IP는 인터넷 프로토콜(Internet Protocol)의 약자이다.
- 그렇다면, 네트워크 참조 모델에 왜 TCP/IP라는 프로토콜 이름이 붙는 것일까?
  - 이유는 이 두 프로토콜이 오늘날 네트워크 구현의 핵심으로 간주되기 떄문이다.

> 💡 프로토콜 스위트(internet protocol suite), 프로토콜 스택(protocol stack)
>
> **다양한 계층의 집합**을 `프로토콜 스위트`, `프로토콜 스택`이라고 한다.
> 마치 묶음으로 판매되는 세트 의류처럼 주로 함께 활용되는 프로토콜들이다.
>
> - TCP/IP 모델에서도 TCP, IP를 포함해 UDP, ARP, HTTP 등 다양한 프로토콜들이 주로 묶여 사용된다.
> - TCP, IP를 중심으로 한 프로토콜의 집합을 통칭하기 위해 인터넷 프로토콜 스위트, TCP/IP 프로토콜 스택이라는 이름이 붙은 것이다.

![self-network_1_14](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_14.png)

(1) 네트워크 액세스 계층

- `네트워크 액세스 계층(network access layer)` : OSI 모델의 데이터링크 계층과 유사
  - cf. `링크 계층` 또는 `네트워크 인터페이스 계층`이라고도 부른다.
- `TCP/IP 모델`에서 **최하위 계층**은 OSI 모델 물리계층보다는 **데이터링크 계층 역할을 수행**하는 쪽에 가깝다.
- `TCP/IP 모델`에는 **OSI모델에서의 물리 계층에 해당하는 개념이 없다**고 보는 견해도 있다.
  - cf. 그래서 많은 공식 문서와 전공 서적에서는 OSI 모델과 TCP/IP 모델을 대응해 설명하기 위해서,
  - TCP/IP 모델에 물리 계층을 추가해 TCP/IP 모델을 5계층으로 확장하여 기술하기도 한다.
  - 여기서도 앞으로는 TCP/IP 모델을 5계층으로 확장하여 설명한다.

---

(2) 인터넷 계층

- 인터넷 계층(internet layer) : OSI 모델에서의 네트워크 계층과 유사

---

(3) 전송 계층

- 전송 계층(transport layer) : OSI 모델에서의 전송 계층과 유사

---

(4) 응용 계층

- 응용 계층(application layer) : OSI 모델에서의 세션 계층, 표현 계층, 응용 계층을 합친 것과 유사

---

### 3.3 캡슐화와 역캡슐화

![self-network_1_15](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_15.png)

프로토콜, 네트워크 참조 모델을 토대로 실제 패킷이 어떻게 송수신될지 알아보자.

- 패킷은 송신 과정에서 `캡슐화`가 이루어지고, 수신 과정에서 `역캡슐화`가 이루어진다.
- 송수신하는 메시지는 `송신지 입장`에서는 가장 높은 계층에서부터 가장 낮은 계층으로,
- `수신자 입장`에서는 가장 낮은 계층에서부터 가장 높은 계층으로 이동한다.

---

#### 3.3.1 캡슐화

패킷 교환 네트워크에서 메시지는 `패킷(e.g. 택배상자, 최소한의 데이터 단위) 단위`로 송수신된다.

- `패킷`은 헤더와 페이로드, 때로는 트레일러를 포함하여 구성된다.
- 프로토콜의 목적과 특징에 따라 헤더의 내용은 달라질 수 있다.

어떤 정보를 송신할 떄, 각 계층에서는 상위 계층으로부터 내려받은 패킷을 페이로드로 삼아,
프로토콜에 걸맞은 헤더(혹은 트레일러)를 덧붙인 후 하위 계층으로 전달한다.

![self-network_1_16](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_16.png)

위 그림을 보면, 각 계층을 지나갈 떄마다, 보내고자 하는 정보에 헤더가 추가된다.

- `데이터링크 계층`을 지날 때는 **오류 감지를 위한 트레일러**도 함께 붙는다.
- 상위 계층의 패킷은 **하위 계층에서의 페이로드로 간주**된다.
- 페이로드를 택배 안에 담을 물품에 빗댄다면, 이는 마치 상위 계층의 택배 상자를 하위 계층의 택배 상자에 담는 것과 같다.

![self-network_1_17](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_17.png)

즉, `한 단계 아래 계층`은 바로 **위의 계층으로부터 받은 패킷에 헤더 및 트레일러를 추가**한다.
이렇게 송신 과정에서 헤더 및 트레일러를 추가해 나가는 과정을 `캡슐화(encapsulation)`라고 부른다.
혹은 영문 그대로 `인캡슐레이션`라고도 부른다.

> 💡 `캡슐화` : 데이터 전송 과정에서 헤더 및 트레일러를 추가해나가는 과정을 의미한다.

---

#### 3.3.2 역캡슐화

![self-network_1_18](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_18.png)

엽캐슐화는 받는 입장에서 생각하면 된다.

- 택배를 수신하는 과정은 택배를 송신하는 과정의 반대다.
- 네트워크에서도 마찬가지로 어떤 메시지를 수신할 떄는 캡슐화 과정에 붙였던 헤더(및 트레일러)를 각 계층에서 확인한 뒤 제거한다.
- 이를 `역캡슐화(decapsulation)`라고 한다.
  - 영문 그대로 `디캡슐레이션`이라고도 부른다.

> 💡 `역캡슐화` : 캡슐화 과정에서 붙인 헤더(및 트레일러)를 제거하는 과정을 의미한다.

---

### 3.4 PDU

각 계층에서 송수신되는 메시지 단위를 `PDU(Protocol Data Unit)`라고 한다.

- 즉, 상위 계층에서 전달받은 데이터에 현재 계층의 프로토콜 헤더(및 트레일러)를 추가하면 현재 계층의 PDU가 된다.

OSI 모델의 각 계층에서의 PDU

|     OSI 계층     |                   PDU                   |
| :--------------: | :-------------------------------------: |
|    응용 계층     |          데이터(data) - 메시지          |
|    표현 계층     |              데이터(data)               |
|    세션 계층     |              데이터(data)               |
|  **전송 계층**   | 세그먼트(segment), 데이터그램(datagram) |
|  네트워크 계층   |      패킷(packet) - IP 데이터그램       |
| 데이터 링크 계층 |              프레임(frame)              |
|    물리 계층     |        비트(bit) - 심볼(symbol)         |

> 응용 계층의 PDU는 메시지, 네트워크 계층의 PDU는 IP 데이터그램, 물리 계층의 PDU는 심볼이라 지칭하기도 한다.

`PDU`는 주로 `전송 계층 이하의 메시지`를 **구분하기 위해 사용**한다.
`전송 계층보다 높은 계층`에서는 **일반적으로 데이터 혹은 메시지로만 지칭**하는 경우가 많다.

- 전송 계층의 PDU는 `TCP 프로토콜`이 사용되었을 경우에는 `세그먼트`,
- `UDP 프로토콜`이 사용되었을 경우에는 `데이터그램`이 된다.

![self-network_1_19](https://raw.githubusercontent.com/berenickt/image-server/main/self-network/self-network_1_19.png)

> cf. 패킷
>
> - “패킷”이라는 용어는 패킷 교환 네트워크에서 쪼개어져 전송되는 단위를 통칭하기 위한 일반적인 용어로 사용되기도 하지만,
> - 네트워크 계층에서 송수신 단위를 지칭하기 위해 사용되기 한다.
> - 네트워크 계층에서의 PDU인 ‘패킷’은 후자이고,
> - 패킷 교환 네트워크ㅇ에서 사용된 ‘패킷’은 전자이다.
> - 여기서는 혼동을 방지하기 위해 네트워크 계층의 PDU는 `IP 패킷`이라고도 지칭한다.

---

#### 3.4.1 OSI 7계층, TCP/IP 4계층은 사실 아무것도 해주지 않는다

- 네트워크 참조 모델은 반드시 지켜져야 하는 규칙이 아니다.
- 모든 프로토콜이나 네트워크 장비는 네트워크 참조 모델에 근거해, 반드시 특정 계층에 완벽히 대응되지 않는다.
- 네트워크 참조 모델은 모든 프로토콜과 네트워크 장비가 반드시 지켜야 하는 엄격한 규칙이나 법규가 아니다.
  - 그냥 가이드 라인이다.
  - 네트워크 ‘참조’ 모델이라는 이름처럼 네트워크 구조에 대한 개념 참조를 위해 사용하는 것이 바람직하다.
- 지금도 새 프로토콜과 네트워크 장비는 만들어지는데,
  - 모든 프로토콜이 모든 모델의 특정 계층에 완벽히 대응되지는 않는다.
- 네트워크 참조 모델이나 특정 계층은 네트워크를 작동시키는 주체가 아니다.
  - 프로토콜 혹은 네트워크 장비 같은 참조 모델에 속한 대상이 바로 네트워크를 작동시키는 주체이자 ‘무언가를 해주는’ 대상이다.
- 즉, 참조모델과 계층은 통신이 일어나는 단계를 역할별로 구획한 큰 그림(모델)일 뿐이지, 반드시 지켜야할 규칙도 아니고, 네트워크 작동 주체도 아니다.
- e.g. TCP/IP 모델도 공식문서, 전공 서적마다 계층별 명칭과 구성, 계층 수를 자유롭게 서술한다.
- e.g. OSI 모델도 마찬가지로, OSI 모델의 목적은 이론적 설계를 위한 참조에 가깝고, TCP/IP모델의 목적은 실용적 구현을 위한 참조에 가깝다. 즉, 두 모델은 별개의 목적을 가진 별개의 모델이다.
  - 그래서 두 모델 계층 간 직접적인 비교는 기술적으로 엄밀하지 않고, 그냥 유사하다고 표현하는 것이다.

---

#### 3.4.2 트래픽과 네트워크 성능 지표

- `트래픽(traffic)` : 네트워크 내의 정보량을 의미
- e.g. 통신 매체를 도로, 통신 매체에 흐르는 정보를 자동차라고 생각해보면,
  - 자동차 수가 트래픽의 양인 셈이다.
- cf. “라우터(네트워크 장비)에 트래픽이 몰린다.”라는 표현이 있다.
- cf. “서버(호스트)의 트래픽을 분산한다”라는 표현이 있다.
- **특정 노드에 트래픽이 몰린다**는 것을 **해당 노드가 특정 시간 동안 처리해야 할 정보가 많음을 의미**한다.
  - 이 경우 해당 노드에 `과부하(overhead)`가 생길 수 있다.
  - 컴퓨터에 여러 프로그램을 동시에 실행하면 CPU가 뜨거워지며 성능이 저하되는 것처럼,
  - 트래픽이 몰려 특정 노드에 과부하가 생기면 성능 저하로 이어진다.

네트워크 성능을 평가할 수 있는 3가지 대중적인 지표가 있다. 바로 처리율, 대역폭, 패킷 손실이다.

---

(1) 처리율

- `처리율(throughput, 쓰루풋)` : 단위 시간당 네트워크를 통해 실제로 전송되는 정보량을 의미
  - 일반적으로 `bps`(bit/s ; bits per second), `Mbps`(Mbit/s ; megabits per second), `Gbps`(Gbit/s; gigabits per second) 단위로 표현한다.
  - 때로는 초당 패킷 수를 표현하기 위해 `pps`(p/s ; packets per second) 단위를 사용하기도 한다.
- `처리율`은 비교적 실시간성이 강조된 지표로,
  - **특정 노드가 얼마만큼의 트래픽을 처리하는 중인지 판단하기 위해 사용**되는 경우가 많다.
- `처리율`은 매 순간 변하는 모습으로 표현되거나, 처리율의 평균값이 주로 활용된다.

---

(2) 대역폭

- `대역폭(bandwidth)` : **신호 처리 영역에서의 정의**와 **네트워크 성능 측정 영역에서의 정의**가 다소 다르다.
  - 전자는 **주파수의 범위**를 의미
  - 후자는 **단위 시간 동안 통신 매체를 통해 송수신할 수 있는 최대 정보량**을 의미
- 처리율과 같이 bps, Mbps, Gbps를 단위로 사용한다.
- e.g. 통신 매체가 높은 대역폭을 가지고 있다면, 이는 많은 정보를 송수신할 능력이 있을 의미
  - e.g. 마치 도로의 넓이가 넓어 오갈 수 있는 자동차가 많은 상황과 유사

---

(3) 패킷 손실

- `패킷 손실(packet loss)` : 말 그대로 송수신되는 패킷이 손실된 상황을 의미한다.
  - `높은 트래픽으로 인해 노드`가 순간적으로 처리해야 할 패킷이 너무 많거나,
  - 네트워크 상에 예기치 못한 장애가 발생해서 패킷을 처리하지 못하면 패킷 손실이 발생할 수 있다.
- `패킷 손실`은 명령 프롬프트(CMD) 혹은 터미널에서 ping 명령어로 확인할 수 있다.
  - `ping` 명령어는 수신지로 다수의 패킷을 전송해 수신지까지 도달 가능한지 여부를 알려준다.
  - 몇 개의 패킷을 보내고, 받았는지, 몇 %의 패킷이 손실되었는지를 알 수 있다.
- 다음처럼 ping 명령어를 입력한 뒤, Ctrl + C를 눌러 실행을 멈추고 결과를 확인해보면, 패킷 손실을 확인할 수 있다.

```bash
$ ping 8.8.8.8
PING 8.8.8.8 (8.8.8.8): 56 data bytes
Request timeout for icmp_seq 0
Request timeout for icmp_seq 1
Request timeout for icmp_seq 2
...
^C
--- 8.8.8.8 ping statistics ---
# 다음 문구로 패킷 손실을 알 수 있다.
7 packets transmitted, 7 packets received, 0.0% packet loss
```
