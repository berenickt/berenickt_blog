---
title: '07-보조기억장치'
date: 2023/12/11
---

## 1. 다양한 보조기억장치

![MySelf-Architec-Oper_7_1](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_1.png)

보조기억장치에는 다양한 종류가 있습니다.

- 그중 가장 대중적인 보조기억장치는 `하드 디스크`와 `플래시 메모리`입니다.
- `플래시 메모리`가 조금 생소하게 들릴 수 있는데,
- 우리가 흔히 사용하는 **USB 메모리, SD 카드, SSD와 같은 저장 장치**를 말합니다

---

### 1.1 하드 디스크(HDD)

![MySelf-Architec-Oper_7_2](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_2.png)

`하드 디스크(HDD; Hard Disk Drive)`

- **자기적인 방식으로 데이터를 저장**하는 보조기억장치
  - cf. 자기적 = 어떤 물질을 끌어당기는 성질을 가진 것 (e.g. 자석)
- 이 때문에 하드 디스크를 `자기 디스크(magnetic disk)`의 일종으로 지칭하기도 합니다.
- 용량 저장 장치가 필요한 작업이나 서버실에 자주 출입하는 작업을 한다면, 하드 디스크를 자주 접하게 될 겁니다.

---

#### 1.1.1 스핀들, 플래터

![MySelf-Architec-Oper_7_3](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_3.png)

하드 디스크의 생김새를 볼까요? 위 그림이 바로 하드 디스크입니다.

- 우리가 아는 CD나 옛날 음향 장치인 LP가 떠오를 겁니다.
- 실제로도 하드 디스크는 CD나 LP와 비슷하게 동작합니다.
- **동그란 원판에 데이터를 저장**하고, 그것을 **회전시켜 뾰족한 리더기로 데이터를 읽는 점**에서 비슷하지요.
- 하드 디스크에서 실질적으로 데이터가 저장되는 곳은 그림 속 동그란 원판입니다.
  - 이를 `플래터(platter)`라고 합니다.
  - 하드 디스크는 **자기적인 방식으로 데이터를 저장**한다고 했죠?
  - 플래터는 자기 물질로 덮여 있어 **수 많은 N극과 S극을 저장**합니다.
  - **N극과 S극**은 0**과 1의 역할을 수행**합니다.
- **플래터를 회전시키는 구성 요소**를 `스핀들(spindle)`이라고 합니다.
  - **스핀들이 플래터를 돌리는 속도**는
    - **분당 회전수**를 나타내는 `RPM(Revolution Per Minute)`이라는 단위로 표현됩니다.
  - e.g. `RPM이 15,000인 하드 디스크`는 **1분에 15,000바퀴를 회전**하는 하드 디스크입니다.

---

#### 1.1.2 헤드, 디스크암

![MySelf-Architec-Oper_7_4](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_4.png)

- **플래터를 대상으로 데이터를 읽고 쓰는 구성 요소**는 `헤드(head)`입니다.
  - 헤드는 플래터 위에서 미세하게 떠 있는 채로 데이터를 읽고 쓰는, 마치 **바늘같이 생긴 부품**입니다.
  - 그리고 헤드는 **원하는 위치로 헤드를 이동**시키는 `디스크 암(disk arm)`에 부착되어 있습니다.
- CD나 LP에 비해 하드 디스크는 훨씬 더 많은 양의 데이터를 저장해야 하므로
  - 일반적으로 **여러 겹의 플래터로 이루어져 있고**, **플래터 양면을 모두 사용**할 수 있습니다.
  - **양면 플래터를 사용**하면, **위아래로 플래터당 두 개의 헤드가 사용**됩니다.
  - 이때 일반적으로 모든 헤드는 디스크 암에 부착되어 다같이 이동합니다.

---

#### 1.1.3 트랙, 섹터

![MySelf-Architec-Oper_7_5](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_5.png)

그럼 이제 플래터에 데이터가 어떻게 저장되는지 알아봅시다.

- `플래터`는 `트랙(track)`과 `섹터(sector)`라는 단위로 데이터를 저장합니다.
- 위 그림처럼 `플래터`를 **여러 동심원으로 나누었을 때** **그 중 하나의 원**을 `트랙`이라고 부릅니다.
  - **운동장 달리기 트랙**을 생각해 보면 쉽게 와닿을 겁니다.
- 그리고 `트랙`은 마치 **피자처럼 여러 조각으로 나누어지는데**, 이 한 조각을 `섹터`라고 부릅니다.
  - `섹터`는 **하드 디스크의 가장 작은 전송 단위**입니다.
  - `하나의 섹터`는 일반적으로 512바이트 정도의 크기를 가지고 있지만,
    - 정확한 크기는 하드 디스크에 따라 차이가 있습니다.
  - 일부 하드 디스크의 섹터 크기는 4,096바이트에 이르기도 합니다.

---

#### 1.1.4 트랙, 실린더

![MySelf-Architec-Oper_7_6](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_6.png)

위에서 여러 겹의 플래터가 사용될 수 있다고 했죠?

- 이때 **여러 겹의 플래터 상에서 같은 트랙이 위치 한 곳을 모아**
  - **연결한 논리적 단위**를 `실린더(cylinder)`라고 부릅니다.
- 쉽게 말해, **한 플래터를 동심원으로 나눈 공간**은 `트랙`,
  - **같은 트랙끼리 연결한 원통 모양의 공간**은 `실린더`입니다.

---

#### 1.1.5 헤드, 플러터

![MySelf-Architec-Oper_7_7](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_7.png)

**연속된 정보는 보통 한 실린더에 기록**됩니다.

- e.g. 두 개의 플래터를 사용하는 하드 디스크에서 **4개 섹터에 걸쳐 데이터를 저장**할 때는
  - 첫 번째 플래터 윗면, 뒷면과 두 번째 플래터 윗면, 뒷면에 데이터를 저장합니다.
- **연속된 정보를 하나의 실린더에 기록하는 이유**는 디스크 암을 움직이지 않고도,
  - 바로 **데이터에 접근할 수 있기 때문**입니다.

---

#### 1.1.6 저장된 데이터에 접근하는 과정

데이터가 하드 디스크의 섹터, 트랙, 실린더에 저장된다는 것을 알았다면,
저장된 데이터에 접근하는 과정을 생각해 봅시다.
하드 디스크가 저장된 데이터에 접근하는 시간은 크게 `탐색 시간`, `회전 지연`, `전송 시간`으로 나뉩니다.

---

##### (1) 탐색 시간(seek time)

![MySelf-Architec-Oper_7_8](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_8.png)

`탐색 시간(seek time)`은 **접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간**을 의미합니다.

---

##### (2) 회전 지연(rotational latency)

![MySelf-Architec-Oper_7_9](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_9.png)

`회전 지연(rotational latency)`은 **헤드가 있는 곳으로 플래터를 회전시키는 시간**을 의미합니다.

---

##### (3) 전송 시간(transfer time)

![MySelf-Architec-Oper_7_10](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_10.png)

`전송 시간(transfer time)`은 **하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간**을 의미합니다.

위 시간들은 별것 아닌 것 같아도 성능에 큰 영향을 끼치는 시간입니다.
일례로 구글의 AI를 주도하고 있는 제프 딘(Jeff Dean)은
과거 ‘프로그래머가 꼭 알아야 할 컴퓨터 시간들’을 공개한 바 있는데,
일부를 발췌하면 다음과 같습니다.

|                      시간 단위                      |     시간      |
| :-------------------------------------------------: | :-----------: |
|                  L1 캐시 참조 시간                  |     0.5ns     |
|                  L2 캐시 참조 시간                  |      5ns      |
|                  메모리 참조 시간                   |      7ns      |
|        메모리에서 1MB를 순차적으로 읽는 시간        |   250,000ns   |
|               (하드) 디스크 탐색 시간               | 10,000,000ns  |
|    (하드) 디스크에서 1MB를 순차적으로 읽는 시간     | 30,000,000ns  |
| 한 패킷이 캘리포니아에서 네덜란드까지 왕복하는 시간 | 150,000,000ns |

> ns(나노초)는 10 -9초입니다. 그리고 `패킷(packet)`이란 **네트워크의 기본적인 전송 단위**입니다.

생각보다 정말 많은 시간이 걸리죠?
물론 2011년에 자료가 공개된 이후 오늘날 하드 디스크 성능은 많이 향상되었지만,
하드 디스크에서 다량의 데이터를 탐색하고 읽어들이는 시간은 생각보다 어마어마하다는 사실을 쉽게 짐작할 수 있습니다.

탐색 시간과 회전 지연을 단축시키기 위해서는 플래터를 빨리 돌려 RPM을 높이는 것도 중요하지만,
06-3절에서 배운 참조 지역성, 즉 접근하려는 데이터가 플래터 혹은 헤드를 조금만 옮겨도
접근할 수 있는 곳에 위치해 있는 것도 중요합니다.

> 💡 다중 헤드 디스크와 고정 헤드 디스크
>
> ![MySelf-Architec-Oper_7_11](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_11.png)
>
> - `단일 헤드 디스크(single-head disk)`
>   - **플래터의 한 면당 헤드가 하나씩 달려 있는 하드 디스크**
>   - 헤드를 데이터가 있는 곳까지 움직여야 하는 단일 헤드 디스크를
>     - `이동 헤드 디스크(movable-head disk)`라고 부름.
> - `다중 헤드 디스크(multiple-head disk)`
>   - **헤드가 트랙별로 여러 개 달려 있는 하드 디스크**
>   - **트랙마다 헤드가 있기 때문에 탐색 시간이 들지 않습니다.**
>   - 따라서 다중 헤드 디스크는 **탐색 시간이 0**입니다.
>   - 이런 점에서 헤드를 움직일 필요가 없는 다중 헤드 디스크를
>     - `고정 헤드 디스크(fixed-head disk)`라고도 부름

인터넷에서 하드 디스크 작동 영상을 찾아 한 번 시청해보길 권합니다.
‘hard drive running’, ‘hard drive in slow motion’ 등으로 검색해 보세요.
하드 디스크를 글로 이해하는 것은 어렵지 않으나,
한 번 눈으로 동작을 본 뒤에 학습하는 것이 훨씬 더 와닿고 기억에 오래 남기 때문입니다.

---

### 1.2 플래시 메모리

다음 그림에서 붉은 박스로 표기한 부분이 플래시 메모리입니다.

![MySelf-Architec-Oper_7_12](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_12.png)

- `플래시 메모리(flash memory)` : **전기적으로 데이터를 읽고 쓸 수 있는 반도체 기반의 저장 장치**입니다.
- e.g. USB 메모리, SD 카드, SSD
- 사실 플래시 메모리는 보조기억장치 범주에만 속한다기보다는
  - **다양한 곳에서 널리 사용하는 저장 장치**로 보는 것이 옳습니다.
- 주기억장치 중 하나인 **ROM에도 사용**되고,
  - 일상적으로 접하는 **거의 모든 전자 제품 안에 플래시 메모리가 내장**되어 있다고 봐도 무방합니다.

> 💡 두 종류의 플래시 메모리
>
> 플래시 메모리에는 크게 `NAND 플래시 메모리`와 `NOR 플래시 메모리`가 있습니다.
>
> - `NAND 플래시`
>   - **NAND 연산을 수행하는 회로**(NAND 게이트)**를 기반으로 만들어진 메모리**
>   - **대용량 저장 장치로 많이 사용되는 플래시 메모리는 NAND 플래시 메모리**
>   - 이번 절에서 설명할 보조기억장치로서의 플래시 메모리 또한 NAND 플래시 메모리
>   - 이 책에서 `플래시 메모리`는 특별한 언급이 없는 한 `NAND 플래시 메모리`를 지칭한다고 보아도 무방
> - `NOR 플래시`
>   - **NOR 연산을 수행하는 회로**(NOR 게이트)**를 기반으로 만들어진 메모리**

---

#### 1.2.1 셀(cell) : 최소 단위

플래시 메모리에는 `셀(cell)`이라는 단위가 있습니다.

- `셀` : **플래시 메모리에서 데이터를 저장하는 가장 작은 단위**
- 이 셀이 모이고 모여 MB, GB, TB 용량을 갖는 저장 장치가 된다.

이때 하나의 셀에 몇 비트를 저장할 수 있느냐에 따라 플래시 메모리 종류가 나뉩니다.

- 한 셀에 1비트를 저장할 수 있는 플래시 메모리를 `SLC(Single Level Cell)` 타입
- 한 셀에 2비트를 저장할 수 있는 플래시 메모리를 `MLC(Multiple Level Cell)` 타입
- 한 셀에 3비트를 저장할 수 있는 플래시 메모리를 `TLC(Triple-Level Cell)` 타입
- 한 셀에 4비트를 저장할 수 있는 플래시 메모리를 `QLC(Quad Level Cell)` 타입

큰 차이가 아닌 것처럼 보여도, 이는 플래시 메모리의 수명, 속도, 가격에 큰 영향을 끼칩니다.
이 책에서는 **SLC, MLC, TLC 타입을 위주로** 알아보겠습니다.
**SLC, MLC, TLC 타입의 특징을 이해**하면, **QLC 타입의 특징도 충분히 짐작**할 수 있기 때문입니다

> 💡 플래시 메모리도 수명이 있나요?
>
> **플래시 메모리에는 수명**이 있습니다. 플래시 메모리뿐만 아니라 **하드 디스크 또한 수명**이 있지요.
>
> - USB 메모리, SSD, SD 카드는 **수명이 다하면 더 이상 저장 장치로써 사용이 불가능**합니다.
> - 종이에 연필로 쓰고 지우개로 지우고를 반복하다 보면, 결국 종이가 찢어지는 것처럼
> - **한 셀에 일정 횟수 이상 데이터를 쓰고 지우면,** **그 셀은 더 이상 데이터를 저장할 수 없기 때문**입니다.

그럼 SLC, MLC, TLC 타입의 특징과 차이점을 알아보겠습니다.
`사람 한 명`을 `1비트`, `셀`을 `집`에 비유하면,

- `SLC 타입`은 **한 집에 한 명,**
- `MLC 타입`은 **한 집에 두 명,**
- `TLC 타입`은 **한 집에 세 명이 사는 구조**로 비유 할 수 있습니다.

---

##### (1) SLC 타입

![MySelf-Architec-Oper_7_13](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_13.png)

한 셀당 2비트씩 저장할 수 있는 `SLC 타입`은 **한 셀로 2개의 정보를 표현**할 수 있습니다.

- **비트의 빠른 입출력**
  - e.g. 홀로 거주하는 집에 제약 없이 출입이 가능하듯,
  - `SLC 타입`은 **MLC나 TLC 타입에 비해 비트의 빠른 입출력이 가능**합니다.
- **긴 수명**
  - MLC나 TLC 타입보다 길어서 수만에서 수십만 번 가까이 데이터를 쓰고 지우고를 반복 가능
- **용량 대비 고가격**
  - e.g. 마치 혼자서 살면 감당해야 할 주거 비용이 커지는 것과 같지요.
  - 그렇기에 보통 **기업에서 데이터를 읽고 쓰기가 매우 많이 반복**되며,
  - **고성능의 빠른 저장 장치가 필요한 경우**에 `SLC 타입`을 사용

---

##### (2) MLC 타입

![MySelf-Architec-Oper_7_14](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_14.png)

한 셀당 2비트씩 저장할 수 있는`MLC 타입`은 **한 셀로 4개의 정보를 표현**할 수 있습니다.

- **SLC보다 느린 입출력**
- **SLC보다 짧은 수명**
- **SLC보다 용량 대비 가격이 저렴**
  - e.g. 두 명이 한 집에서 주거 비용을 나눠 내면 혼자 감당해야 하는 주거 비용보다 저렴해짐
- **시중에서 많이 사용(**MLC, TLC, QLC), **대용량화 유리**
  - 한 셀에 두 비트씩 저장할 수 있다는 점에서 MLC 타입은 SLC 타입 보다 대용량화하기 유리
  - e.g. 집의 개수가 같다면 한 집에 한 명씩 사는 것보다
  - 한 집에 두 명씩 사는 것이 훨씬 더 많은 사람을 수용할 수 있는 것과 같은 이치

---

##### (3) TLC 타입

![MySelf-Architec-Oper_7_15](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_15.png)

한 셀당 3비트씩 저장할 수 있는 `TLC 타입`은 **한 셀로 8개의 정보를 표현**할 수 있습니다.

- **MLC보다 느린 입출력**
- **MLC보다 짧은 수명**
- **MLC보다 용량 대비 가격이 저렴**
- **시중에서 많이 사용(**MLC, TLC, QLC), **대용량화 유리**

정리하면, 같은 용량의 플래시 메모리 저장 장치라고 할지라도, **셀의 타입에 따라 수명, 가격, 성능이 다릅니다.**

- `고가의 SLC 타입` : 썼다 지우기를 자주 반복해야 하는 경우 혹은 높은 성능을 원하는 경우
- `MLC 타입` : SLC와 TLC의 중간을 원하는 경우
- `TLC 타입` : **저가의 대용량 저장 장치**를 원하는 경우

|      구분      |  SLC   | MLC  |  TLC   |
| :------------: | :----: | :--: | :----: |
|    셀당 bit    |  1bit  | 2bit |  3bit  |
|      수명      |  길다  | 보통 |  짧다  |
| 읽기/쓰기 속도 | 빠르다 | 보통 | 느리다 |
| 용량 대비 가격 |  높다  | 보통 |  낮다  |

---

#### 1.2.2 셀보다 더 큰 단위

이제 플래시 메모리의 가장 작은 단위인 셀보다 더 큰 단위를 알아봅시다.

- `셀` : **플래시 메모리에서 데이터를 저장하는 가장 작은 단위**
- 이 셀이 모이고 모여 MB, GB, TB 용량을 갖는 저장 장치가 된다.

![MySelf-Architec-Oper_7_16](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_16.png)

- **셀들이 모여 만들어진 단위**를 `페이지(page)`
- **페이지가 모여 만들어진 단위**를 `블록(block)`
- **블록이 모여 만들어진 단위**를 `플레인(plane)`
- **플레인이 모여 만들어진 단위**를 `다이(die)`

플래시 메모리에서 `읽기와 쓰기`는 **페이지 단위로 이루어집니다**.
하지만 `삭제`는 페이지보다 큰 **블록 단위로 이루어집니다**.
`읽기/쓰기 단위`와 `삭제 단위`가 **다르다는 것이 플래시 메모리의 가장 큰 특징** 중 하나입니다.

이때 `페이지`는 **3개의 상태**를 가질 수 있습니다. 이는 각각 `Free`, `Valid`, `Invalid` 상태입니다.

- `Free 상태` : **어떠한 데이터도 저장하고 있지 않아, 새로운 데이터를 저장**할 수 있는 상태
- `Valid 상태` : **이미 유효한 데이터를 저장**하고 있는 상태
- `Invalid 상태` : **쓰레기값이라 부르는 유효하지 않은 데이터를 저장**하고 있는 상태

플래시 메모리는 하드 디스크와는 달리 **덮어쓰기가 불가능**하여,
`Valid 상태인 페이지`에는 **새 데이터를 저장할 수 없습니다.**

---

#### 1.2.3 가비지 컬렉터

![MySelf-Architec-Oper_7_17](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_17.png)

플래시 메모리의 간단한 동작을 예시로 알아봅시다. **X라는 블록이 4개의 페이지로 이루어져 있다고 가정**해 보겠습니다.

- 그 중 **2개의 페이지에는** 왼쪽과 같이 **A와 B라는 데이터가 저장**되어 있다고 해보죠.
- 여기서 **블록 X에 새로운 데이터 C를 저장한다면** 어떻게 될까요?
- 플래시 메모리의 **읽기 쓰기 단위는 페이지**라고 했죠?
- 그러므로 **오른쪽과 같이 저장**됩니다.

---

![MySelf-Architec-Oper_7_18](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_18.png)

여기서 기존에 저장되어 있던 B는 그대로 둔 채, **기존의 A만을 A'로 수정하고 싶다면** 어떻게 해야 할까요?

- 플래시 메모리에서 **덮어쓰기는 불가능하기 때문에**
  - `기존에 저장된 A`는 `Invalid 상태`가 되어 **더 이상 값이 유효하지 않은 쓰레기값**이 되고,
  - **새로운 A' 데이터가 저장**됩니다.
- 결과적으로 `블록 X의 Valid 페이지`는 **B, C, A'**가 됩니다.

---

여기서 문제점이 보이나요?

- A와 같은 쓰레기값을 저장하고 있는 공간은 사용하지 않는데도, 용량을 차지하고 있습니다.
- 이는 엄연히 용량 낭비입니다. 그렇다고 A만 지울 수도 없습니다.
- 앞서 언급했듯이 플래시 메모리에서 삭제는 블록 단위로 수행되기 때문입니다.
- 그래서 최근 SSD를 비롯한 플래시 메모리는 이런 쓰레기값을 정리하기 위해,
  - `가비지 컬렉션(garbage collection)` 기능을 제공합니다.

![MySelf-Architec-Oper_7_19](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_19.png)

가비지 컬렉션은

- **유효한 페이지들만을 새로운 블록으로 복사**한 뒤, **기존의 블록을 삭제하는 기능**입니다.
- 즉, **블록 X의 모든 유효한 페이지**를 **새로운 블록 Y로 옮기고 블록 X를 삭제하는 것**이죠.

---

## 2. RAID의 정의와 종류

![MySelf-Architec-Oper_7_20](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_20.png)

`1TB 하드 디스크 4개`와 `4TB 하드 디스크 1개`를 비교해보겠습니다.

- `1TB 하드 디스크 4개`를 동시에 사용하는 것이 더 나을까요?
- 아니면 `4TB 하드 디스크 1개`를 사용하는 것이 더 나을까요?
- `1TB 하드 디스크 4개`로 **RAID를 구성**하면, `4TB 하드 디스크 1개`의 **성능과 안전성을 능가**할 수 있습니다.
- 그렇다면 RAID가 무엇이며, 왜 이런 차이가 생기는 것인지 이번 절에서 함께 알아봅시다.

---

### 2.1 RAID의 정의

![MySelf-Architec-Oper_7_21](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_21.png)

여러분이 구글, 아마존과 같은 글로벌 IT 기업의 서버를 관리하는 엔지니어라고 생각해 봅시다.

- 매일 같이 수십, 수백 TB 데이터가 서버로 쏟아지고,
- 데이터에는 개인 정보, 결제 정보와 같이 절대로 잃어버려서는 안될 민감한 정보도 포함되어 있습니다
- 여러분이라면 이런 정보를 어떻게 안전하게 관리할 건가요?
  - 보조기억장치에도 수명이 있다고 했습니다.
  - 그래서 ‘HDD 같은 보조 기억장치에 어떻게든 저장하면 됩니다’같은 단순한 답으로는 부족합니다.
  - 이럴 때 사용할 수 있는 방법 중 하나가 RAID입니다.

![MySelf-Architec-Oper_7_22](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_22.png)

`RAID(Redundant Array of Independent Disks)`

- 하드 디스크와 SSD를 사용하는 기술
- 데이터의 안전성 혹은 높은 성능을 위해,
  - **여러 개의 물리적 보조기억장치**를 마치 **하나의 논리적 보조기억장치처럼 사용**하는 기술

---

### 2.2 RAID의 종류

여러 개의 하드 디스크나 SSD를 마치 하나의 장치처럼 사용하는 RAID를 구성하는 방법은 여러 가지가 있습니다.

- RAID 구성 방법을 `RAID 레벨`이라 표현하는데,
  - RAID 레벨에는 대표적으로 `RAID 0, RAID 1, RAID 2, RAID 3, RAID 4, RAID 5, RAID 6`이 있고,
  - 그로부터 파생된 `RAID 10, RAID 50`등이 있습니다.
- 이들 중 가장 대중적인 `RAID 0, RAID 1, RAID 4, RAID 5, RAID 6`에 대해 알아보겠습니다.

---

#### 2.2.1 RAID 0

![MySelf-Architec-Oper_7_23](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_23.png)

- `RAID 0`는 여러 개의 보조기억장치에 **데이터를 단순히 나누어 저장하는 구성 방식**입니다.
- e.g. 1TB 하드 디스크 4개로 RAID 0를 구성했다고 가정해봅시다.

---

![MySelf-Architec-Oper_7_24](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_24.png)

- 어떤 데이터를 저장할 때, 각 하드 디스크는 위와 같이 번갈아가며 데이터를 저장합니다.
- 즉, 저장되는 데이터가 **하드 디스크 개수만큼 나뉘어 저장**되는 것이지요.
- 이때 마치 **줄무늬처럼 분산되어 저장된 데이터**를 `스트라입(stripe)`이라 하고,
- **분산하여 저장하는 것**을 `스트라이핑(striping)`이라고 합니다.
- cf. `stripe` : 줄무늬

---

![MySelf-Architec-Oper_7_25](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_25.png)

위와 같이 **데이터가 분산되어 저장**되면, 다시 말해 **스트라이핑되면 저장된 데이터를 읽고 쓰는 속도가 빨라집니다**.

- 하나의 대용량 저장 장치를 이용했더라면,
  - **여러 번에 걸쳐 읽고 썼을 데이터를 동시에 읽고 쓸 수 있기 때문**이지요.
- 그렇기에 `4TB 저장 장치 1개`를 읽고 쓰는 속도보다,
  - `RAID 0로 구성 된 1TB 저장 장치 4개`의 속도가 **이론상 4배가량 빠릅니다**.

![MySelf-Architec-Oper_7_26](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_26.png)

그런데 RAID 0에는 단점이 있습니다. 저장된 정보가 안전하지 않습니다.

- **RAID 0으로 구성된 하드 디스크 중 하나에 문제**가 생긴다면,
- **다른 모든 하드 디스크의 정보를 읽는 데 문제**가 생길 수 있습니다.
- 그래서 등장한 것이 RAID 1입니다.

---

#### 2.2.2 RAID 1

다음 그림은 4개의 하드 디스크를 RAID 1으로 구성한 모습입니다.

![MySelf-Architec-Oper_7_27](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_27.png)

- `RAID 1`은 **복사본을 만드는 방식**입니다.
- 마치 **거울처럼 완전한 복사본을 만드는 구성**이기에 `미러링(mirroring)`이라고도 부릅니다.
- RAID 0처럼 데이터 스트라이핑이 사용되긴 했지만,
  - 오른쪽의 두 하드 디스크는 마치 거울처럼 왼쪽의 두 하드 디스크와 동일한 내용을 저장합니다.
- 이처럼 RAID 1에 어떠한 데이터를 쓸 때는 `원본`과 `복사본` 두 군데에 씁니다.
- 그렇기에 **쓰기 속도는 RAID 0보다 느립니다.**
- RAID 1 방식은 **복구가 매우 간단하다는 장점**이 있습니다.
  - 똑같은 디스크가 두 개 있는 셈이니,
  - 하나에 문제가 발생해도 잃어버린 정보를 금방 되찾을 수 있기 때문입니다.
- 하지만 RAID 1은 하드 디스크 개수가 한정되었을 때, **사용 가능한 용량이 적어지는 단점**이 있습니다.
  - 위 그림만 봐도 `RAID 0` 구성은 **4TB의 정보를 저장**할 수 있는 반면,
  - `RAID 1`에서는 **2TB의 정보만 저장**할 수 있습니다.
  - 즉, RAID 1에서는 **복사본이 만들어지는 용량만큼 사용자가 사용하지 못합니다**.
  - 결국 **많은 양의 하드 디스크가 필요**하게 되고, **비용이 증가한다는 단점**으로도 이어집니다.

---

#### 2.2.3 RAID 4

![MySelf-Architec-Oper_7_28](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_28.png)

- `RAID 4`는 (RAID 1처럼 완전한 복사본을 만드는 대신)
  - **오류를 검출하고 복구하기 위한 정보를 저장한 장치를 두는 구성 방식**입니다.
- cf. **‘오류를 검출하고 복구하기 위한 정보’**를 `패리티 비트(parity bit)`라고 합니다.
- **패리티를 저장한 장치를 이용해 다른 장치들의 오류를 검출**하고, **오류가 있다면 복구**합니다.
  - 이로써 RAID 4는 **RAID 1보다 적은 하드 디스크로도 데이터를 안전하게 보관**할 수 있습니다.

> 💡 오류를 검출하는 패리티 비트
>
> `원래 패리티 비트`는 **오류 검출만 가능할 뿐**, **오류 복구는 불가능**합니다.
> 하지만 `RAID에서는 패리티 값`으로 **오류 수정도 가능**합니다.
> 다만 구체적인 방법인 패리티 계산법은 다루지 않을 예정입니다.
> 여러분은 여기서 다음 2가지만 기억하면 됩니다.
>
> 1. `RAID 4`에서는 **패리티 정보를 저장한 장치**로써 **나머지 장치들의 오류를 검출·복구**한다.
> 2. `패리티 비트`는 **본래 오류 검출용 정보**지만, **RAID에서는 오류 복구도 가능**하다.

---

#### 2.2.4 RAID 5

![MySelf-Architec-Oper_7_29](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_29.png)

- `RAID 4`에서는 어떤 새로운 데이터가 저장될 때마다 패리티를 저장하는 디스크에도 데이터를 쓰게 되므로
- `패리티를 저장하는 장치`에 **병목 현상이 발생한다는 문제**가 있습니다.
- cf. `병목현상(bottle neck)` : 페트병의 목 부분처럼 넓은 길이 갑자기 좁아짐으로써 일어나는 교통 정체 현상
  - 컴퓨터에서는 **엄청난 양의 데이터를 순식간에 내보내서**,
  - **메모리가 이를 제대로 소화하지 못해 성능이 떨어지는 현상**

![MySelf-Architec-Oper_7_30](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_30.png)

- `RAID 5`는 위 그림처럼 **패리티 정보를 분산하여 저장하는 방식**으로
- **RAID 4의 문제인 병목 현상을 해소**합니다.

---

#### 2.2.5 RAID 6

![MySelf-Architec-Oper_7_31](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_7_31.png)

- `RAID 6`의 구성은 기본적으로 RAID 5와 같으나,
  - 위 그림과 같이 **서로 다른 두 개의 패리티를 두는 방식**입니다.
  - 이는 **오류를 검출하고 복구할 수 있는 수단이 2개가 생긴 셈**입니다.
  - 따라서 `RAID 6`은 `RAID 4`나 `RAID 5`**보다 안전한 구성**이라 볼 수 있습니다.
- 다만 새로운 정보를 저장할 때마다 함께 저장할 패리티가 2개이므로, **쓰기 속도는 RAID 5보다 느립니다**.
  - 따라서 RAID 6은 **데이터 저장 속도를 조금 희생**하더라도,
  - **데이터를 더욱 안전하게 보관하고 싶을 때 사용하는 방식**입니다.

---

지금까지 다양한 RAID의 개념과 RAID 레벨을 알아보았습니다.

- 이 외에도 RAID 0과 RAID 1을 혼합한 RAID 10 방식도 있고,
  - RAID 0과 RAID 5를 혼합한 RAID 50 방식도 있습니다.
  - cf. 이렇게 여러 RAID 레벨을 혼합한 방식을 `Nested RAID`라고 합니다
- **각 RAID 레벨마다 장단점**이 있으므로,
  - **어떤 상황에서 무엇을 최우선으로 원하는지에 따라 최적의 RAID 레벨**은 달라질 수 있습니다.
- 그렇기에 **각 RAID 레벨의 대략적인 구성과 특징을 아는 것이 중요**합니다
