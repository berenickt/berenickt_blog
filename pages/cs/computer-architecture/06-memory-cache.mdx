---
title: '06-메모리와 캐시메모리'
date: 2023/12/11
---

## 1. RAM의 특징과 종류

> 주기억장치의 종류에는 크게 **RAM**과 **ROM**, 두 가지가 있고,
> **‘메모리’**라는 용어는 그 중 **RAM을 지칭**하는 경우가 많습니다

지금까지 ‘메모리’라는 용어로 지칭했던 저장 장치인 RAM을 조금 더 자세히 알아보겠습니다.

- RAM 용량이 컴 퓨터 성능에 어떤 영향을 미치는지
- DRAM, SRAM, SDRAM, DDR SDRAM은 무엇이고 어떤 특징을 가지는지
- cf. 이번 장에서는 **‘메모리’**라는 용어 대신 **RAM**이라는 용어를 사용하겠습니다.

---

### 1.1 RAM의 특징

`CPU`는 **RAM으로부터 명령어와 데이터를 갖고와서 실행**하고, `RAM`은 **실행할 대상을 저장**합니다.

- `RAM`에는 `실행할 프로그램의 명령어`와 `데이터`가 저장됩니다.
- RAM은 **전원을 끄면 저장된 내용이 사라지는 저장 장치**입니다.
  - 즉, `휘발성 저장 장치(volatile memory)`입니다.
- 반면, 하드디스크같이 **전원이 꺼져도 저장된 내용이 유지되는 저장 장치**는
  - 즉, `비휘발성 저장 장치(non-volatile memory)`라고 합니다.
  - e.g. 하드디스크, SSD, CD-ROM, USB 메모리와 같은 보조기억장치

![MySelf-Architec-Oper_6_1](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_1.png)

`보조기억장치`는 **전원을 꺼도 내용을 유지**하지만, `CPU`는 **보조기억장치에 직접 접근하지 못합니다**.
그래서 일반적으로 `보조기억장치인 비휘발성 저장 장치`에는 **‘보관할 대상’을 저장**하고,
`휘발성 저장 장치인 RAM`에는 **‘실행할 대상’을 저장**합니다.
**CPU가 실행하고 싶은 프로그램**이 보조기억장치에 있다면, 이를 **RAM으로 복사하여 저장한 뒤 실행**합니다.

---

### 1.2 RAM의 용량과 성능

그렇다면 RAM 용량은 컴퓨터 성능에 어떤 영향을 미칠까요? RAM 용량이 크면 어떤 점이 좋을까요?

- CPU가 실행하고 싶은 프로그램이 보조기억장치에 있다면, 이를 RAM으로 가져와야 할 텐데,
- **RAM 용량이 적다면**, **보조기억장치에서 실행할 프로그램을 가져오는 일이 잦아 실행 시간이 길어집니다**.

![MySelf-Architec-Oper_6_2](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_2.png)

e.g. 위 그림처럼 **RAM 용량**이 프로그램 A, B, C 중 **하나만 저장할 수 있을만큼 작다면**,

- CPU가 프로그램 A를 실행하고 싶을 때는 보조기억장치에서 프로그램 A를 RAM으로 가지고 오고,
- 프로그램 B를 실행하고 싶을 때는 다시 프로그램 B를 RAM으로 가지고 오고,
- 프로그램 C를 실행하고 싶을 때는 또 다시 프로그램 C를 RAM으로 가지고 와야 합니다.

![MySelf-Architec-Oper_6_3](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_3.png)

e.g. 위 그림처럼 **RAM 용량이 충분히 크다면**, 보조기억장치에서 **많은 데이터를 한 번에 가져와 미리 RAM에 저장**

- **많은 프로그램을 동시에 실행하는 데 유리**하죠.
- RAM 용량이 충분히 크다면, 프로그램 A, B, C를 보조기억장치에서 여러 번 가져오는 수고를 덜 수 있습니다.

![MySelf-Architec-Oper_6_4](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_4.png)

CPU가 실행할 프로그램을 책에 빗대어 생각해 봅시다.

- `보조기억장치`는 **책이 꽂혀 있는 책장**과 같고, `RAM`은 **책을 읽을 수 있는 책상**과 같습니다.
- 책상이 크다면 책장으로부터 많은 책을 미리 책상으로 가져와 여러 권을 동시에 읽을 수 있기 때문에
  - 책을 가지러 왔다 갔다 하는 시간을 절약할 수 있습니다.
  - 이처럼 RAM 용량이 크면 많은 프로그램들을 동시에 빠르게 실행하는데 유리합니다.
- 그럼 **RAM 용량이 무지막지하게 크면 프로그램 실행 속도는 그에 비례하여 빨라질까요?**
  - **그렇지 않습니다.**
  - **RAM 용량이 커지면, 프로그램 실행 속도가 어느 정도 증가하**는 것은 맞지만,
  - **용량이 필요 이상으로 커졌을 때, 속도가 그에 비례하여 증가하지는 않습니다.**
  - 책을 100권 이상 올려놓을 수 있는 책상에서 책을 읽든,
  - 1,000권 이상 올려놓을 수 있는 책상에서 책을 읽든 간에
  - **책장을 오가는 시간에는 별 차이가 없는 것과 마찬가지**입니다.

---

### 1.3 RAM의 종류

#### 1.3.1 DRAM (Dynamic RAM)

- Dynamic = ‘동적이는, 움직이는’
- **저장된 데이터가 동적으로 변하는**(사라지는) RAM
  - 즉, **시간이 지나면 저장된 데이터가 점차 사라지는 RAM**
  - **데이터의 소멸을 막기 위해 일정 주기로 데이터를 재활성화**(다시 저장)해야 합니다.
- 이런 단점에도 불구하고, 우리가 일반적으로 메모리로써 사용하는 RAM은 DRAM
  - 소비 전력이 비교적 낮고, 저렴하고, 집적도가 높기 때문에 대용량으로 설계하기가 용이하기 때문
  - `집적도가 높다`는 의미는 **‘더 작고 빽빽하게 만들 수 있다’**는 말과 같습니다.

---

#### 1.3.2 SRAM (Static RAM)

- Static = ‘정적의, 변화가 없는’
- **저장된 데이터가 정적인**(사라지지 않는) RAM
- 시간이 지나면 점차 저장된 내용이 소실되는 DRAM과는 달리
  - SRAM은 **시간이 지나도 저장된 데이터가 사라지지 않습니다**.
  - cf. 시간이 지나도 저장된 데이터가 사라지지 않는다고 해서 SRAM이 비휘발성 메모리인 것은 아닙니다.
  - cf. SRAM도 전원이 공급되지 않으면 저장된 내용이 날아갑니다.
- **주기적으로 데이터를 재활성화할 필요도 없습니다.**
- 그리고 SRAM은 **DRAM보다 일반적으로 속도도 더 빠릅니다**.
- 하지만 SRAM은 DRAM보다 집적도가 낮고, 소비 전력도 크며, 가격도 더 비싸기 때문에,
  - 메모리로 사용되는 RAM은 일반적으로 SRAM이 아닌 DRAM입니다.
- 그래서 SRAM은 메모리가 아닌 **‘대용량으로 만들어질 필요는 없지만, 속도가 빨라야 하는 저장 장치’**에 사용
  - e.g. 가령 캐시 메모리에서 사용됩니다.
  - cf. 캐시 메모리가 무엇인지는 06-3절에서 살펴보겠습니다.

|           |      DRAM       |    SRAM     |
| :-------: | :-------------: | :---------: |
|  재충전   |     필요함      |  필요없음   |
|   속도    |      느림       |    빠름     |
|   가격    |     저렴함      |    비쌈     |
|  집적도   |      높음       |    낮음     |
| 소비 전력 |      적음       |    높음     |
| 사용 용도 | 주기억장치(RAM) | 캐시 메모리 |

---

#### 1.3.3 SDRAM (Synchronous Dynamic RAM)

- 이름만 보면 마치 SRAM과 DRAM의 합성어라고 오해하기 쉽지만, SDRAM은 SRAM 과 관계가 없습니다.
- Synchronous = 동기화
- 클럭 신호와 동기화된, 발전된 형태의 DRAM
  - **‘클럭 신호와 동기화되었다’**는 말은 **클럭 타이밍에 맞춰 CPU와 정보를 주고받을 수 있음**을 의미
- **클럭에 맞춰 동작하며 클럭마다 CPU와 정보를 주고받을 수 있는 DRAM**

---

#### 1.3.4 DDR SDRAM (Double Data Rate SDRAM)

![MySelf-Architec-Oper_6_5](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_5.png)

- 2023년 현재 가장 대중적으로 흔히 사용되는 RAM
- DDR SDRAM은 대역 폭을 넓혀 속도를 빠르게 만든 SDRAM
- `대역폭(data rate)`이란 **‘데이터를 주고받는 길의 너비’**를 의미
- e.g. 대역폭은 흔히 자동차 도로에 비유되곤 합니다.
  - 한 클럭에 하나씩 정보를 주고받을 수 있는 **SDRAM과 비교**했을 때,
    - `DDR SDRAM`은 **너비가 2배인 도로**와 같습니다.
  - 즉, **한 클럭에 한 번씩 CPU와 데이터를 주고받을 수 있는** `SDRAM`에 비해,
  - `DDR SDRAM`은 **2배의 대역폭으로 한 클럭당 두 번씩 CPU와 데이터를 주고받을 수** 있습니다.
  - 당연하게도 `DDR SDRAM`의 **전송 속도가 2배가량 빠릅니다**.
- cf. 이런 이유에서 한 클럭당 하나씩 데이터를 주고받을 수 있는 `SDRAM`을
  - `SDR SDRAM(Single Data Rate SDRAM)`이라 부르기도 합니다.

> 💡 DDR2, DDR3, DDR4
>
> - `DDR2 SDRAM`
>   - DDR SDRAM보다 **대역폭이 두 배 넓은 SDRAM**
>   - 다시 말해, DDR2 SDRAM은 SDR SDRAM보다 **너비가 4배 넓은 도로**와도 같습니다.
> - `DDR3 SDRAM`
>   - **DDR2 SDRAM보다 대역폭이 두 배 넓고**, SDR SDRAM보다 **대역폭이 8배 넓은 SDRAM**
> - `DDR4 SDRAM`
>   - 2023년 기준 최근에 흔히 사용하는 메모리
>   - **SDR SDRAM보다 16배 넓은 대역폭**을 가집니다.
>
> ![MySelf-Architec-Oper_6_6](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_6.png)

---

## 2. 메모리의 주소 공간

‘메모리에 저장된 정보의 위치는 주소로 나타낼 수 있다’ 정도로만 설명했지만, 사실 주소에는 두 종류가 있습니다.

![MySelf-Architec-Oper_6_7](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_7.png)

1. `물리 주소` : 메모리 하드웨어가 사용하는 주소
2. `논리 주소` : CPU와 실행 중인 프로그램이 사용하는 주소

이번 절에서는 이렇게 두 종류의 주소로 나뉘게 된 배경과 각 주소의 개념,
그리고 논리 주소를 물리 주소로 변환하는 방법에 대해 알아보겠습니다.

---

### 2.1 물리 주소와 논리 주소

> “CPU와 실행 중인 프로그램은 현재 메모리 몇 번지에 무엇이 저장되어 있는지 다 알고 있을까요?”

언뜻 생각하면 당연히 그럴 것 같지만, 실제로는 그렇지 않습니다.
`CPU`와 `메모리에 저장되어 실행 중인 프로그램`은 **메모리 몇 번지에 무엇이 저장되어 있는지 다 알지 못합니다**.

왜냐하면, **메모리에 저장된 정보는 시시각각 변하기 때문**입니다.

- 메모리는 **실행되는 프로그램은 새롭게 메모리에 적재**하고,
- **실행이 끝난 프로그램은 메모리에서 삭제**합니다.
- **같은 프로그램을 실행**하더라도, **실행할 때마다 적재되는 주소가 달라짐**
- e.g. 1500번지에 적재되었던 프로그램을 다시 실행하면 3000번지,
  - 또 다시 실행하면 2700번지에 적재될 수 있음
- 이런 상황에서 `CPU`와 `실행 중인 프로그램`이
  - 현재 메모리 몇 번지에 무엇이 저장되어 있는지 모두 알기 어렵습니다.

---

그래서 이런 점을 극복하기 위해서 주소 체계를 `물리 주소`와 `논리 주소`로 구분합니다.

- `물리 주소(physical address)`
  - **메모리 입장에서 바라본 주소**
  - 말 그대로 정보가 실제로 저장된 하드웨어상의 주소
- `논리 주소(logical address)`
  - **CPU와 실행 중인 프로그램 입장에서 바라본 주소**
  - 실행 중인 프로그램 각각에게 부여된 0번지부터 시작되는 주소

![MySelf-Architec-Oper_6_8](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_8.png)

e.g. 현재 메모리에 **메모장**, **게임**, **인터넷 브라우저** 프로그램이 적재되어 있다고 가정해보겠습니다.

- 메모장, 게임, 인터넷 브라우저 프로그램은
  - 현재 다른 프로그램들이 메모리 몇 번지에 저장되어 있는지,
  - 다시 말해 다른 프로그램들의 물리 주소가 무엇인지 굳이 알 필요가 없습니다.
- 새로운 프로그램이 언제든 적재될 수 있고,
  - 실행되지 않는 프로그램은 언제든 메모리에서 사라질 수 있기 때문입니다.
- 그래서 `메모장, 게임, 인터넷 브라우저`는 모두 **물리 주소가 아닌**
  - **0번지부터 시작하는 자신만을 위한 주소인 논리 주소를 가지고 있습니다**.
- e.g. ‘10번지’라는 주소는 메모장에도, 게임에도, 인터넷 브라우저에도 논리 주소로써 존재할 수 있습니다.
  - **프로그램마다 같은 논리 주소가 얼마든지 있을 수 있다는 뜻**입니다.
  - 그리고 CPU는 이 논리 주소를 받아들이고, 해석하고, 연산합니다.

---

![MySelf-Architec-Oper_6_9](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_9.png)

그런데 CPU가 이해하는 주소가 논리 주소라고는 해도 CPU가 메모리와 상호작용하려면,

- 논리 주소 와 물리 주소 간의 변환이 이루어져야 합니다.
- 논리 주소와 물리 주소 간에 어떠한 변환도 이루어지지 않는다면,
  - CPU와 메모리는 서로 이해할 수 없는 주소 체계를 가지고 각자 다른 이야기만 할 뿐,
  - 결코 상호작용할 수 없을 테니까요.

---

그렇다면 논리 주소는 어떻게 물리 주소로 변환될까요?

![MySelf-Architec-Oper_6_10](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_10.png)

- 논리 주소와 물리 주소 간의 변환은 CPU와 주소 버스 사이에 위치한
  - `메모리 관리 장치(MMU; Memory Management Unit)`라는 하드웨어에 의해 수행됩니다.
- `MMU`는 **CPU가 발생시킨 논리 주소**에 **베이스 레지스터 값**을 더하여 **논리 주소**를 **물리 주소로 변환**합니다.

![MySelf-Architec-Oper_6_11](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_11.png)

e.g. 현재 `베이스 레지스터`에 **15000이 저장**되어 있고, `CPU가 발생시킨 논리 주소`가 **100번지**라면

- 이 논리 주소는 위 그림처럼 물리 주소 `15100번지 (100 + 15000)`로 변환됩니다.
- **물리 주소 15000번지부터** 적재된 **프로그램 A의 논리 주소 100번지**에는 이렇게 접근이 가능한 것이지요.

---

![MySelf-Architec-Oper_6_12](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_12.png)

e.g. 만약 `베이스 레지스터`에 **45000이 저장**되어 있고, `CPU가 발생시킨 논리 주소`가 **100번지**라면

- 논리 주소는 물리 주소 `45100 ( 100 + 45000) 번지`로 변환됩니다.
- **물리 주소 45000번지부터** 적대된 **프로그램 C의 논리 주소 100번지**에는 이렇게 접근이 가능한 것입니다.

> 💡 정리
>
> - `베이스 레지스터`는 **프로그램의 가장 작은 물리 주소**, 즉 **프로그램의 첫 물리 주소를 저장**하는 셈이고,
> - `논리 주소`는 **프로그램의 시작점으로부터 떨어진 거리**인 셈입니다
>   - **실제로 저장되어 있는 그 프로그램으로부터 얼마나 떨어져있느냐에 해당하는 정보**

---

### 2.2 메모리 보호 기법

![MySelf-Architec-Oper_6_13](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_13.png)

`메모장 프로그램의 물리 주소`가 1000번지부터 1999번지,
`인터넷 브라우저 프로그램의 물리 주소`가 2000번지부터 2999번지,
`게임 프로그램의 물리 주소`가 3000번지부터 3999번지라고 가정해 보겠습니다.

- 만약 **메모장 프로그램 명령어** 중 ‘(논리 주소) **1500번지에 숫자 100을 저장하라**’와 같은 명령어가 있다면
- 숫자 100은 어떤 물리 주소에 저장될까요? 이 명령어는 실행되어도 안전할까요?

![MySelf-Architec-Oper_6_13](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_13-1676978419385-50.png)

혹은 인터넷 브라우저 프로그램 명령어 중 ‘(논리 주소) **1100번지의 데이터를 삭제하라**’와 같은 명령어가 있다면,

- 어떤 물리 주소의 데이터가 삭제될까요? 이 명령어는 실행되어도 안전할까요?

![MySelf-Architec-Oper_6_15](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_15.png)

짐작하겠지만, 위와 같은 명령어들은 실행되어서는 안됩니다. **프로그램의 논리 주소 영역을 벗어났기 때문**이지요.

- 위 명령어들이 실행된다면
- `메모장 프로그램 명령어`는 **애꿎은 인터넷 브라우저 프로그램에 숫자 10을 저장**하고,
- `인터넷 브라우저 프로그램 명령어`는 자신과는 **전혀 관련 없는 게임 프로그램 정보를 삭제**합니다.

---

#### 2.2.1 한계 레지스터

위와 같이, 다른 프로그램의 영역을 침범할 수 있는 명령어는 위험하기 때문에,
**논리 주소 범위를 벗어나는 명령어 실행을 방지**하고,
**실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호**할 방법이 필요합니다.
이 방법은 `한계 레지스터(limit register)`라고 하는 특별한 레지스터를 통해서 메모리를 보호합니다.

![MySelf-Architec-Oper_6_16](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_16.png)

- **프로그램의 영역을 침범할 수 있는 명령어의 실행을 막음**
- `베이스 레지스터`가 **실행 중인 프로그램의 가장 작은 물리 주소를 저장**한다면,
- `한계 레지스터`는 **논리 주소의 최대 크기를 저장**
- `베이스 레지스터 값 <= 프로그램의 물리 주소 범위 < 베이스 레지스터 값 + 한계 레지스터 값`
- 어떤 명령어가 **한 개 레지스터값보다 큰 논리 주소에 접근**하려고 하면,
  - **그 명령어의 실행을 막아주면 됩니다**.
  - 그러면 그 명령어가 다른 메모리 주소를 침범할 일은 없어지게 됩니다.

![MySelf-Architec-Oper_6_17](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_17.png)

e.g. `베이스 레지스터`에 100, `한계 레지스터`에 150이 저장되어 있다고 해 봅시다

- 이는 `물리 주소 시작점`이 **100번지**, `프로그램의 크기(논리 주소의 최대 크기)`는 **150**임을 의미합니다.
- 따라서 **이 프로그램은 150번지를 넘어서는 논리 주소를 가질 수 없습니다**.

![MySelf-Architec-Oper_6_18](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_18.png)

e.g. `베이스 레지스터`에 1500, `한계 레지스터`에 1000이 저장되어 있다고 해 봅시다.

- 이는 `물리 주소 시작점`이 1500번지, `프로그램 크기`는 1000임을 의미합니다.
- 따라서 **이 프로그램은 1000번지를 넘어서는 논리 주소를 가질 수 없습니다.**

![MySelf-Architec-Oper_6_19](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_19.png)

- 이처럼 `CPU`는 **메모리에 접근하기 전**,
  - 접근하고자 하는 `논리 주소`가 **한계 레지스터보다 작은지를 항상 검사**당합니다.
- 만약 `CPU`가 **한계 레지스터보다 높은 논리 주소에 접근**하려고 하면,
  - `인터럽트(트랩)`를 발생시켜 **실행을 중단**합니다.

이런 식으로 **실행 중인 프로그램의 독립적인 실행 공간을 확보**하고,
**하나의 프로그램이 다른 프로그램을 침범하지 못하게 보호**할 수 있습니다.

---

## 3. 캐시 메모리

![MySelf-Architec-Oper_6_20](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_20.png)

`CPU`는 프로그램을 실행하는 과정에서 `메모리`에 **저장된 데이터를 빈번하게 사용**합니다.

- 하지만 **CPU가 메모리에 접근하는 시간은 CPU의 연산 속도보다 느립니다.**
- CPU가 아무리 빨리 연산한다 해도, 메모리에 접근하는 시간이 느리면,
  - CPU의 빠른 연산 속도는 아무런 쓸모가 없죠?
  - 이를 **극복하기 위한 저장 장치**가 바로 `캐시 메모리`입니다.
- 캐시 메모리의 탄생 배경과 특징을 이해하려면, `저장 장치 계층 구조`라는 개념을 이해해야 합니다.

---

### 3.1 저장 장치 계층 구조(memory hierarchy)

모든 사용자들은 빠르고 동시에 용량이 큰 저장 장치를 원합니다.
하지만 안타깝게도 `빠른 저장 장치`와 `용량이 큰 저장 장치`는 **양립하기 어렵습니다.**
저장 장치는 일반적으로 다음과 같은 명제를 따릅니다.

1. **CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다.**
2. **속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비싸다.**

![MySelf-Architec-Oper_6_21](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_21.png)

e.g. 가령 CPU 내의 레지스터, 메모리(RAM), USB 메모리를 비교해볼까요?

- `CPU와 가장 가까운 레지스터`
  - 일반적으로 RAM보다 용량은 작지만, **접근 시간이 압도적으로 빠르고, 가격이 비쌈**
- `USB 메모리보다 CPU에 더 가까운 RAM`
  - USB보다 **접근 시간이 훨씬 더 빠르지만**, 같은 용량이라 할지라도 **가격은 더 비쌈**
- `USB 메모리`
  - 가장 느림
- cf. 위 계층으로 올라갈수록 CPU 와 가깝고 용량은 작지만 빠른 저장 장치
- cf. 아래 계층으로 내려갈수록 CPU와 멀고 용 량은 크지만 느린 저장 장치
- cf. 가격 또한 일반적으로 위 계층으로 올라갈수록 비싸고, 아래 계 층으로 내려갈수록 저렴

> 💡 저장 장치들의 장단점 정리
>
> 즉, **낮은 가격대의 대용량 저장 장치를 원한다면, 느린 속도는 감수**해야 하고,
> **빠른 메모리를 원한다면, 작은 용량과 비싼 가격은 감수**해야 합니다.
> 이렇게 저장 장치들의 장단점이 명확한데, 어느 하나의 저장 장치만을 사용할 수는 없겠죠?
> 그래서 일반적으로 컴퓨터는 **다양한 저장 장치를 모두 사용**합니다.

컴퓨터가 사용하는 저장 장치들은 **‘CPU에 얼마나 가까운가’를 기준으로 계층적**으로 나타낼 수 있습니다.

- 이를 `저장 장치 계층 구조(memory hierarchy)`라고 합니다.
- cf. 저장 장치 계층 구조를 영문으로 나타내면 memory hierarchy, 즉 **메모리 계층 구조**를 의미합니다.
  - 여기서 **‘메모리’**라는 용어는 **RAM이 아닌 ‘일반적인 저장 장치‘를 의미**합니다.
  - 이 책에서는 용어의 혼동을 방지하기 위해 **‘저장 장치 계층 구조’**라는 표현을 사용합니다.

---

### 3.2 캐시 메모리(cache memory)

- CPU와 메모리 사이에 위치하고,
  - **레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치**
- CPU의 연산 속도와 메모리 접근 속도의 차이를 조금이나마 줄이기 위해 탄생
- “CPU에서 **매번 메모리에 왔다 갔다 하는건 시간이 오래 걸리니**,
  - 메모리에서 **CPU가 사용할 일부 데이터를 미리 캐시 메모리로 가지고 와서** 쓰자”

![MySelf-Architec-Oper_6_22](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_22.png)

e.g. `CPU`를 **집**으로, `메모리에 접근하는 행위`를 **물건을 사러 가는 것**으로 비유하면,

- `메모리`는 마치 **‘물건은 많지만 집과는 멀리 떨어져 있어 왕복이 오래 걸리는 대형 마트’**이고,
- `캐시 메모리`는 **‘물건이 많지는 않아도 집과 가까이 있는 편의점’**과 같다고 보면 됩니다.

![MySelf-Architec-Oper_6_23](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_23.png)

- **편의점에 내가 필요한 물품이 있다면,**
  - 굳이 멀리 있는 대형 마트까지 갈 필요 없이 내가 원하는 물품을 얻을 수 있는 것처럼
- **캐시 메모리에 CPU가 필요로 하는 데이터가 있다면,**
  - 필요한 데이터로의 접근 시간을 줄일 수 있습니다

![MySelf-Architec-Oper_6_24](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_24.png)

캐시 메모리까지 반영한 저장 장치 계층 구조는 위 그림과 같이 그릴 수 있습니다.

![MySelf-Architec-Oper_6_25](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_25.png)

여러분이 사용하는 컴퓨터 내부에는 여러 개의 캐시 메모리가 있습니다.

- `캐시 메모리들`은 **CPU**(코어)와 **가까운 순서대로 계층을 구성**합니다.
- **코어와 가장 가까운 캐시 메모리**를 `L1(level 1) 캐시`,
- **그다음 가까운 캐시 메모리**를 `L2(level) 2 캐시`,
- **그다음 가까운 캐시 메모리**를 `L3(level 3) 캐시`라고 부릅니다.
- cf. 일반적으로 `L1 캐시`와 `L2 캐시`는 **코어 내부**에, `L3 캐시`는 **코어 외부**에 위치해 있습니다.
- 저장 장치 계층 구조를 이해했다면,
  - `캐시 메모리의 용량`은 L1, L2, L3 순으로 커지고, `속도`는 L3, L2, L1 순으로 빨라집니다.
  - `가격`은 일반적으로 **L3, L2, L1 순으로 비싸지지요**.
- CPU가 메모리 내에 데이터가 필요하다고 판단하면,
  - 우선 L1 캐시에 해당 데이터가 있는지를 알아보고,
  - 없다면 L2, L3 캐시 순으로 데이터를 검색합니다.

![MySelf-Architec-Oper_6_26](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_26.png)

- 멀티 코어 프로세서에서 `L1-L2-L3 캐시`는 일반적으로 위 그림과 같이 구현됩니다.
- `L1 캐시`와 `L2 캐시`는 **코어마다 고유한 캐시 메모리로 할당**되고,
- `L3 캐시`는 **여러 코어가 공유하는 형태로 사용**됩니다.

> 💡 분리형 캐시(split cache)
>
> ![MySelf-Architec-Oper_6_27](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_27.png)
>
> - 코어와 가장 가까운 L1 캐시는 조금이라도 접근 속도를 빠르게 만들기 위해,
> - 명령어만을 저장하는 L1 캐시인 `L1I 캐시`와
> - 데이터만을 저장하는 L1 캐시인 `L1D 캐시`로 분리하는 경우도 있습니다.
> - 이를 `분리형 캐시(split cache)`라고 합니다.

![MySelf-Architec-Oper_6_28](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_28.png)

이 구조를 외울 필요는 전혀 없습니다. 클라우드 서비스에서 제공하는 원격 스토리지와 같이 여기서 다루지 않는 저장 장치들도 얼마든지 저장 장치 계층 구조에 추가될 수 있으니까요. 중요한 것은 **상위 계층을 이루고 있는 저장 장치의 특징**과 **하위 계층을 이루고 있는 저장 장치의 특징을 이해하고 그 차이를 이해하는 것**입니다.

---

### 3.3 참조 지역성 원리

#### 3.3.1 캐시 히트(cache hit)

![MySelf-Architec-Oper_6_29](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_29.png)

- 캐시 메모리는 메모리보다 용량이 작다.
- 당연하게도 메모리의 모든 내용을 저장할 수 없다.
  - 메모리의 일부 내용들을 저장할 수 밖에 없습니다.
- 그렇다며 캐시 메모리는 메모리의 많은 정보 중 뭘 저장해야 할까?
  - 바로 **CPU가 자주 사용할 법한 내용을 예측하여 저장**합니다.
- 이렇게 **CPU가 자주 사용할 것으로 예측한 데이터가 실제로 CPU가 사용**했을 경우
  - 다시 말해, **예측이 적중**한 경우, 이를 `캐시 히트(cache hit)`라고 합니다.

---

#### 3.3.2 캐시 미스(cache miss)

![MySelf-Architec-Oper_6_30](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_30.png)

반대로 자주 사용될 것으로 예측하여 캐시 메모리에 저장했지만,

- **CPU가 메모리에서 필요한 데이터를 직접 가져와야 하는 경우**
- 다시 말해, **예측이 틀린 경우**, 이를 `캐시 미스(cache miss)`라고 합니다.
- 캐시 미스가 발생하면 CPU가 필요한 데이터를 메모리에서 직접 가져와야 하기 때문에
  - 캐시 메모리의 이점을 활용할 수 없습니다.
  - 당연히 캐시 미스가 자주 발생하면 성능이 떨어지게 되겠죠.
- cf. 캐시가 히트되는 비율을 `캐시 적중률(cache hit ratio)`이라 하고, 다음과 같이 계산합니다.
  - `캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)`
  - `캐시 히트 횟수`를 분자로 해서, 적중률을 알아낼 수 있음
  - 우리가 사용하는 컴퓨터의 캐시 적중률은 대략 85~95% 이상입니다.
  - CPU가 필요할 것으로 예측한 데이터를 100번 중 85~95번꼴로 맞추는 셈이지요.

**캐시 메모리의 이점을 제대로 활용**하려면, **CPU가 사용할 법한 데이터를 제대로 예측해서 캐시 적중률을 높여야** 합니다.
그렇다면 CPU가 사용할 법한 데이터는 어떻게 알 수 있을까요?

캐시 메모리는 한 가지 원칙에 따라 메모리로부터 가져올 데이터를 결정합니다.
바로 `참조 지역성의 원리(locality of reference, principle of locality)`입니다.
`참조 지역성의 원리`란 **CPU가 메모리에 접근할 때의 주된 경향을 바탕으로 만들어진 원리**입니다.

1. CPU는 **최근에 접근했던 메모리 공간에 다시 접근하려는 경향**이 있다.
2. CPU는 **접근한 메모리 공간 근처를 접근하려는 경향**이 있다.

하나씩 살펴봅시다.

---

##### (1) 시간 지역성(temporal locality)

첫째, **‘최근에 접근했던 메모리 공간에 다시 접근하려는 경향’**은 무엇일까요?

프로그래밍 언어를 배운 독자들은 **‘변수’**가 무엇인지 알고 있을 겁니다.

- 변수에 값을 저장하면, 언제든 변수에 다시 접근하여 변수에 저장된 값을 사용할 수 있습니다.
- 달리 말해 `CPU`는 **변수가 저장된 메모리 공간을 언제든 다시 참조할 수 있다**는 겁니다.
- `변수에 저장된 값`은 일반적으로 한 번만 사용되지 않고, **프로그램이 실행되는 동안 여러 번 사용**됩니다.
- 즉, `CPU`는 **최근에 접근했던** (변수가 저장된) **메모리 공간을 여러 번 다시 접근**할 수 있습니다.

가령 다음 코드를 봅시다. 이는 구구단 2단을 출력하는 간단한 코드입니다.

```c
#include <stdio.h>
int main(void) {
  int num = 2;
  for (int i = 1; i <= 9; i++)
    printf("%d X %d = %d\n", num, i, num * i);
  return 0;
}
```

위 코드에서 변수는 `num, i`입니다. 구구단 2단을 출력하는 과정에서 이 **변수들이 여러 번 사용**되고 있습니다.
이렇게 **‘최근에 접근했던 메모리 공간에 다시 접근하려는 경향’**을 `시간 지역성(temporal locality)`이라고 합니다.

---

##### (2) 공간 지역성(spatial locality)

둘째, ‘접근한 메모리 공간 근처를 접근하려는 경향’은 무엇일까요?

![MySelf-Architec-Oper_6_31](https://raw.githubusercontent.com/berenickt/image-server/main/img/MySelf-Architec-Oper_6_31.png)

`CPU가 실행하려는 프로그램`은 **보통 관련 데이터들끼리 한데 모여 있습니다**.
가령 메모리 내에 워드 프로세서, 웹 브라우저, 게임이 있다고 가정해 봅시다.

- 이 세 프로그램은 **서로 관련 있는 데이터끼리 모여서 저장**됩니다.
- `워드 프로세서`는 **워드 프로세서 관련 데이터들이 모여 저장**되고,
- `웹 브라우저`는 **웹 브라우저 관련 데이터들이 모여 저장**되고,
- `게임`은 **게임 관련 데이터들이 모여 저장**되지요.

그리고 **하나의 프로그램 내에서도 관련 있는 데이터들은 모여서 저장**됩니다.
가령 `워드 프로세서`에 자동 저장 기능, 입력 기능, 출력 기능이 있다고 했을 때,
**각각의 기능과 관련한 데이터는 모여 저장**됩니다.

CPU가 워드 프로세서 프로그램을 실행할 때는

- 워드 프로세서 프로그램이 모여 있는 공간 근처를 집중적으로 접근할 것이고,
- 사용자가 입력을 할 적에는 입력 기능이 모여 있는 공간 근처를 집중적으로 접근하겠죠?
- 이렇게 **‘접근한 메모리 공간 근처를 접근하려는 경향’**을 `공간 지역성(spatial locality)`이라고 합니다

`캐시 메모리`는 이렇듯 **참조 지역성의 원리에 입각해 CPU가 사용할 법한 데이터를 예측**합니다.
